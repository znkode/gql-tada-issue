import { Kind, OperationTypeNode, DocumentNode } from '@0no-co/graphql.web';

/** Constraints a given string to a string literal. */
type stringLiteral<T extends string> = string extends T ? never : string;
/** Returns `T` if it matches `Constraint` without being equal to it. Failing this evaluates to `Fallback` otherwise. */
type matchOr<Constraint, T, Fallback> = Constraint extends T
  ? Fallback
  : T extends Constraint
    ? T
    : Fallback;
/** Flattens a given object type.
 *
 * @remarks
 * This is typically used to make a TypeScript type appear as a flat object,
 * both in terms of type checking and for type hints and the tsserver output.
 */
type obj<T> = T extends {
  [key: string | number]: any;
}
  ? T extends infer U
    ? {
        [K in keyof U]: U[K];
      }
    : never
  : never;
/** Retrieves all non-nullish value types of an object dictionary. */
type objValues<T> = T[keyof T] extends infer U
  ? U extends null | undefined | never | void
    ? never
    : U
  : never;
/** Annotations for GraphQL’s `DocumentNode` with attached generics for its result data and variables types.
 *
 * @remarks
 * A GraphQL {@link DocumentNode} defines both the variables it accepts on request and the `data`
 * shape it delivers on a response in the GraphQL query language.
 *
 * To bridge the gap to TypeScript, tools may be used to generate TypeScript types that define the shape
 * of `data` and `variables` ahead of time. These types are then attached to GraphQL documents using this
 * `TypedDocumentNode` type.
 *
 * Using a `DocumentNode` that is typed like this will cause any `urql` API to type its input `variables`
 * and resulting `data` using the types provided.
 *
 * @privateRemarks
 * For compatibility reasons this type has been copied and internalized from:
 * https://github.com/dotansimha/graphql-typed-document-node/blob/3711b12/packages/core/src/index.ts#L3-L10
 *
 * @see {@link https://github.com/dotansimha/graphql-typed-document-node} for more information.
 */
interface DocumentDecoration<
  Result = {
    [key: string]: any;
  },
  Variables = {
    [key: string]: any;
  },
> {
  /** Type to support `@graphql-typed-document-node/core`
   * @internal
   */
  __apiType?: (variables: Variables) => Result;
  /** Type to support `TypedQueryDocumentNode` from `graphql`
   * @internal
   */
  __ensureTypesOfVariablesAndResultMatching?: (variables: Variables) => Result;
}

/** Format of introspection data queryied from your schema.
 *
 * @remarks
 * You must provide your introspected schema in the standard introspection
 * format (as represented by this type) to `setupSchema` to configure this
 * library to use your types.
 *
 * @see {@link setupSchema} for where to use this data.
 */
interface IntrospectionQuery {
  readonly __schema: IntrospectionSchema;
}
interface IntrospectionSchema {
  readonly queryType: IntrospectionNamedTypeRef;
  readonly mutationType?: IntrospectionNamedTypeRef | null;
  readonly subscriptionType?: IntrospectionNamedTypeRef | null;
  readonly types: readonly any[];
}
interface IntrospectionScalarType {
  readonly kind: 'SCALAR';
  readonly name: string;
  readonly specifiedByURL?: string | null;
}
interface IntrospectionObjectType {
  readonly kind: 'OBJECT';
  readonly name: string;
  readonly fields: readonly any[];
}
interface IntrospectionInterfaceType {
  readonly kind: 'INTERFACE';
  readonly name: string;
  readonly fields: readonly any[];
  readonly possibleTypes: readonly IntrospectionNamedTypeRef[];
}
interface IntrospectionUnionType {
  readonly kind: 'UNION';
  readonly name: string;
  readonly possibleTypes: readonly IntrospectionNamedTypeRef[];
}
interface IntrospectionEnumValue {
  readonly name: string;
}
interface IntrospectionEnumType {
  readonly kind: 'ENUM';
  readonly name: string;
  readonly enumValues: readonly IntrospectionEnumValue[];
}
interface IntrospectionInputObjectType {
  readonly kind: 'INPUT_OBJECT';
  readonly name: string;
  readonly inputFields: readonly IntrospectionInputValue[];
}
interface IntrospectionListTypeRef {
  readonly kind: 'LIST';
  readonly ofType: IntrospectionTypeRef;
}
interface IntrospectionNonNullTypeRef {
  readonly kind: 'NON_NULL';
  readonly ofType: IntrospectionTypeRef;
}
type IntrospectionTypeRef =
  | IntrospectionNamedTypeRef
  | IntrospectionListTypeRef
  | IntrospectionNonNullTypeRef;
interface IntrospectionNamedTypeRef {
  readonly name: string;
}
interface IntrospectionField {
  readonly name: string;
  readonly type: IntrospectionTypeRef;
}
interface IntrospectionInputValue {
  readonly name: string;
  readonly type: IntrospectionTypeRef;
  readonly defaultValue?: string | null;
}
interface DefaultScalars {
  ID: number | string;
  Boolean: boolean;
  String: string;
  Float: number;
  Int: number;
}
type mapScalar<
  Type extends IntrospectionScalarType,
  Scalars extends ScalarsLike = DefaultScalars,
> = {
  kind: 'SCALAR';
  name: Type['name'];
  type: Type['name'] extends keyof Scalars
    ? Scalars[Type['name']]
    : Type['name'] extends keyof DefaultScalars
      ? DefaultScalars[Type['name']]
      : unknown;
};
type mapEnum<T extends IntrospectionEnumType> = {
  kind: 'ENUM';
  name: T['name'];
  type: T['enumValues'][number]['name'];
};
type mapField<T> = T extends IntrospectionField
  ? {
      name: T['name'];
      type: T['type'];
    }
  : never;
type mapObject<T extends IntrospectionObjectType> = {
  kind: 'OBJECT';
  name: T['name'];
  fields: obj<{
    [P in T['fields'][number]['name']]: T['fields'][number] extends infer Field
      ? Field extends {
          readonly name: P;
        }
        ? mapField<Field>
        : never
      : never;
  }>;
};
type mapInputObject<T extends IntrospectionInputObjectType> = {
  kind: 'INPUT_OBJECT';
  name: T['name'];
  inputFields: [...T['inputFields']];
};
type mapInterface<T extends IntrospectionInterfaceType> = {
  kind: 'INTERFACE';
  name: T['name'];
  possibleTypes: T['possibleTypes'][number]['name'];
  fields: obj<{
    [P in T['fields'][number]['name']]: T['fields'][number] extends infer Field
      ? Field extends {
          readonly name: P;
        }
        ? mapField<Field>
        : never
      : never;
  }>;
};
type mapUnion<T extends IntrospectionUnionType> = {
  kind: 'UNION';
  name: T['name'];
  fields: {};
  possibleTypes: T['possibleTypes'][number]['name'];
};
type mapType<
  Type,
  Scalars extends ScalarsLike = DefaultScalars,
> = Type extends IntrospectionScalarType
  ? mapScalar<Type, Scalars>
  : Type extends IntrospectionEnumType
    ? mapEnum<Type>
    : Type extends IntrospectionObjectType
      ? mapObject<Type>
      : Type extends IntrospectionInterfaceType
        ? mapInterface<Type>
        : Type extends IntrospectionUnionType
          ? mapUnion<Type>
          : Type extends IntrospectionInputObjectType
            ? mapInputObject<Type>
            : never;
type mapIntrospectionTypes<
  Query extends IntrospectionQuery,
  Scalars extends ScalarsLike = DefaultScalars,
> = obj<{
  [P in Query['__schema']['types'][number]['name']]: Query['__schema']['types'][number] extends infer Type
    ? Type extends {
        readonly name: P;
      }
      ? mapType<Type, Scalars>
      : never
    : never;
}>;
type mapIntrospection<
  Query extends IntrospectionQuery,
  Scalars extends ScalarsLike = DefaultScalars,
> = {
  query: Query['__schema']['queryType']['name'];
  mutation: Query['__schema']['mutationType'] extends {
    name: string;
  }
    ? Query['__schema']['mutationType']['name']
    : never;
  subscription: Query['__schema']['subscriptionType'] extends {
    name: string;
  }
    ? Query['__schema']['subscriptionType']['name']
    : never;
  types: mapIntrospectionTypes<Query, Scalars>;
};
type getScalarType$1<
  Schema extends IntrospectionLikeType,
  Name extends string,
  OrType = never,
> = Schema['types'][Name] extends {
  kind: 'SCALAR';
  type: infer Type;
}
  ? Type | OrType
  : Schema['types'][Name] extends {
        kind: 'ENUM';
        type: infer Type;
      }
    ? Type | OrType
    : never;
type ScalarsLike = {
  [name: string]: any;
};
type IntrospectionLikeType = {
  query: string;
  mutation?: any;
  subscription?: any;
  types: {
    [name: string]: any;
  };
};

type digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
type letter =
  | 'A'
  | 'B'
  | 'C'
  | 'D'
  | 'E'
  | 'F'
  | 'G'
  | 'H'
  | 'I'
  | 'J'
  | 'K'
  | 'L'
  | 'M'
  | 'N'
  | 'O'
  | 'P'
  | 'Q'
  | 'R'
  | 'S'
  | 'T'
  | 'U'
  | 'V'
  | 'W'
  | 'X'
  | 'Y'
  | 'Z'
  | 'a'
  | 'b'
  | 'c'
  | 'd'
  | 'e'
  | 'f'
  | 'g'
  | 'h'
  | 'i'
  | 'j'
  | 'k'
  | 'l'
  | 'm'
  | 'n'
  | 'o'
  | 'p'
  | 'q'
  | 'r'
  | 's'
  | 't'
  | 'u'
  | 'v'
  | 'w'
  | 'x'
  | 'y'
  | 'z';
type skipIgnored<In> = In extends `#${infer _}\n${infer In}`
  ? skipIgnored<In>
  : In extends `${' ' | '\n' | '\t' | '\r' | ',' | '\ufeff'}${infer In}`
    ? skipIgnored<In>
    : In extends string
      ? In
      : never;
type skipDigits<In> = In extends `${digit}${infer In}` ? skipDigits<In> : In;
type skipInt<In> = In extends `${'-'}${digit}${infer In}`
  ? skipDigits<In>
  : In extends `${digit}${infer In}`
    ? skipDigits<In>
    : void;
type skipExponent<In> = In extends `${'e' | 'E'}${'+' | '-'}${infer In}`
  ? skipDigits<In>
  : In extends `${'e' | 'E'}${infer In}`
    ? skipDigits<In>
    : In;
type skipFloat<In> = In extends `${'.'}${infer In}`
  ? In extends `${digit}${infer In}`
    ? skipExponent<skipDigits<In>>
    : void
  : In extends `${'e' | 'E'}${infer _}`
    ? skipExponent<In>
    : void;
type skipBlockString<In> = In extends `${infer Hd}${'"""'}${infer In}`
  ? Hd extends `${infer _}${'\\'}`
    ? skipBlockString<skipIgnored<In>>
    : In
  : void;
type skipString<In> = In extends `${infer Hd}${'"'}${infer In}`
  ? Hd extends `${infer _}${'\\'}`
    ? skipString<In>
    : In
  : void;
type _takeNameLiteralRec<PrevMatch extends string, In> = In extends `${infer Match}${infer Out}`
  ? Match extends letter | digit | '_'
    ? _takeNameLiteralRec<`${PrevMatch}${Match}`, Out>
    : [PrevMatch, In]
  : [PrevMatch, In];
type takeNameLiteral<In> = In extends `${infer Match}${infer In}`
  ? Match extends letter | '_'
    ? _takeNameLiteralRec<Match, In>
    : void
  : void;
type takeName<In> = takeNameLiteral<In> extends [infer Out, infer In]
  ? [
      {
        kind: Kind.NAME;
        value: Out;
      },
      In,
    ]
  : void;
type takeOptionalName<In> = takeNameLiteral<In> extends [infer Out, infer In]
  ? [
      {
        kind: Kind.NAME;
        value: Out;
      },
      In,
    ]
  : [undefined, In];
type takeEnum<In> = takeNameLiteral<In> extends [infer Out, infer In]
  ? [
      {
        kind: Kind.ENUM;
        value: Out;
      },
      In,
    ]
  : void;
type TakeVariable<In, Const> = Const extends false
  ? In extends `${'$'}${infer In}`
    ? takeNameLiteral<In> extends [infer Out, infer In]
      ? [
          {
            kind: Kind.VARIABLE;
            name: {
              kind: Kind.NAME;
              value: Out;
            };
          },
          In,
        ]
      : void
    : void
  : void;
type takeNumber<In> = skipInt<In> extends `${infer In}`
  ? skipFloat<In> extends `${infer In}`
    ? [
        {
          kind: Kind.FLOAT;
          value: string;
        },
        In,
      ]
    : [
        {
          kind: Kind.INT;
          value: string;
        },
        In,
      ]
  : void;
type takeString<In> = In extends `${'"""'}${infer In}`
  ? skipBlockString<In> extends `${infer In}`
    ? [
        {
          kind: Kind.STRING;
          value: string;
          block: true;
        },
        In,
      ]
    : void
  : In extends `${'"'}${infer In}`
    ? skipString<In> extends `${infer In}`
      ? [
          {
            kind: Kind.STRING;
            value: string;
            block: false;
          },
          In,
        ]
      : void
    : void;
type takeLiteral<In> = In extends `${'null'}${infer In}`
  ? [
      {
        kind: Kind.NULL;
      },
      In,
    ]
  : In extends `${'true' | 'false'}${infer In}`
    ? [
        {
          kind: Kind.BOOLEAN;
          value: boolean;
        },
        In,
      ]
    : void;
type takeValue<In, Const> = takeLiteral<In> extends [infer Node, infer Rest]
  ? [Node, Rest]
  : TakeVariable<In, Const> extends [infer Node, infer Rest]
    ? [Node, Rest]
    : takeNumber<In> extends [infer Node, infer Rest]
      ? [Node, Rest]
      : takeEnum<In> extends [infer Node, infer Rest]
        ? [Node, Rest]
        : takeString<In> extends [infer Node, infer Rest]
          ? [Node, Rest]
          : takeList<In, Const> extends [infer Node, infer Rest]
            ? [Node, Rest]
            : takeObject<In, Const> extends [infer Node, infer Rest]
              ? [Node, Rest]
              : void;
type _takeListRec<Nodes extends any[], In, Const> = In extends `${']'}${infer In}`
  ? [
      {
        kind: Kind.LIST;
        values: Nodes;
      },
      In,
    ]
  : takeValue<skipIgnored<In>, Const> extends [infer Node, infer In]
    ? _takeListRec<[...Nodes, Node], skipIgnored<In>, Const>
    : void;
type takeList<In, Const> = In extends `${'['}${infer In}`
  ? _takeListRec<[], skipIgnored<In>, Const>
  : void;
type takeObjectField<In, Const> = takeName<In> extends [infer Name, infer In]
  ? skipIgnored<In> extends `${':'}${infer In}`
    ? takeValue<skipIgnored<In>, Const> extends [infer Value, infer In]
      ? [
          {
            kind: Kind.OBJECT_FIELD;
            name: Name;
            value: Value;
          },
          In,
        ]
      : void
    : void
  : void;
type _takeObjectRec<Fields extends any[], In, Const> = In extends `${'}'}${infer In}`
  ? [
      {
        kind: Kind.OBJECT;
        fields: Fields;
      },
      In,
    ]
  : takeObjectField<skipIgnored<In>, Const> extends [infer Field, infer In]
    ? _takeObjectRec<[...Fields, Field], skipIgnored<In>, Const>
    : void;
type takeObject<In, Const> = In extends `${'{'}${infer In}`
  ? _takeObjectRec<[], skipIgnored<In>, Const>
  : void;
type takeArgument<In, Const> = takeName<In> extends [infer Name, infer In]
  ? skipIgnored<In> extends `${':'}${infer In}`
    ? takeValue<skipIgnored<In>, Const> extends [infer Value, infer In]
      ? [
          {
            kind: Kind.ARGUMENT;
            name: Name;
            value: Value;
          },
          In,
        ]
      : void
    : void
  : void;
type _takeArgumentsRec<Arguments extends any[], In, Const> = In extends `${')'}${infer In}`
  ? Arguments extends []
    ? void
    : [Arguments, In]
  : takeArgument<In, Const> extends [infer Argument, infer In]
    ? _takeArgumentsRec<[...Arguments, Argument], skipIgnored<In>, Const>
    : void;
type takeArguments<In, Const> = In extends `${'('}${infer In}`
  ? _takeArgumentsRec<[], skipIgnored<In>, Const>
  : [[], In];
type takeDirective<In, Const> = In extends `${'@'}${infer In}`
  ? takeName<In> extends [infer Name, infer In]
    ? takeArguments<skipIgnored<In>, Const> extends [infer Arguments, infer In]
      ? [
          {
            kind: Kind.DIRECTIVE;
            name: Name;
            arguments: Arguments;
          },
          In,
        ]
      : void
    : void
  : void;
type takeDirectives<In, Const> = takeDirective<In, Const> extends [infer Directive, infer In]
  ? takeDirectives<skipIgnored<In>, Const> extends [[...infer Directives], infer In]
    ? [[Directive, ...Directives], In]
    : [[], In]
  : [[], In];
type takeFieldName<In> = takeName<In> extends [infer MaybeAlias, infer In]
  ? skipIgnored<In> extends `${':'}${infer In}`
    ? takeName<skipIgnored<In>> extends [infer Name, infer In]
      ? [MaybeAlias, Name, In]
      : void
    : [undefined, MaybeAlias, In]
  : void;
type takeField<In> = takeFieldName<In> extends [infer Alias, infer Name, infer In]
  ? takeArguments<skipIgnored<In>, false> extends [infer Arguments, infer In]
    ? takeDirectives<skipIgnored<In>, false> extends [infer Directives, infer In]
      ? takeSelectionSet<skipIgnored<In>> extends [infer SelectionSet, infer In]
        ? [
            {
              kind: Kind.FIELD;
              alias: Alias;
              name: Name;
              arguments: Arguments;
              directives: Directives;
              selectionSet: SelectionSet;
            },
            In,
          ]
        : [
            {
              kind: Kind.FIELD;
              alias: Alias;
              name: Name;
              arguments: Arguments;
              directives: Directives;
              selectionSet: undefined;
            },
            In,
          ]
      : void
    : void
  : void;
type takeType<In> = In extends `${'['}${infer In}`
  ? takeType<skipIgnored<In>> extends [infer Subtype, infer In]
    ? In extends `${']'}${infer In}`
      ? skipIgnored<In> extends `${'!'}${infer In}`
        ? [
            {
              kind: Kind.NON_NULL_TYPE;
              type: {
                kind: Kind.LIST_TYPE;
                type: Subtype;
              };
            },
            In,
          ]
        : [
            {
              kind: Kind.LIST_TYPE;
              type: Subtype;
            },
            In,
          ]
      : void
    : void
  : takeName<skipIgnored<In>> extends [infer Name, infer In]
    ? skipIgnored<In> extends `${'!'}${infer In}`
      ? [
          {
            kind: Kind.NON_NULL_TYPE;
            type: {
              kind: Kind.NAMED_TYPE;
              name: Name;
            };
          },
          In,
        ]
      : [
          {
            kind: Kind.NAMED_TYPE;
            name: Name;
          },
          In,
        ]
    : void;
type takeTypeCondition<In> = In extends `${'on'}${infer In}`
  ? takeName<skipIgnored<In>> extends [infer Name, infer In]
    ? [
        {
          kind: Kind.NAMED_TYPE;
          name: Name;
        },
        In,
      ]
    : void
  : void;
type takeFragmentSpread<In> = In extends `${'...'}${infer In}`
  ? skipIgnored<In> extends `${'on'}${infer In}`
    ? takeName<skipIgnored<In>> extends [infer Name, infer In]
      ? takeDirectives<skipIgnored<In>, false> extends [infer Directives, infer In]
        ? takeSelectionSet<skipIgnored<In>> extends [infer SelectionSet, infer In]
          ? [
              {
                kind: Kind.INLINE_FRAGMENT;
                typeCondition: {
                  kind: Kind.NAMED_TYPE;
                  name: Name;
                };
                directives: Directives;
                selectionSet: SelectionSet;
              },
              In,
            ]
          : void
        : void
      : void
    : takeName<skipIgnored<In>> extends [infer Name, infer In]
      ? takeDirectives<skipIgnored<In>, false> extends [infer Directives, infer In]
        ? [
            {
              kind: Kind.FRAGMENT_SPREAD;
              name: Name;
              directives: Directives;
            },
            In,
          ]
        : void
      : takeDirectives<skipIgnored<In>, false> extends [infer Directives, infer In]
        ? takeSelectionSet<skipIgnored<In>> extends [infer SelectionSet, infer In]
          ? [
              {
                kind: Kind.INLINE_FRAGMENT;
                typeCondition: undefined;
                directives: Directives;
                selectionSet: SelectionSet;
              },
              In,
            ]
          : void
        : void
  : void;
type _takeSelectionRec<Selections extends any[], In> = In extends `${'}'}${infer In}`
  ? [
      {
        kind: Kind.SELECTION_SET;
        selections: Selections;
      },
      In,
    ]
  : takeFragmentSpread<skipIgnored<In>> extends [infer Selection, infer In]
    ? _takeSelectionRec<[...Selections, Selection], skipIgnored<In>>
    : takeField<skipIgnored<In>> extends [infer Selection, infer In]
      ? _takeSelectionRec<[...Selections, Selection], skipIgnored<In>>
      : void;
type takeSelectionSet<In> = In extends `${'{'}${infer In}`
  ? _takeSelectionRec<[], skipIgnored<In>>
  : void;
type takeVarDefinition<In> = TakeVariable<In, false> extends [infer Variable, infer In]
  ? skipIgnored<In> extends `${':'}${infer In}`
    ? takeType<skipIgnored<In>> extends [infer Type, infer In]
      ? skipIgnored<In> extends `${'='}${infer In}`
        ? takeValue<skipIgnored<In>, true> extends [infer DefaultValue, infer In]
          ? takeDirectives<skipIgnored<In>, true> extends [infer Directives, infer In]
            ? [
                {
                  kind: Kind.VARIABLE_DEFINITION;
                  variable: Variable;
                  type: Type;
                  defaultValue: DefaultValue;
                  directives: Directives;
                },
                In,
              ]
            : void
          : void
        : takeDirectives<skipIgnored<In>, true> extends [infer Directives, infer In]
          ? [
              {
                kind: Kind.VARIABLE_DEFINITION;
                variable: Variable;
                type: Type;
                defaultValue: undefined;
                directives: Directives;
              },
              In,
            ]
          : void
      : void
    : void
  : void;
type _takeVarDefinitionRec<Definitions extends any[], In> = In extends `${')'}${infer In}`
  ? [Definitions, In]
  : takeVarDefinition<In> extends [infer Definition, infer In]
    ? _takeVarDefinitionRec<[...Definitions, Definition], skipIgnored<In>>
    : void;
type takeVarDefinitions<In> = skipIgnored<In> extends `${'('}${infer In}`
  ? _takeVarDefinitionRec<[], skipIgnored<In>>
  : [[], In];
type takeFragmentDefinition<In> = In extends `${'fragment'}${infer In}`
  ? takeName<skipIgnored<In>> extends [infer Name, infer In]
    ? takeTypeCondition<skipIgnored<In>> extends [infer TypeCondition, infer In]
      ? takeDirectives<skipIgnored<In>, true> extends [infer Directives, infer In]
        ? takeSelectionSet<skipIgnored<In>> extends [infer SelectionSet, infer In]
          ? [
              {
                kind: Kind.FRAGMENT_DEFINITION;
                name: Name;
                typeCondition: TypeCondition;
                directives: Directives;
                selectionSet: SelectionSet;
              },
              In,
            ]
          : void
        : void
      : void
    : void
  : void;
type TakeOperation<In> = In extends `${'query'}${infer In}`
  ? [OperationTypeNode.QUERY, In]
  : In extends `${'mutation'}${infer In}`
    ? [OperationTypeNode.MUTATION, In]
    : In extends `${'subscription'}${infer In}`
      ? [OperationTypeNode.SUBSCRIPTION, In]
      : void;
type takeOperationDefinition<In> = TakeOperation<In> extends [infer Operation, infer In]
  ? takeOptionalName<skipIgnored<In>> extends [infer Name, infer In]
    ? takeVarDefinitions<skipIgnored<In>> extends [infer VarDefinitions, infer In]
      ? takeDirectives<skipIgnored<In>, false> extends [infer Directives, infer In]
        ? takeSelectionSet<skipIgnored<In>> extends [infer SelectionSet, infer In]
          ? [
              {
                kind: Kind.OPERATION_DEFINITION;
                operation: Operation;
                name: Name;
                variableDefinitions: VarDefinitions;
                directives: Directives;
                selectionSet: SelectionSet;
              },
              In,
            ]
          : void
        : void
      : void
    : void
  : takeSelectionSet<skipIgnored<In>> extends [infer SelectionSet, infer In]
    ? [
        {
          kind: Kind.OPERATION_DEFINITION;
          operation: OperationTypeNode.QUERY;
          name: undefined;
          variableDefinitions: [];
          directives: [];
          selectionSet: SelectionSet;
        },
        In,
      ]
    : void;
type _takeDocumentRec<Definitions extends any[], In> = takeFragmentDefinition<In> extends [
  infer Definition,
  infer In,
]
  ? _takeDocumentRec<[...Definitions, Definition], skipIgnored<In>>
  : takeOperationDefinition<In> extends [infer Definition, infer In]
    ? _takeDocumentRec<[...Definitions, Definition], skipIgnored<In>>
    : [Definitions, In];
type parseDocument<In> = _takeDocumentRec<[], skipIgnored<In>> extends [
  [...infer Definitions],
  infer _Rest,
]
  ? Definitions extends []
    ? never
    : {
        kind: Kind.DOCUMENT;
        definitions: Definitions;
      }
  : never;
type DocumentNodeLike = {
  kind: Kind.DOCUMENT;
  definitions: any[];
};

/** Private namespace holding our symbols for markers.
 *
 * @remarks
 * Markers are used to indicate, for example, which fragments a given GraphQL document
 * is referring to or which fragments a document exposes. This ties into “fragment masking”,
 * a process by which the type of a fragment is hidden away until it’s unwrapped, to enforce
 * isolation and code-reuse.
 */
declare namespace $tada {
  const fragmentRefs: unique symbol;
  type fragmentRefs = typeof fragmentRefs;
  const definition: unique symbol;
  type definition = typeof definition;
  const ref: unique symbol;
  type ref = typeof ref;
}
interface FragmentDefDecorationLike {
  fragment: any;
  on: any;
  masked: any;
}
type isMaskedRec<Directives extends readonly unknown[] | undefined> = Directives extends readonly [
  infer Directive,
  ...infer Rest,
]
  ? Directive extends {
      kind: Kind.DIRECTIVE;
      name: any;
    }
    ? Directive['name']['value'] extends '_unmask'
      ? false
      : isMaskedRec<Rest>
    : isMaskedRec<Rest>
  : true;
type decorateFragmentDef<Document extends DocumentNodeLike> = Document['definitions'][0] extends {
  kind: Kind.FRAGMENT_DEFINITION;
  name: any;
}
  ? {
      fragment: Document['definitions'][0]['name']['value'];
      on: Document['definitions'][0]['typeCondition']['name']['value'];
      masked: isMaskedRec<Document['definitions'][0]['directives']>;
    }
  : void;
type getFragmentsOfDocumentsRec<Documents> = Documents extends readonly [
  infer Document,
  ...infer Rest,
]
  ? (Document extends {
      [$tada.definition]?: any;
    }
      ? Exclude<Document[$tada.definition], undefined> extends infer Definition extends
          FragmentDefDecorationLike
        ? {
            [Name in Definition['fragment']]: {
              kind: Kind.FRAGMENT_DEFINITION;
              name: {
                kind: Kind.NAME;
                value: Definition['fragment'];
              };
              typeCondition: {
                kind: Kind.NAMED_TYPE;
                name: {
                  kind: Kind.NAME;
                  value: Definition['on'];
                };
              };
              [$tada.ref]: makeFragmentRef<Document>;
            };
          }
        : {}
      : {}) &
      getFragmentsOfDocumentsRec<Rest>
  : {};
type makeFragmentRef<Document> = Document extends {
  [$tada.definition]?: infer Definition;
}
  ? Definition extends FragmentDefDecorationLike
    ? Definition['masked'] extends false
      ? Document extends DocumentDecoration<infer Result, any>
        ? Result
        : {
            [$tada.fragmentRefs]: {
              [Name in Definition['fragment']]: $tada.ref;
            };
          }
      : {
          [$tada.fragmentRefs]: {
            [Name in Definition['fragment']]: $tada.ref;
          };
        }
    : never
  : never;
type omitFragmentRefsRec<Data> = Data extends readonly (infer Value)[]
  ? readonly omitFragmentRefsRec<Value>[]
  : Data extends null
    ? null
    : Data extends undefined
      ? undefined
      : Data extends {}
        ? {
            [Key in Exclude<keyof Data, $tada.fragmentRefs>]: omitFragmentRefsRec<Data[Key]>;
          }
        : Data;
type makeUndefinedFragmentRef<FragmentName extends string> = {
  [$tada.fragmentRefs]: {
    [Name in FragmentName]: 'Undefined Fragment';
  };
};
type makeDefinitionDecoration<Definition = FragmentDefDecorationLike> = {
  [Key in $tada.definition]?: Definition;
};

type ObjectLikeType = {
  kind: 'OBJECT' | 'INTERFACE' | 'UNION';
  name: string;
  fields: {
    [key: string]: any;
  };
};
type _unwrapTypeRec$1<
  Type,
  SelectionSet,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
> = Type extends {
  readonly kind: 'NON_NULL';
  readonly ofType: any;
}
  ? _unwrapTypeRec$1<Type['ofType'], SelectionSet, Introspection, Fragments>
  : Type extends {
        readonly kind: 'LIST';
        readonly ofType: any;
      }
    ? Array<unwrapType$1<Type['ofType'], SelectionSet, Introspection, Fragments>>
    : Type extends {
          readonly name: string;
        }
      ? Introspection['types'][Type['name']] extends ObjectLikeType
        ? SelectionSet extends {
            kind: Kind.SELECTION_SET;
            selections: any;
          }
          ? getSelection<
              SelectionSet['selections'],
              Introspection['types'][Type['name']],
              Introspection,
              Fragments
            >
          : unknown
        : Introspection['types'][Type['name']]['type']
      : unknown;
type unwrapType$1<
  Type,
  SelectionSet,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
  TypeDirective = void,
> = Type extends {
  readonly kind: 'NON_NULL';
  readonly ofType: any;
}
  ? TypeDirective extends 'optional'
    ? null | _unwrapTypeRec$1<Type['ofType'], SelectionSet, Introspection, Fragments>
    : _unwrapTypeRec$1<Type['ofType'], SelectionSet, Introspection, Fragments>
  : TypeDirective extends 'required'
    ? _unwrapTypeRec$1<Type, SelectionSet, Introspection, Fragments>
    : null | _unwrapTypeRec$1<Type, SelectionSet, Introspection, Fragments>;
type getTypeDirective<Node> = Node extends {
  directives: any[];
}
  ? Node['directives'][number]['name']['value'] & ('required' | '_required') extends never
    ? Node['directives'][number]['name']['value'] & ('optional' | '_optional') extends never
      ? void
      : 'optional'
    : 'required'
  : void;
type isOptional<Node> = Node extends {
  directives: any[];
}
  ? Node['directives'][number]['name']['value'] & ('include' | 'skip' | 'defer') extends never
    ? false
    : true
  : false;
type getFieldAlias<Node> = Node extends {
  alias: undefined;
  name: any;
}
  ? Node['name']['value']
  : Node extends {
        alias: any;
      }
    ? Node['alias']['value']
    : never;
type getFragmentSelection<
  Node,
  Type extends ObjectLikeType,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
> = Node extends {
  kind: Kind.INLINE_FRAGMENT;
  selectionSet: any;
}
  ? getSelection<Node['selectionSet']['selections'], Type, Introspection, Fragments>
  : Node extends {
        kind: Kind.FRAGMENT_SPREAD;
        name: any;
      }
    ? Node['name']['value'] extends keyof Fragments
      ? Fragments[Node['name']['value']] extends {
          [$tada.ref]: any;
        }
        ? Fragments[Node['name']['value']][$tada.ref]
        : getSelection<
            Fragments[Node['name']['value']]['selectionSet']['selections'],
            Type,
            Introspection,
            Fragments
          >
      : {}
    : {};
type getSpreadSubtype<
  Node,
  BaseType extends ObjectLikeType,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
> = Node extends {
  kind: Kind.INLINE_FRAGMENT;
  typeCondition?: any;
}
  ? Node['typeCondition'] extends {
      kind: Kind.NAMED_TYPE;
      name: any;
    }
    ? Introspection['types'][Node['typeCondition']['name']['value']]
    : BaseType
  : Node extends {
        kind: Kind.FRAGMENT_SPREAD;
        name: any;
      }
    ? Node['name']['value'] extends keyof Fragments
      ? Introspection['types'][Fragments[Node['name']['value']]['typeCondition']['name']['value']]
      : void
    : void;
type getTypenameOfType<Type> =
  | (Type extends {
      name: any;
    }
      ? Type['name']
      : never)
  | (Type extends {
      possibleTypes: any;
    }
      ? Type['possibleTypes']
      : never);
type getSelection<
  Selections,
  Type extends ObjectLikeType,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
> = obj<
  Type extends {
    kind: 'UNION' | 'INTERFACE';
    possibleTypes: any;
  }
    ? objValues<{
        [PossibleType in Type['possibleTypes']]: _getPossibleTypeSelectionRec<
          Selections,
          PossibleType,
          Type,
          Introspection,
          Fragments
        >;
      }>
    : Type extends {
          kind: 'OBJECT';
          name: any;
        }
      ? _getPossibleTypeSelectionRec<Selections, Type['name'], Type, Introspection, Fragments>
      : {}
>;
type _getPossibleTypeSelectionRec<
  Selections,
  PossibleType extends string,
  Type extends ObjectLikeType,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
  SelectionAcc = {},
> = Selections extends [infer Node, ...infer Rest]
  ? _getPossibleTypeSelectionRec<
      Rest,
      PossibleType,
      Type,
      Introspection,
      Fragments,
      (Node extends {
        kind: Kind.FRAGMENT_SPREAD | Kind.INLINE_FRAGMENT;
      }
        ? getSpreadSubtype<Node, Type, Introspection, Fragments> extends infer Subtype extends
            ObjectLikeType
          ? PossibleType extends getTypenameOfType<Subtype>
            ?
                | (isOptional<Node> extends true ? {} : never)
                | getFragmentSelection<Node, Subtype, Introspection, Fragments>
            : {}
          : Node extends {
                kind: Kind.FRAGMENT_SPREAD;
                name: any;
              }
            ? makeUndefinedFragmentRef<Node['name']['value']>
            : {}
        : Node extends {
              kind: Kind.FIELD;
              name: any;
              selectionSet: any;
            }
          ? isOptional<Node> extends true
            ? {
                [Prop in getFieldAlias<Node>]?: Node['name']['value'] extends '__typename'
                  ? PossibleType
                  : unwrapType$1<
                      Type['fields'][Node['name']['value']]['type'],
                      Node['selectionSet'],
                      Introspection,
                      Fragments,
                      getTypeDirective<Node>
                    >;
              }
            : {
                [Prop in getFieldAlias<Node>]: Node['name']['value'] extends '__typename'
                  ? PossibleType
                  : unwrapType$1<
                      Type['fields'][Node['name']['value']]['type'],
                      Node['selectionSet'],
                      Introspection,
                      Fragments,
                      getTypeDirective<Node>
                    >;
              }
          : {}) &
        SelectionAcc
    >
  : SelectionAcc;
type getOperationSelectionType<
  Definition,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
> = Definition extends {
  kind: Kind.OPERATION_DEFINITION;
  selectionSet: any;
  operation: any;
}
  ? Introspection['types'][Introspection[Definition['operation']]] extends infer Type extends
      ObjectLikeType
    ? getSelection<Definition['selectionSet']['selections'], Type, Introspection, Fragments>
    : {}
  : never;
type getFragmentSelectionType<
  Definition,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  },
> = Definition extends {
  kind: Kind.FRAGMENT_DEFINITION;
  selectionSet: any;
  typeCondition: any;
}
  ? Introspection['types'][Definition['typeCondition']['name']['value']] extends infer Type extends
      ObjectLikeType
    ? getSelection<Definition['selectionSet']['selections'], Type, Introspection, Fragments>
    : never
  : never;
type getDocumentType<
  Document extends DocumentNodeLike,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  } = {},
> = Document['definitions'] extends readonly [infer Definition, ...infer Rest]
  ? Definition extends {
      kind: Kind.OPERATION_DEFINITION;
    }
    ? getOperationSelectionType<Definition, Introspection, getFragmentMapRec<Rest> & Fragments>
    : Definition extends {
          kind: Kind.FRAGMENT_DEFINITION;
        }
      ? getFragmentSelectionType<Definition, Introspection, getFragmentMapRec<Rest> & Fragments>
      : never
  : never;
type getFragmentMapRec<Definitions> = Definitions extends readonly [infer Definition, ...infer Rest]
  ? (Definition extends {
      kind: Kind.FRAGMENT_DEFINITION;
      name: any;
    }
      ? {
          [Name in Definition['name']['value']]: Definition;
        }
      : {}) &
      getFragmentMapRec<Rest>
  : {};

type getInputObjectTypeRec<
  InputFields,
  Introspection extends IntrospectionLikeType,
  InputObject = {},
> = InputFields extends [infer InputField, ...infer Rest]
  ? getInputObjectTypeRec<
      Rest,
      Introspection,
      (InputField extends {
        name: any;
        type: any;
      }
        ? InputField['type'] extends {
            kind: 'NON_NULL';
          }
          ? {
              [Name in InputField['name']]: unwrapType<InputField['type'], Introspection>;
            }
          : {
              [Name in InputField['name']]?: unwrapType<InputField['type'], Introspection>;
            }
        : {}) &
        InputObject
    >
  : InputObject;
type getScalarType<
  TypeName,
  Introspection extends IntrospectionLikeType,
> = TypeName extends keyof Introspection['types']
  ? Introspection['types'][TypeName] extends {
      kind: 'SCALAR' | 'ENUM';
      type: any;
    }
    ? Introspection['types'][TypeName]['type']
    : Introspection['types'][TypeName] extends {
          kind: 'INPUT_OBJECT';
          inputFields: any;
        }
      ? obj<getInputObjectTypeRec<Introspection['types'][TypeName]['inputFields'], Introspection>>
      : never
  : unknown;
type _unwrapTypeRec<TypeRef, Introspection extends IntrospectionLikeType> = TypeRef extends {
  kind: 'NON_NULL';
  ofType: any;
}
  ? _unwrapTypeRec<TypeRef['ofType'], Introspection>
  : TypeRef extends {
        kind: 'LIST';
        ofType: any;
      }
    ? Array<unwrapType<TypeRef['ofType'], Introspection>>
    : TypeRef extends {
          name: any;
        }
      ? getScalarType<TypeRef['name'], Introspection>
      : unknown;
type unwrapType<Type, Introspection extends IntrospectionLikeType> = Type extends {
  kind: 'NON_NULL';
  ofType: any;
}
  ? _unwrapTypeRec<Type['ofType'], Introspection>
  : null | _unwrapTypeRec<Type, Introspection>;
type _unwrapTypeRefRec<Type, Introspection extends IntrospectionLikeType> = Type extends {
  kind: Kind.NON_NULL_TYPE;
  type: any;
}
  ? _unwrapTypeRefRec<Type['type'], Introspection>
  : Type extends {
        kind: Kind.LIST_TYPE;
        type: any;
      }
    ? Array<unwrapTypeRef<Type['type'], Introspection>>
    : Type extends {
          kind: Kind.NAMED_TYPE;
          name: any;
        }
      ? getScalarType<Type['name']['value'], Introspection>
      : unknown;
type unwrapTypeRef<Type, Introspection extends IntrospectionLikeType> = Type extends {
  kind: Kind.NON_NULL_TYPE;
  type: any;
}
  ? _unwrapTypeRefRec<Type['type'], Introspection>
  : null | _unwrapTypeRefRec<Type, Introspection>;
type _getVariablesRec<
  Variables,
  Introspection extends IntrospectionLikeType,
  VariablesObject = {},
> = Variables extends [infer Variable, ...infer Rest]
  ? _getVariablesRec<
      Rest,
      Introspection,
      (Variable extends {
        kind: Kind.VARIABLE_DEFINITION;
        variable: any;
        type: any;
      }
        ? Variable extends {
            defaultValue: undefined;
            type: {
              kind: Kind.NON_NULL_TYPE;
            };
          }
          ? {
              [Name in Variable['variable']['name']['value']]: unwrapTypeRef<
                Variable['type'],
                Introspection
              >;
            }
          : {
              [Name in Variable['variable']['name']['value']]?: unwrapTypeRef<
                Variable['type'],
                Introspection
              >;
            }
        : {}) &
        VariablesObject
    >
  : VariablesObject;
type getVariablesType<
  Document extends DocumentNodeLike,
  Introspection extends IntrospectionLikeType,
> = Document['definitions'][0] extends {
  kind: Kind.OPERATION_DEFINITION;
  variableDefinitions: any;
}
  ? obj<_getVariablesRec<Document['definitions'][0]['variableDefinitions'], Introspection>>
  : {};

/** Abstract configuration type input for your schema and scalars.
 *
 * @remarks
 * This is used either via {@link setupSchema} or {@link initGraphQLTada} to set
 * up your schema and scalars.
 *
 * The `scalars` option is optional and can be used to set up more scalars, apart
 * from the default ones (like: Int, Float, String, Boolean).
 * It must be an object map of scalar names to their desired TypeScript types.
 *
 * @param introspection - Introspection of your schema matching {@link IntrospectionQuery}.
 * @param scalars - An object type with scalar names as keys and the corresponding scalar types as values.
 */
interface AbstractSetupSchema {
  introspection: IntrospectionQuery;
  scalars?: ScalarsLike;
}
/** This is used to configure gql.tada with your introspection data and scalars.
 *
 * @remarks
 * You may extend this interface via declaration merging with your {@link IntrospectionQuery}
 * data and optionally your scalars to get proper type inference.
 * This is done by declaring a declaration for it as per the following example.
 *
 * Configuring scalars is optional and by default the standard scalrs are already
 * defined.
 *
 * This will configure the {@link graphql} export to infer types from your schema.
 * Alternatively, you may call {@link initGraphQLTada} instead.
 *
 * @param introspection - Introspection of your schema matching {@link IntrospectionQuery}.
 * @param scalars - An object type with scalar names as keys and the corresponding scalar types as values.
 *
 * @example
 * ```
 * import type { myIntrospection } from './myIntrospection';
 *
 * declare module 'gql.tada' {
 *   interface setupSchema {
 *     introspection: typeof myIntrospection;
 *     scalars: {
 *       DateTime: string;
 *       Json: any;
 *     };
 *   }
 * }
 * ```
 */
interface setupSchema extends AbstractSetupSchema {}
interface GraphQLTadaAPI<Schema extends IntrospectionLikeType> {
  /** Function to create and compose GraphQL documents with result and variable types.
   *
   * @param input - A string of a GraphQL document.
   * @param fragments - An optional list of other GraphQL fragments created with this function.
   * @returns A {@link DocumentNode} with result and variables types.
   *
   * @remarks
   * This function creates a {@link DocumentNode} with result and variables types.
   * It is used with your schema in {@link setupSchema} to create a result type
   * of your queries, fragments, and variables.
   *
   * You can compose fragments into this function by passing them and a fragment
   * mask will be created for them.
   * When creating queries, the returned document of queries can be passed into GraphQL clients
   * which will then automatically infer the result and variables types.
   *
   * @example
   * ```
   * import { graphql } from 'gql.tada';
   *
   * const bookFragment = graphql(`
   *   fragment BookComponent on Book {
   *     id
   *     title
   *   }
   * `);
   *
   * const bookQuery = graphql(`
   *   query Book ($id: ID!) {
   *     book(id: $id) {
   *       id
   *       ...BookComponent
   *     }
   *   }
   * `, [bookFragment]);
   * ```
   *
   * @see {@link readFragment} for how to read from fragment masks.
   */
  <
    const In extends stringLiteral<In>,
    const Fragments extends readonly [...makeDefinitionDecoration[]],
  >(
    input: In,
    fragments?: Fragments
  ): getDocumentNode<parseDocument<In>, Schema, getFragmentsOfDocumentsRec<Fragments>>;
  /** Function to validate the type of a given scalar or enum value.
   *
   * @param name - The name of a scalar or enum type.
   * @param value - An optional scalar value of the given type.
   * @returns A {@link DocumentNode} with result and variables types.
   *
   * @remarks
   * This function validates that a value matches an enum or scalar type
   * as a type check.
   *
   * You can use it to retrieve the type of a given scalar or enum type
   * for use in a utility function or separate component that only
   * accepts a primitive scalar or enum value.
   *
   * Note that this function does not perform runtime checks of your
   * scalar value!
   *
   * @example
   * ```
   * import { graphql } from 'gql.tada';
   *
   * type myEnum = ReturnType<graphql.scalar<'myEnum'>>;
   *
   * const myEnumValue = graphql.scalar('myEnum', 'value');
   * ```
   */
  scalar<
    const Name extends stringLiteral<Name>,
    const Value extends getScalarType$1<Schema, Name, null | undefined>,
  >(
    name: Name,
    value: Value
  ): Value;
  scalar<const Name extends stringLiteral<Name>>(
    name: Name,
    value?: getScalarType$1<Schema, Name>
  ): getScalarType$1<Schema, Name>;
}
type schemaOfConfig<Setup extends AbstractSetupSchema> = mapIntrospection<
  matchOr<IntrospectionQuery, Setup['introspection'], never>,
  matchOr<ScalarsLike, Setup['scalars'], {}>
>;
/** Setup function to create a typed `graphql` document function with.
 *
 * @remarks
 * `initGraphQLTada` accepts an {@link AbstractSetupSchema} configuration object as a generic
 * and returns a `graphql` function that may be used to create documents typed using your
 * GraphQL schema.
 *
 * You should use and re-export the resulting function named as `graphql` or `gql` for your
 * editor and the TypeScript language server to recognize your GraphQL documents correctly.
 *
 * @example
 * ```
 * import { initGraphQLTada } from 'gql.tada';
 * import type { myIntrospection } from './myIntrospection';
 *
 * export const graphql = initGraphQLTada<{
 *   introspection: typeof myIntrospection;
 *   scalars: {
 *     DateTime: string;
 *     Json: any;
 *   };
 * }>();
 *
 * const query = graphql(`{ __typename }`);
 * ```
 */
declare function initGraphQLTada<const Setup extends AbstractSetupSchema>(): GraphQLTadaAPI<
  schemaOfConfig<Setup>
>;
/** Alias to a GraphQL parse function returning an exact document type.
 *
 * @param input - A string of a GraphQL document
 * @returns A parsed {@link DocumentNode}.
 *
 * @remarks
 * This function accepts a GraphQL document string and parses it, just like
 * GraphQL’s `parse` function. However, its return type will be the exact
 * structure of the AST parsed in types.
 */
declare function parse<const In extends stringLiteral<In>>(input: In): parseDocument<In>;
type getDocumentNode<
  Document extends DocumentNodeLike,
  Introspection extends IntrospectionLikeType,
  Fragments extends {
    [name: string]: any;
  } = {},
> = getDocumentType<Document, Introspection, Fragments> extends infer Result
  ? Result extends never
    ? never
    : TadaDocumentNode<
        Result,
        getVariablesType<Document, Introspection>,
        decorateFragmentDef<Document>
      >
  : never;
/** A GraphQL `DocumentNode` with attached types for results and variables.
 *
 * @remarks
 * This is a GraphQL {@link DocumentNode} with attached types for results and variables.
 * This is used by GraphQL clients to infer the types of results and variables and provide
 * type-safety in GraphQL documents.
 *
 * You can create typed GraphQL documents using the {@link graphql} function.
 *
 * `Result` is the type of GraphQL results, as returned by GraphQL APIs for a given query.
 * `Variables` is the type of variables, as accepted by GraphQL APIs for a given query.
 *
 * @see {@link https://github.com/dotansimha/graphql-typed-document-node} for more information.
 */
interface TadaDocumentNode<
  Result = {
    [key: string]: any;
  },
  Variables = {
    [key: string]: any;
  },
  Decoration = void,
> extends DocumentNode,
    DocumentDecoration<Result, Variables>,
    makeDefinitionDecoration<Decoration> {}
/** A utility type returning the `Result` type of typed GraphQL documents.
 *
 * @remarks
 * This accepts a {@link TadaDocumentNode} and returns the attached `Result` type
 * of GraphQL documents.
 */
type ResultOf<Document> = Document extends DocumentDecoration<infer Result, any> ? Result : never;
/** A utility type returning the `Variables` type of typed GraphQL documents.
 *
 * @remarks
 * This accepts a {@link TadaDocumentNode} and returns the attached `Variables` type
 * of GraphQL documents.
 */
type VariablesOf<Document> = Document extends DocumentDecoration<any, infer Variables>
  ? Variables
  : never;
/** Creates a fragment mask for a given fragment document.
 *
 * @remarks
 * When {@link graphql} is used to create a fragment and is spread into another
 * fragment or query, their result types will only contain a “reference” to the
 * fragment. This encourages isolation and is known as “fragment masking.”
 *
 * While {@link readFragment} is used to unmask these fragment masks, this utility
 * creates a fragment mask, so you can accept the masked data in the part of your
 * codebase that defines a fragment.
 *
 * @example
 * ```
 * import { FragmentOf, graphql, readFragment } from 'gql.tada';
 *
 * const bookFragment = graphql(`
 *   fragment BookComponent on Book {
 *     id
 *     title
 *   }
 * `);
 *
 * // May be called with any GraphQL data that contains a spread of `bookFragment`
 * const getBook = (data: FragmentOf<typeof bookFragment>) => {
 *   // Unmasks the fragment and casts to the result type of `bookFragment`
 *   const book = readFragment(bookFragment, data);
 * };
 * ```
 *
 * @see {@link readFragment} for how to read from fragment masks.
 */
type FragmentOf<Document extends makeDefinitionDecoration> = makeFragmentRef<Document>;
type mirrorFragmentTypeRec<Fragment, Data> = Fragment extends (infer Value)[]
  ? mirrorFragmentTypeRec<Value, Data>[]
  : Fragment extends readonly (infer Value)[]
    ? readonly mirrorFragmentTypeRec<Value, Data>[]
    : Fragment extends null
      ? null
      : Fragment extends undefined
        ? undefined
        : Data;
type fragmentRefsOfFragmentsRec<Fragments extends readonly any[]> = Fragments extends readonly [
  infer Fragment,
  ...infer Rest,
]
  ? obj<makeFragmentRef<Fragment> & fragmentRefsOfFragmentsRec<Rest>>
  : {};
type resultOfFragmentsRec<Fragments extends readonly any[]> = Fragments extends readonly [
  infer Fragment,
  ...infer Rest,
]
  ? ResultOf<Fragment> & resultOfFragmentsRec<Rest>
  : {};
type fragmentOfTypeRec<Document extends makeDefinitionDecoration> =
  | readonly fragmentOfTypeRec<Document>[]
  | FragmentOf<Document>
  | undefined
  | null;
type resultOfTypeRec<Data> = readonly resultOfTypeRec<Data>[] | Data | undefined | null;
/** Unmasks a fragment mask for a given fragment document and data.
 *
 * @param _document - A GraphQL document of a fragment, created using {@link graphql}.
 * @param fragment - A mask of the fragment, which can be wrapped in arrays, or nullable.
 * @returns The unmasked data of the fragment.
 *
 * @remarks
 * When {@link graphql} is used to create a fragment and is spread into another
 * fragment or query, their result types will only contain a “reference” to the
 * fragment. This encourages isolation and is known as “fragment masking.”
 *
 * This means that you must use {@link readFragment} to unmask these fragment masks
 * and get to the data. This encourages isolation and only using the data you define
 * a part of your codebase to require.
 *
 * @example
 * ```
 * import { FragmentOf, graphql, readFragment } from 'gql.tada';
 *
 * const bookFragment = graphql(`
 *   fragment BookComponent on Book {
 *     id
 *     title
 *   }
 * `);
 *
 * const getBook = (data: FragmentOf<typeof bookFragment> | null) => {
 *   // Unmasks the fragment and casts to the result type of `bookFragment`
 *   // This is intersected with `| null` in this case, due to the input type.
 *   const book = readFragment(bookFragment, data);
 * };
 *
 * const bookQuery = graphql(`
 *   query Book ($id: ID!) {
 *     book(id: $id) {
 *       id
 *       ...BookComponent
 *     }
 *   }
 * `, [bookFragment]);
 *
 * const getQuery = (data: ResultOf<typeof bookQuery>) => {
 *   getBook(data?.book);
 * };
 * ```
 *
 * @see {@link readFragment} for how to read from fragment masks.
 */
declare function readFragment<
  const Document extends makeDefinitionDecoration & DocumentDecoration<any, any>,
  const Fragment extends fragmentOfTypeRec<Document>,
>(
  _document: Document,
  fragment: Fragment
): fragmentOfTypeRec<Document> extends Fragment
  ? never
  : mirrorFragmentTypeRec<Fragment, ResultOf<Document>>;
/** For testing, masks fragment data for given data and fragments.
 *
 * @param _fragments - A list of GraphQL documents of fragments, created using {@link graphql}.
 * @param data - The combined result data of the fragments, which can be wrapped in arrays.
 * @returns The masked data of the fragments.
 *
 * @remarks
 * When creating test data, you may define data for fragments that’s unmasked, making it
 * unusable in parent fragments or queries that require masked data.
 *
 * This means that you may have to use {@link maskFragments} to mask your data first
 * for TypeScript to not report an error.
 *
 * @example
 * ```
 * import { FragmentOf, ResultOf, graphql, maskFragments } from 'gql.tada';
 *
 * const bookFragment = graphql(`
 *   fragment BookComponent on Book {
 *     id
 *     title
 *   }
 * `);
 *
 * const data = maskFragments([bookFragment], { id: 'id', title: 'book' });
 * ```
 *
 * @see {@link readFragment} for how to read from fragment masks (i.e. the reverse)
 */
declare function maskFragments<
  const Fragments extends readonly [...makeDefinitionDecoration[]],
  const Data extends resultOfTypeRec<resultOfFragmentsRec<Fragments>>,
>(
  _fragments: Fragments,
  data: Data
): resultOfTypeRec<resultOfFragmentsRec<Fragments>> extends Data
  ? never
  : mirrorFragmentTypeRec<Data, fragmentRefsOfFragmentsRec<Fragments>>;
/** For testing, converts document data without fragment refs to their result type.
 *
 * @param _document - A GraphQL document, created using {@link graphql}.
 * @param data - The result data of the GraphQL document with optional fragment refs.
 * @returns The masked result data of the document.
 *
 * @remarks
 * When creating test data, you may define data for documents that’s unmasked, but
 * need to cast the data to match the result type of your document.
 *
 * This means that you may have to use {@link unsafe_readResult} to cast
 * them to the result type, instead of doing `as any as ResultOf<typeof document>`.
 *
 * This function is inherently unsafe, since it doesn't check that your document
 * actually contains the masked fragment data!
 *
 * @example
 * ```
 * import { FragmentOf, ResultOf, graphql, unsafe_readResult } from 'gql.tada';
 *
 * const bookFragment = graphql(`
 *   fragment BookComponent on Book {
 *     id
 *     title
 *   }
 * `);
 *
 * const query = graphql(`
 *   query {
 *     book {
 *       ...BookComponent
 *     }
 *   }
 * `, [bookFragment]);
 *
 * const data = unsafe_readResult(query, { book: { id: 'id', title: 'book' } });
 * ```
 *
 * @see {@link readFragment} for how to read from fragment masks (i.e. the reverse)
 */
declare function unsafe_readResult<
  const Document extends DocumentDecoration<any, any>,
  const Data extends omitFragmentRefsRec<ResultOf<Document>>,
>(_document: Document, data: Data): ResultOf<Document>;
declare const graphql: GraphQLTadaAPI<schemaOfConfig<setupSchema>>;

export {
  type AbstractSetupSchema,
  type FragmentOf,
  type GraphQLTadaAPI,
  type ResultOf,
  type TadaDocumentNode,
  type VariablesOf,
  graphql,
  initGraphQLTada,
  maskFragments,
  parse,
  type parseDocument,
  readFragment,
  type setupSchema,
  unsafe_readResult,
};
