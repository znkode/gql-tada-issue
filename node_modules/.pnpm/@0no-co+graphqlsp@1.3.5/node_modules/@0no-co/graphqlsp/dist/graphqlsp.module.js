import e from "node-fetch";

import n from "path";

import r from "fs";

var i;

function init$1(e) {
  i = e.typescript;
}

function devAssert(e, n) {
  if (!Boolean(e)) {
    throw new Error(n);
  }
}

function isPromise(e) {
  return "function" == typeof (null == e ? void 0 : e.then);
}

function isObjectLike(e) {
  return "object" == typeof e && null !== e;
}

function invariant$1(e, n) {
  if (!Boolean(e)) {
    throw new Error(null != n ? n : "Unexpected invariant triggered.");
  }
}

var a = /\r\n|[\n\r]/g;

function getLocation$1(e, n) {
  var r = 0;
  var i = 1;
  for (var s of e.body.matchAll(a)) {
    "number" == typeof s.index || invariant$1(!1);
    if (s.index >= n) {
      break;
    }
    r = s.index + s[0].length;
    i += 1;
  }
  return {
    line: i,
    column: n + 1 - r
  };
}

function printLocation(e) {
  return printSourceLocation(e.source, getLocation$1(e.source, e.start));
}

function printSourceLocation(e, n) {
  var r = e.locationOffset.column - 1;
  var i = "".padStart(r) + e.body;
  var a = n.line - 1;
  var s = n.line + (e.locationOffset.line - 1);
  var o = n.column + (1 === n.line ? r : 0);
  var l = `${e.name}:${s}:${o}\n`;
  var u = i.split(/\r\n|[\n\r]/g);
  var c = u[a];
  if (c.length > 120) {
    var d = Math.floor(o / 80);
    var f = o % 80;
    var v = [];
    for (var h = 0; h < c.length; h += 80) {
      v.push(c.slice(h, h + 80));
    }
    return l + printPrefixedLines([ [ `${s} |`, v[0] ], ...v.slice(1, d + 1).map((e => [ "|", e ])), [ "|", "^".padStart(f) ], [ "|", v[d + 1] ] ]);
  }
  return l + printPrefixedLines([ [ s - 1 + " |", u[a - 1] ], [ `${s} |`, c ], [ "|", "^".padStart(o) ], [ `${s + 1} |`, u[a + 1] ] ]);
}

function printPrefixedLines(e) {
  var n = e.filter((([e, n]) => void 0 !== n));
  var r = Math.max(...n.map((([e]) => e.length)));
  return n.map((([e, n]) => e.padStart(r) + (n ? " " + n : ""))).join("\n");
}

class GraphQLError extends Error {
  constructor(e, ...n) {
    var r, i, a;
    var {nodes: s, source: o, positions: l, path: u, originalError: c, extensions: d} = function toNormalizedOptions(e) {
      var n = e[0];
      if (null == n || "kind" in n || "length" in n) {
        return {
          nodes: n,
          source: e[1],
          positions: e[2],
          path: e[3],
          originalError: e[4],
          extensions: e[5]
        };
      }
      return n;
    }(n);
    super(e);
    this.name = "GraphQLError";
    this.path = null != u ? u : void 0;
    this.originalError = null != c ? c : void 0;
    this.nodes = undefinedIfEmpty(Array.isArray(s) ? s : s ? [ s ] : void 0);
    var f = undefinedIfEmpty(null === (r = this.nodes) || void 0 === r ? void 0 : r.map((e => e.loc)).filter((e => null != e)));
    this.source = null != o ? o : null == f ? void 0 : null === (i = f[0]) || void 0 === i ? void 0 : i.source;
    this.positions = null != l ? l : null == f ? void 0 : f.map((e => e.start));
    this.locations = l && o ? l.map((e => getLocation$1(o, e))) : null == f ? void 0 : f.map((e => getLocation$1(e.source, e.start)));
    var v = isObjectLike(null == c ? void 0 : c.extensions) ? null == c ? void 0 : c.extensions : void 0;
    this.extensions = null !== (a = null != d ? d : v) && void 0 !== a ? a : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    });
    if (null != c && c.stack) {
      Object.defineProperty(this, "stack", {
        value: c.stack,
        writable: !0,
        configurable: !0
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: !0,
        configurable: !0
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    var e = this.message;
    if (this.nodes) {
      for (var n of this.nodes) {
        if (n.loc) {
          e += "\n\n" + printLocation(n.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (var r of this.locations) {
        e += "\n\n" + printSourceLocation(this.source, r);
      }
    }
    return e;
  }
  toJSON() {
    var e = {
      message: this.message
    };
    if (null != this.locations) {
      e.locations = this.locations;
    }
    if (null != this.path) {
      e.path = this.path;
    }
    if (null != this.extensions && Object.keys(this.extensions).length > 0) {
      e.extensions = this.extensions;
    }
    return e;
  }
}

function undefinedIfEmpty(e) {
  return void 0 === e || 0 === e.length ? void 0 : e;
}

function syntaxError(e, n, r) {
  return new GraphQLError(`Syntax Error: ${r}`, {
    source: e,
    positions: [ n ]
  });
}

let s = class Location {
  constructor(e, n, r) {
    this.start = e.start;
    this.end = n.end;
    this.startToken = e;
    this.endToken = n;
    this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};

class Token {
  constructor(e, n, r, i, a, s) {
    this.kind = e;
    this.start = n;
    this.end = r;
    this.line = i;
    this.column = a;
    this.value = s;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}

var o = {
  Name: [],
  Document: [ "definitions" ],
  OperationDefinition: [ "name", "variableDefinitions", "directives", "selectionSet" ],
  VariableDefinition: [ "variable", "type", "defaultValue", "directives" ],
  Variable: [ "name" ],
  SelectionSet: [ "selections" ],
  Field: [ "alias", "name", "arguments", "directives", "selectionSet" ],
  Argument: [ "name", "value" ],
  FragmentSpread: [ "name", "directives" ],
  InlineFragment: [ "typeCondition", "directives", "selectionSet" ],
  FragmentDefinition: [ "name", "variableDefinitions", "typeCondition", "directives", "selectionSet" ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: [ "values" ],
  ObjectValue: [ "fields" ],
  ObjectField: [ "name", "value" ],
  Directive: [ "name", "arguments" ],
  NamedType: [ "name" ],
  ListType: [ "type" ],
  NonNullType: [ "type" ],
  SchemaDefinition: [ "description", "directives", "operationTypes" ],
  OperationTypeDefinition: [ "type" ],
  ScalarTypeDefinition: [ "description", "name", "directives" ],
  ObjectTypeDefinition: [ "description", "name", "interfaces", "directives", "fields" ],
  FieldDefinition: [ "description", "name", "arguments", "type", "directives" ],
  InputValueDefinition: [ "description", "name", "type", "defaultValue", "directives" ],
  InterfaceTypeDefinition: [ "description", "name", "interfaces", "directives", "fields" ],
  UnionTypeDefinition: [ "description", "name", "directives", "types" ],
  EnumTypeDefinition: [ "description", "name", "directives", "values" ],
  EnumValueDefinition: [ "description", "name", "directives" ],
  InputObjectTypeDefinition: [ "description", "name", "directives", "fields" ],
  DirectiveDefinition: [ "description", "name", "arguments", "locations" ],
  SchemaExtension: [ "directives", "operationTypes" ],
  ScalarTypeExtension: [ "name", "directives" ],
  ObjectTypeExtension: [ "name", "interfaces", "directives", "fields" ],
  InterfaceTypeExtension: [ "name", "interfaces", "directives", "fields" ],
  UnionTypeExtension: [ "name", "directives", "types" ],
  EnumTypeExtension: [ "name", "directives", "values" ],
  InputObjectTypeExtension: [ "name", "directives", "fields" ]
};

var l = new Set(Object.keys(o));

function isNode(e) {
  var n = null == e ? void 0 : e.kind;
  return "string" == typeof n && l.has(n);
}

var u;

!function(e) {
  e.QUERY = "query";
  e.MUTATION = "mutation";
  e.SUBSCRIPTION = "subscription";
}(u || (u = {}));

var c;

!function(e) {
  e.QUERY = "QUERY";
  e.MUTATION = "MUTATION";
  e.SUBSCRIPTION = "SUBSCRIPTION";
  e.FIELD = "FIELD";
  e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION";
  e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD";
  e.INLINE_FRAGMENT = "INLINE_FRAGMENT";
  e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION";
  e.SCHEMA = "SCHEMA";
  e.SCALAR = "SCALAR";
  e.OBJECT = "OBJECT";
  e.FIELD_DEFINITION = "FIELD_DEFINITION";
  e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION";
  e.INTERFACE = "INTERFACE";
  e.UNION = "UNION";
  e.ENUM = "ENUM";
  e.ENUM_VALUE = "ENUM_VALUE";
  e.INPUT_OBJECT = "INPUT_OBJECT";
  e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
}(c || (c = {}));

var d;

!function(e) {
  e.NAME = "Name";
  e.DOCUMENT = "Document";
  e.OPERATION_DEFINITION = "OperationDefinition";
  e.VARIABLE_DEFINITION = "VariableDefinition";
  e.SELECTION_SET = "SelectionSet";
  e.FIELD = "Field";
  e.ARGUMENT = "Argument";
  e.FRAGMENT_SPREAD = "FragmentSpread";
  e.INLINE_FRAGMENT = "InlineFragment";
  e.FRAGMENT_DEFINITION = "FragmentDefinition";
  e.VARIABLE = "Variable";
  e.INT = "IntValue";
  e.FLOAT = "FloatValue";
  e.STRING = "StringValue";
  e.BOOLEAN = "BooleanValue";
  e.NULL = "NullValue";
  e.ENUM = "EnumValue";
  e.LIST = "ListValue";
  e.OBJECT = "ObjectValue";
  e.OBJECT_FIELD = "ObjectField";
  e.DIRECTIVE = "Directive";
  e.NAMED_TYPE = "NamedType";
  e.LIST_TYPE = "ListType";
  e.NON_NULL_TYPE = "NonNullType";
  e.SCHEMA_DEFINITION = "SchemaDefinition";
  e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition";
  e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition";
  e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition";
  e.FIELD_DEFINITION = "FieldDefinition";
  e.INPUT_VALUE_DEFINITION = "InputValueDefinition";
  e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition";
  e.UNION_TYPE_DEFINITION = "UnionTypeDefinition";
  e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition";
  e.ENUM_VALUE_DEFINITION = "EnumValueDefinition";
  e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition";
  e.DIRECTIVE_DEFINITION = "DirectiveDefinition";
  e.SCHEMA_EXTENSION = "SchemaExtension";
  e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension";
  e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension";
  e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension";
  e.UNION_TYPE_EXTENSION = "UnionTypeExtension";
  e.ENUM_TYPE_EXTENSION = "EnumTypeExtension";
  e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
}(d || (d = {}));

function isWhiteSpace(e) {
  return 9 === e || 32 === e;
}

function isDigit$1(e) {
  return e >= 48 && e <= 57;
}

function isLetter(e) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}

function isNameStart(e) {
  return isLetter(e) || 95 === e;
}

function isNameContinue(e) {
  return isLetter(e) || isDigit$1(e) || 95 === e;
}

function dedentBlockStringLines(e) {
  var n;
  var r = Number.MAX_SAFE_INTEGER;
  var i = null;
  var a = -1;
  for (var s = 0; s < e.length; ++s) {
    var o;
    var l = e[s];
    var u = leadingWhitespace(l);
    if (u === l.length) {
      continue;
    }
    i = null !== (o = i) && void 0 !== o ? o : s;
    a = s;
    if (0 !== s && u < r) {
      r = u;
    }
  }
  return e.map(((e, n) => 0 === n ? e : e.slice(r))).slice(null !== (n = i) && void 0 !== n ? n : 0, a + 1);
}

function leadingWhitespace(e) {
  var n = 0;
  while (n < e.length && isWhiteSpace(e.charCodeAt(n))) {
    ++n;
  }
  return n;
}

var f;

!function(e) {
  e.SOF = "<SOF>";
  e.EOF = "<EOF>";
  e.BANG = "!";
  e.DOLLAR = "$";
  e.AMP = "&";
  e.PAREN_L = "(";
  e.PAREN_R = ")";
  e.SPREAD = "...";
  e.COLON = ":";
  e.EQUALS = "=";
  e.AT = "@";
  e.BRACKET_L = "[";
  e.BRACKET_R = "]";
  e.BRACE_L = "{";
  e.PIPE = "|";
  e.BRACE_R = "}";
  e.NAME = "Name";
  e.INT = "Int";
  e.FLOAT = "Float";
  e.STRING = "String";
  e.BLOCK_STRING = "BlockString";
  e.COMMENT = "Comment";
}(f || (f = {}));

class Lexer {
  constructor(e) {
    var n = new Token(f.SOF, 0, 0, 0, 0);
    this.source = e;
    this.lastToken = n;
    this.token = n;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    return this.token = this.lookahead();
  }
  lookahead() {
    var e = this.token;
    if (e.kind !== f.EOF) {
      do {
        if (e.next) {
          e = e.next;
        } else {
          var n = readNextToken(this, e.end);
          e.next = n;
          n.prev = e;
          e = n;
        }
      } while (e.kind === f.COMMENT);
    }
    return e;
  }
}

function isUnicodeScalarValue(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}

function isSupplementaryCodePoint(e, n) {
  return isLeadingSurrogate(e.charCodeAt(n)) && isTrailingSurrogate(e.charCodeAt(n + 1));
}

function isLeadingSurrogate(e) {
  return e >= 55296 && e <= 56319;
}

function isTrailingSurrogate(e) {
  return e >= 56320 && e <= 57343;
}

function printCodePointAt(e, n) {
  var r = e.source.body.codePointAt(n);
  if (void 0 === r) {
    return f.EOF;
  } else if (r >= 32 && r <= 126) {
    var i = String.fromCodePoint(r);
    return '"' === i ? "'\"'" : `"${i}"`;
  }
  return "U+" + r.toString(16).toUpperCase().padStart(4, "0");
}

function createToken(e, n, r, i, a) {
  return new Token(n, r, i, e.line, 1 + r - e.lineStart, a);
}

function readNextToken(e, n) {
  var r = e.source.body;
  var i = r.length;
  var a = n;
  while (a < i) {
    var s = r.charCodeAt(a);
    switch (s) {
     case 65279:
     case 9:
     case 32:
     case 44:
      ++a;
      continue;

     case 10:
      ++a;
      ++e.line;
      e.lineStart = a;
      continue;

     case 13:
      if (10 === r.charCodeAt(a + 1)) {
        a += 2;
      } else {
        ++a;
      }
      ++e.line;
      e.lineStart = a;
      continue;

     case 35:
      return readComment(e, a);

     case 33:
      return createToken(e, f.BANG, a, a + 1);

     case 36:
      return createToken(e, f.DOLLAR, a, a + 1);

     case 38:
      return createToken(e, f.AMP, a, a + 1);

     case 40:
      return createToken(e, f.PAREN_L, a, a + 1);

     case 41:
      return createToken(e, f.PAREN_R, a, a + 1);

     case 46:
      if (46 === r.charCodeAt(a + 1) && 46 === r.charCodeAt(a + 2)) {
        return createToken(e, f.SPREAD, a, a + 3);
      }
      break;

     case 58:
      return createToken(e, f.COLON, a, a + 1);

     case 61:
      return createToken(e, f.EQUALS, a, a + 1);

     case 64:
      return createToken(e, f.AT, a, a + 1);

     case 91:
      return createToken(e, f.BRACKET_L, a, a + 1);

     case 93:
      return createToken(e, f.BRACKET_R, a, a + 1);

     case 123:
      return createToken(e, f.BRACE_L, a, a + 1);

     case 124:
      return createToken(e, f.PIPE, a, a + 1);

     case 125:
      return createToken(e, f.BRACE_R, a, a + 1);

     case 34:
      if (34 === r.charCodeAt(a + 1) && 34 === r.charCodeAt(a + 2)) {
        return readBlockString(e, a);
      }
      return readString(e, a);
    }
    if (isDigit$1(s) || 45 === s) {
      return readNumber(e, a, s);
    }
    if (isNameStart(s)) {
      return readName(e, a);
    }
    throw syntaxError(e.source, a, 39 === s ? "Unexpected single quote character ('), did you mean to use a double quote (\")?" : isUnicodeScalarValue(s) || isSupplementaryCodePoint(r, a) ? `Unexpected character: ${printCodePointAt(e, a)}.` : `Invalid character: ${printCodePointAt(e, a)}.`);
  }
  return createToken(e, f.EOF, i, i);
}

function readComment(e, n) {
  var r = e.source.body;
  var i = r.length;
  var a = n + 1;
  while (a < i) {
    var s = r.charCodeAt(a);
    if (10 === s || 13 === s) {
      break;
    }
    if (isUnicodeScalarValue(s)) {
      ++a;
    } else if (isSupplementaryCodePoint(r, a)) {
      a += 2;
    } else {
      break;
    }
  }
  return createToken(e, f.COMMENT, n, a, r.slice(n + 1, a));
}

function readNumber(e, n, r) {
  var i = e.source.body;
  var a = n;
  var s = r;
  var o = !1;
  if (45 === s) {
    s = i.charCodeAt(++a);
  }
  if (48 === s) {
    if (isDigit$1(s = i.charCodeAt(++a))) {
      throw syntaxError(e.source, a, `Invalid number, unexpected digit after 0: ${printCodePointAt(e, a)}.`);
    }
  } else {
    a = readDigits(e, a, s);
    s = i.charCodeAt(a);
  }
  if (46 === s) {
    o = !0;
    s = i.charCodeAt(++a);
    a = readDigits(e, a, s);
    s = i.charCodeAt(a);
  }
  if (69 === s || 101 === s) {
    o = !0;
    if (43 === (s = i.charCodeAt(++a)) || 45 === s) {
      s = i.charCodeAt(++a);
    }
    a = readDigits(e, a, s);
    s = i.charCodeAt(a);
  }
  if (46 === s || isNameStart(s)) {
    throw syntaxError(e.source, a, `Invalid number, expected digit but got: ${printCodePointAt(e, a)}.`);
  }
  return createToken(e, o ? f.FLOAT : f.INT, n, a, i.slice(n, a));
}

function readDigits(e, n, r) {
  if (!isDigit$1(r)) {
    throw syntaxError(e.source, n, `Invalid number, expected digit but got: ${printCodePointAt(e, n)}.`);
  }
  var i = e.source.body;
  var a = n + 1;
  while (isDigit$1(i.charCodeAt(a))) {
    ++a;
  }
  return a;
}

function readString(e, n) {
  var r = e.source.body;
  var i = r.length;
  var a = n + 1;
  var s = a;
  var o = "";
  while (a < i) {
    var l = r.charCodeAt(a);
    if (34 === l) {
      o += r.slice(s, a);
      return createToken(e, f.STRING, n, a + 1, o);
    }
    if (92 === l) {
      o += r.slice(s, a);
      var u = 117 === r.charCodeAt(a + 1) ? 123 === r.charCodeAt(a + 2) ? readEscapedUnicodeVariableWidth(e, a) : readEscapedUnicodeFixedWidth(e, a) : readEscapedCharacter(e, a);
      o += u.value;
      s = a += u.size;
      continue;
    }
    if (10 === l || 13 === l) {
      break;
    }
    if (isUnicodeScalarValue(l)) {
      ++a;
    } else if (isSupplementaryCodePoint(r, a)) {
      a += 2;
    } else {
      throw syntaxError(e.source, a, `Invalid character within String: ${printCodePointAt(e, a)}.`);
    }
  }
  throw syntaxError(e.source, a, "Unterminated string.");
}

function readEscapedUnicodeVariableWidth(e, n) {
  var r = e.source.body;
  var i = 0;
  var a = 3;
  while (a < 12) {
    var s = r.charCodeAt(n + a++);
    if (125 === s) {
      if (a < 5 || !isUnicodeScalarValue(i)) {
        break;
      }
      return {
        value: String.fromCodePoint(i),
        size: a
      };
    }
    if ((i = i << 4 | readHexDigit(s)) < 0) {
      break;
    }
  }
  throw syntaxError(e.source, n, `Invalid Unicode escape sequence: "${r.slice(n, n + a)}".`);
}

function readEscapedUnicodeFixedWidth(e, n) {
  var r = e.source.body;
  var i = read16BitHexCode(r, n + 2);
  if (isUnicodeScalarValue(i)) {
    return {
      value: String.fromCodePoint(i),
      size: 6
    };
  }
  if (isLeadingSurrogate(i)) {
    if (92 === r.charCodeAt(n + 6) && 117 === r.charCodeAt(n + 7)) {
      var a = read16BitHexCode(r, n + 8);
      if (isTrailingSurrogate(a)) {
        return {
          value: String.fromCodePoint(i, a),
          size: 12
        };
      }
    }
  }
  throw syntaxError(e.source, n, `Invalid Unicode escape sequence: "${r.slice(n, n + 6)}".`);
}

function read16BitHexCode(e, n) {
  return readHexDigit(e.charCodeAt(n)) << 12 | readHexDigit(e.charCodeAt(n + 1)) << 8 | readHexDigit(e.charCodeAt(n + 2)) << 4 | readHexDigit(e.charCodeAt(n + 3));
}

function readHexDigit(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}

function readEscapedCharacter(e, n) {
  var r = e.source.body;
  switch (r.charCodeAt(n + 1)) {
   case 34:
    return {
      value: '"',
      size: 2
    };

   case 92:
    return {
      value: "\\",
      size: 2
    };

   case 47:
    return {
      value: "/",
      size: 2
    };

   case 98:
    return {
      value: "\b",
      size: 2
    };

   case 102:
    return {
      value: "\f",
      size: 2
    };

   case 110:
    return {
      value: "\n",
      size: 2
    };

   case 114:
    return {
      value: "\r",
      size: 2
    };

   case 116:
    return {
      value: "\t",
      size: 2
    };
  }
  throw syntaxError(e.source, n, `Invalid character escape sequence: "${r.slice(n, n + 2)}".`);
}

function readBlockString(e, n) {
  var r = e.source.body;
  var i = r.length;
  var a = e.lineStart;
  var s = n + 3;
  var o = s;
  var l = "";
  var u = [];
  while (s < i) {
    var c = r.charCodeAt(s);
    if (34 === c && 34 === r.charCodeAt(s + 1) && 34 === r.charCodeAt(s + 2)) {
      l += r.slice(o, s);
      u.push(l);
      var d = createToken(e, f.BLOCK_STRING, n, s + 3, dedentBlockStringLines(u).join("\n"));
      e.line += u.length - 1;
      e.lineStart = a;
      return d;
    }
    if (92 === c && 34 === r.charCodeAt(s + 1) && 34 === r.charCodeAt(s + 2) && 34 === r.charCodeAt(s + 3)) {
      l += r.slice(o, s);
      o = s + 1;
      s += 4;
      continue;
    }
    if (10 === c || 13 === c) {
      l += r.slice(o, s);
      u.push(l);
      if (13 === c && 10 === r.charCodeAt(s + 1)) {
        s += 2;
      } else {
        ++s;
      }
      l = "";
      o = s;
      a = s;
      continue;
    }
    if (isUnicodeScalarValue(c)) {
      ++s;
    } else if (isSupplementaryCodePoint(r, s)) {
      s += 2;
    } else {
      throw syntaxError(e.source, s, `Invalid character within String: ${printCodePointAt(e, s)}.`);
    }
  }
  throw syntaxError(e.source, s, "Unterminated string.");
}

function readName(e, n) {
  var r = e.source.body;
  var i = r.length;
  var a = n + 1;
  while (a < i) {
    if (isNameContinue(r.charCodeAt(a))) {
      ++a;
    } else {
      break;
    }
  }
  return createToken(e, f.NAME, n, a, r.slice(n, a));
}

var v = 10;

var h = 2;

function inspect(e) {
  return formatValue(e, []);
}

function formatValue(e, n) {
  switch (typeof e) {
   case "string":
    return JSON.stringify(e);

   case "function":
    return e.name ? `[function ${e.name}]` : "[function]";

   case "object":
    return function formatObjectValue(e, n) {
      if (null === e) {
        return "null";
      }
      if (n.includes(e)) {
        return "[Circular]";
      }
      var r = [ ...n, e ];
      if (function isJSONable(e) {
        return "function" == typeof e.toJSON;
      }(e)) {
        var i = e.toJSON();
        if (i !== e) {
          return "string" == typeof i ? i : formatValue(i, r);
        }
      } else if (Array.isArray(e)) {
        return function formatArray(e, n) {
          if (0 === e.length) {
            return "[]";
          }
          if (n.length > h) {
            return "[Array]";
          }
          var r = Math.min(v, e.length);
          var i = e.length - r;
          var a = [];
          for (var s = 0; s < r; ++s) {
            a.push(formatValue(e[s], n));
          }
          if (1 === i) {
            a.push("... 1 more item");
          } else if (i > 1) {
            a.push(`... ${i} more items`);
          }
          return "[" + a.join(", ") + "]";
        }(e, r);
      }
      return function formatObject(e, n) {
        var r = Object.entries(e);
        if (0 === r.length) {
          return "{}";
        }
        if (n.length > h) {
          return "[" + function getObjectTag(e) {
            var n = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
            if ("Object" === n && "function" == typeof e.constructor) {
              var r = e.constructor.name;
              if ("string" == typeof r && "" !== r) {
                return r;
              }
            }
            return n;
          }(e) + "]";
        }
        var i = r.map((([e, r]) => e + ": " + formatValue(r, n)));
        return "{ " + i.join(", ") + " }";
      }(e, r);
    }(e, n);

   default:
    return String(e);
  }
}

var m = globalThis.process && "production" === globalThis.process.env.NODE_ENV ? function instanceOf(e, n) {
  return e instanceof n;
} : function instanceOf(e, n) {
  if (e instanceof n) {
    return !0;
  }
  if ("object" == typeof e && null !== e) {
    var r;
    var i = n.prototype[Symbol.toStringTag];
    if (i === (Symbol.toStringTag in e ? e[Symbol.toStringTag] : null === (r = e.constructor) || void 0 === r ? void 0 : r.name)) {
      var a = inspect(e);
      throw new Error(`Cannot use ${i} "${a}" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.`);
    }
  }
  return !1;
};

class Source {
  constructor(e, n = "GraphQL request", r = {
    line: 1,
    column: 1
  }) {
    "string" == typeof e || devAssert(!1, `Body must be a string. Received: ${inspect(e)}.`);
    this.body = e;
    this.name = n;
    this.locationOffset = r;
    this.locationOffset.line > 0 || devAssert(!1, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(!1, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

function parse(e, n) {
  return new Parser(e, n).parseDocument();
}

class Parser {
  constructor(e, n = {}) {
    var r = function isSource(e) {
      return m(e, Source);
    }(e) ? e : new Source(e);
    this._lexer = new Lexer(r);
    this._options = n;
    this._tokenCounter = 0;
  }
  parseName() {
    var e = this.expectToken(f.NAME);
    return this.node(e, {
      kind: d.NAME,
      value: e.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: d.DOCUMENT,
      definitions: this.many(f.SOF, this.parseDefinition, f.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(f.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    var e = this.peekDescription();
    var n = e ? this._lexer.lookahead() : this._lexer.token;
    if (n.kind === f.NAME) {
      switch (n.value) {
       case "schema":
        return this.parseSchemaDefinition();

       case "scalar":
        return this.parseScalarTypeDefinition();

       case "type":
        return this.parseObjectTypeDefinition();

       case "interface":
        return this.parseInterfaceTypeDefinition();

       case "union":
        return this.parseUnionTypeDefinition();

       case "enum":
        return this.parseEnumTypeDefinition();

       case "input":
        return this.parseInputObjectTypeDefinition();

       case "directive":
        return this.parseDirectiveDefinition();
      }
      if (e) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (n.value) {
       case "query":
       case "mutation":
       case "subscription":
        return this.parseOperationDefinition();

       case "fragment":
        return this.parseFragmentDefinition();

       case "extend":
        return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(n);
  }
  parseOperationDefinition() {
    var e = this._lexer.token;
    if (this.peek(f.BRACE_L)) {
      return this.node(e, {
        kind: d.OPERATION_DEFINITION,
        operation: u.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    var n = this.parseOperationType();
    var r;
    if (this.peek(f.NAME)) {
      r = this.parseName();
    }
    return this.node(e, {
      kind: d.OPERATION_DEFINITION,
      operation: n,
      name: r,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    var e = this.expectToken(f.NAME);
    switch (e.value) {
     case "query":
      return u.QUERY;

     case "mutation":
      return u.MUTATION;

     case "subscription":
      return u.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  parseVariableDefinitions() {
    return this.optionalMany(f.PAREN_L, this.parseVariableDefinition, f.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: d.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(f.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(f.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    var e = this._lexer.token;
    this.expectToken(f.DOLLAR);
    return this.node(e, {
      kind: d.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: d.SELECTION_SET,
      selections: this.many(f.BRACE_L, this.parseSelection, f.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(f.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    var e = this._lexer.token;
    var n = this.parseName();
    var r;
    var i;
    if (this.expectOptionalToken(f.COLON)) {
      r = n;
      i = this.parseName();
    } else {
      i = n;
    }
    return this.node(e, {
      kind: d.FIELD,
      alias: r,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(f.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  parseArguments(e) {
    return this.optionalMany(f.PAREN_L, e ? this.parseConstArgument : this.parseArgument, f.PAREN_R);
  }
  parseArgument(e = !1) {
    var n = this._lexer.token;
    var r = this.parseName();
    this.expectToken(f.COLON);
    return this.node(n, {
      kind: d.ARGUMENT,
      name: r,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  parseFragment() {
    var e = this._lexer.token;
    this.expectToken(f.SPREAD);
    var n = this.expectOptionalKeyword("on");
    if (!n && this.peek(f.NAME)) {
      return this.node(e, {
        kind: d.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1)
      });
    }
    return this.node(e, {
      kind: d.INLINE_FRAGMENT,
      typeCondition: n ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    var e = this._lexer.token;
    this.expectKeyword("fragment");
    if (!0 === this._options.allowLegacyFragmentVariables) {
      return this.node(e, {
        kind: d.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(e, {
      kind: d.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if ("on" === this._lexer.token.value) {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(e) {
    var n = this._lexer.token;
    switch (n.kind) {
     case f.BRACKET_L:
      return this.parseList(e);

     case f.BRACE_L:
      return this.parseObject(e);

     case f.INT:
      this.advanceLexer();
      return this.node(n, {
        kind: d.INT,
        value: n.value
      });

     case f.FLOAT:
      this.advanceLexer();
      return this.node(n, {
        kind: d.FLOAT,
        value: n.value
      });

     case f.STRING:
     case f.BLOCK_STRING:
      return this.parseStringLiteral();

     case f.NAME:
      this.advanceLexer();
      switch (n.value) {
       case "true":
        return this.node(n, {
          kind: d.BOOLEAN,
          value: !0
        });

       case "false":
        return this.node(n, {
          kind: d.BOOLEAN,
          value: !1
        });

       case "null":
        return this.node(n, {
          kind: d.NULL
        });

       default:
        return this.node(n, {
          kind: d.ENUM,
          value: n.value
        });
      }

     case f.DOLLAR:
      if (e) {
        this.expectToken(f.DOLLAR);
        if (this._lexer.token.kind === f.NAME) {
          throw syntaxError(this._lexer.source, n.start, `Unexpected variable "$${this._lexer.token.value}" in constant value.`);
        } else {
          throw this.unexpected(n);
        }
      }
      return this.parseVariable();

     default:
      throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    var e = this._lexer.token;
    this.advanceLexer();
    return this.node(e, {
      kind: d.STRING,
      value: e.value,
      block: e.kind === f.BLOCK_STRING
    });
  }
  parseList(e) {
    return this.node(this._lexer.token, {
      kind: d.LIST,
      values: this.any(f.BRACKET_L, (() => this.parseValueLiteral(e)), f.BRACKET_R)
    });
  }
  parseObject(e) {
    return this.node(this._lexer.token, {
      kind: d.OBJECT,
      fields: this.any(f.BRACE_L, (() => this.parseObjectField(e)), f.BRACE_R)
    });
  }
  parseObjectField(e) {
    var n = this._lexer.token;
    var r = this.parseName();
    this.expectToken(f.COLON);
    return this.node(n, {
      kind: d.OBJECT_FIELD,
      name: r,
      value: this.parseValueLiteral(e)
    });
  }
  parseDirectives(e) {
    var n = [];
    while (this.peek(f.AT)) {
      n.push(this.parseDirective(e));
    }
    return n;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  parseDirective(e) {
    var n = this._lexer.token;
    this.expectToken(f.AT);
    return this.node(n, {
      kind: d.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  parseTypeReference() {
    var e = this._lexer.token;
    var n;
    if (this.expectOptionalToken(f.BRACKET_L)) {
      var r = this.parseTypeReference();
      this.expectToken(f.BRACKET_R);
      n = this.node(e, {
        kind: d.LIST_TYPE,
        type: r
      });
    } else {
      n = this.parseNamedType();
    }
    if (this.expectOptionalToken(f.BANG)) {
      return this.node(e, {
        kind: d.NON_NULL_TYPE,
        type: n
      });
    }
    return n;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: d.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(f.STRING) || this.peek(f.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("schema");
    var r = this.parseConstDirectives();
    var i = this.many(f.BRACE_L, this.parseOperationTypeDefinition, f.BRACE_R);
    return this.node(e, {
      kind: d.SCHEMA_DEFINITION,
      description: n,
      directives: r,
      operationTypes: i
    });
  }
  parseOperationTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseOperationType();
    this.expectToken(f.COLON);
    var r = this.parseNamedType();
    return this.node(e, {
      kind: d.OPERATION_TYPE_DEFINITION,
      operation: n,
      type: r
    });
  }
  parseScalarTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("scalar");
    var r = this.parseName();
    var i = this.parseConstDirectives();
    return this.node(e, {
      kind: d.SCALAR_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i
    });
  }
  parseObjectTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("type");
    var r = this.parseName();
    var i = this.parseImplementsInterfaces();
    var a = this.parseConstDirectives();
    var s = this.parseFieldsDefinition();
    return this.node(e, {
      kind: d.OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: i,
      directives: a,
      fields: s
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(f.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(f.BRACE_L, this.parseFieldDefinition, f.BRACE_R);
  }
  parseFieldDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    var r = this.parseName();
    var i = this.parseArgumentDefs();
    this.expectToken(f.COLON);
    var a = this.parseTypeReference();
    var s = this.parseConstDirectives();
    return this.node(e, {
      kind: d.FIELD_DEFINITION,
      description: n,
      name: r,
      arguments: i,
      type: a,
      directives: s
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(f.PAREN_L, this.parseInputValueDef, f.PAREN_R);
  }
  parseInputValueDef() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    var r = this.parseName();
    this.expectToken(f.COLON);
    var i = this.parseTypeReference();
    var a;
    if (this.expectOptionalToken(f.EQUALS)) {
      a = this.parseConstValueLiteral();
    }
    var s = this.parseConstDirectives();
    return this.node(e, {
      kind: d.INPUT_VALUE_DEFINITION,
      description: n,
      name: r,
      type: i,
      defaultValue: a,
      directives: s
    });
  }
  parseInterfaceTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("interface");
    var r = this.parseName();
    var i = this.parseImplementsInterfaces();
    var a = this.parseConstDirectives();
    var s = this.parseFieldsDefinition();
    return this.node(e, {
      kind: d.INTERFACE_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: i,
      directives: a,
      fields: s
    });
  }
  parseUnionTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("union");
    var r = this.parseName();
    var i = this.parseConstDirectives();
    var a = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: d.UNION_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      types: a
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(f.EQUALS) ? this.delimitedMany(f.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("enum");
    var r = this.parseName();
    var i = this.parseConstDirectives();
    var a = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: d.ENUM_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      values: a
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(f.BRACE_L, this.parseEnumValueDefinition, f.BRACE_R);
  }
  parseEnumValueDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    var r = this.parseEnumValueName();
    var i = this.parseConstDirectives();
    return this.node(e, {
      kind: d.ENUM_VALUE_DEFINITION,
      description: n,
      name: r,
      directives: i
    });
  }
  parseEnumValueName() {
    if ("true" === this._lexer.token.value || "false" === this._lexer.token.value || "null" === this._lexer.token.value) {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("input");
    var r = this.parseName();
    var i = this.parseConstDirectives();
    var a = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: d.INPUT_OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: i,
      fields: a
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(f.BRACE_L, this.parseInputValueDef, f.BRACE_R);
  }
  parseTypeSystemExtension() {
    var e = this._lexer.lookahead();
    if (e.kind === f.NAME) {
      switch (e.value) {
       case "schema":
        return this.parseSchemaExtension();

       case "scalar":
        return this.parseScalarTypeExtension();

       case "type":
        return this.parseObjectTypeExtension();

       case "interface":
        return this.parseInterfaceTypeExtension();

       case "union":
        return this.parseUnionTypeExtension();

       case "enum":
        return this.parseEnumTypeExtension();

       case "input":
        return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(e);
  }
  parseSchemaExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var n = this.parseConstDirectives();
    var r = this.optionalMany(f.BRACE_L, this.parseOperationTypeDefinition, f.BRACE_R);
    if (0 === n.length && 0 === r.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.SCHEMA_EXTENSION,
      directives: n,
      operationTypes: r
    });
  }
  parseScalarTypeExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var n = this.parseName();
    var r = this.parseConstDirectives();
    if (0 === r.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.SCALAR_TYPE_EXTENSION,
      name: n,
      directives: r
    });
  }
  parseObjectTypeExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var n = this.parseName();
    var r = this.parseImplementsInterfaces();
    var i = this.parseConstDirectives();
    var a = this.parseFieldsDefinition();
    if (0 === r.length && 0 === i.length && 0 === a.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.OBJECT_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: i,
      fields: a
    });
  }
  parseInterfaceTypeExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var n = this.parseName();
    var r = this.parseImplementsInterfaces();
    var i = this.parseConstDirectives();
    var a = this.parseFieldsDefinition();
    if (0 === r.length && 0 === i.length && 0 === a.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.INTERFACE_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: i,
      fields: a
    });
  }
  parseUnionTypeExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var n = this.parseName();
    var r = this.parseConstDirectives();
    var i = this.parseUnionMemberTypes();
    if (0 === r.length && 0 === i.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.UNION_TYPE_EXTENSION,
      name: n,
      directives: r,
      types: i
    });
  }
  parseEnumTypeExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var n = this.parseName();
    var r = this.parseConstDirectives();
    var i = this.parseEnumValuesDefinition();
    if (0 === r.length && 0 === i.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.ENUM_TYPE_EXTENSION,
      name: n,
      directives: r,
      values: i
    });
  }
  parseInputObjectTypeExtension() {
    var e = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var n = this.parseName();
    var r = this.parseConstDirectives();
    var i = this.parseInputFieldsDefinition();
    if (0 === r.length && 0 === i.length) {
      throw this.unexpected();
    }
    return this.node(e, {
      kind: d.INPUT_OBJECT_TYPE_EXTENSION,
      name: n,
      directives: r,
      fields: i
    });
  }
  parseDirectiveDefinition() {
    var e = this._lexer.token;
    var n = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(f.AT);
    var r = this.parseName();
    var i = this.parseArgumentDefs();
    var a = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var s = this.parseDirectiveLocations();
    return this.node(e, {
      kind: d.DIRECTIVE_DEFINITION,
      description: n,
      name: r,
      arguments: i,
      repeatable: a,
      locations: s
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(f.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    var e = this._lexer.token;
    var n = this.parseName();
    if (Object.prototype.hasOwnProperty.call(c, n.value)) {
      return n;
    }
    throw this.unexpected(e);
  }
  node(e, n) {
    if (!0 !== this._options.noLocation) {
      n.loc = new s(e, this._lexer.lastToken, this._lexer.source);
    }
    return n;
  }
  peek(e) {
    return this._lexer.token.kind === e;
  }
  expectToken(e) {
    var n = this._lexer.token;
    if (n.kind === e) {
      this.advanceLexer();
      return n;
    }
    throw syntaxError(this._lexer.source, n.start, `Expected ${getTokenKindDesc(e)}, found ${getTokenDesc(n)}.`);
  }
  expectOptionalToken(e) {
    if (this._lexer.token.kind === e) {
      this.advanceLexer();
      return !0;
    }
    return !1;
  }
  expectKeyword(e) {
    var n = this._lexer.token;
    if (n.kind === f.NAME && n.value === e) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, n.start, `Expected "${e}", found ${getTokenDesc(n)}.`);
    }
  }
  expectOptionalKeyword(e) {
    var n = this._lexer.token;
    if (n.kind === f.NAME && n.value === e) {
      this.advanceLexer();
      return !0;
    }
    return !1;
  }
  unexpected(e) {
    var n = null != e ? e : this._lexer.token;
    return syntaxError(this._lexer.source, n.start, `Unexpected ${getTokenDesc(n)}.`);
  }
  any(e, n, r) {
    this.expectToken(e);
    var i = [];
    while (!this.expectOptionalToken(r)) {
      i.push(n.call(this));
    }
    return i;
  }
  optionalMany(e, n, r) {
    if (this.expectOptionalToken(e)) {
      var i = [];
      do {
        i.push(n.call(this));
      } while (!this.expectOptionalToken(r));
      return i;
    }
    return [];
  }
  many(e, n, r) {
    this.expectToken(e);
    var i = [];
    do {
      i.push(n.call(this));
    } while (!this.expectOptionalToken(r));
    return i;
  }
  delimitedMany(e, n) {
    this.expectOptionalToken(e);
    var r = [];
    do {
      r.push(n.call(this));
    } while (this.expectOptionalToken(e));
    return r;
  }
  advanceLexer() {
    var {maxTokens: e} = this._options;
    var n = this._lexer.advance();
    if (void 0 !== e && n.kind !== f.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > e) {
        throw syntaxError(this._lexer.source, n.start, `Document contains more that ${e} tokens. Parsing aborted.`);
      }
    }
  }
}

function getTokenDesc(e) {
  var n = e.value;
  return getTokenKindDesc(e.kind) + (null != n ? ` "${n}"` : "");
}

function getTokenKindDesc(e) {
  return function isPunctuatorTokenKind(e) {
    return e === f.BANG || e === f.DOLLAR || e === f.AMP || e === f.PAREN_L || e === f.PAREN_R || e === f.SPREAD || e === f.COLON || e === f.EQUALS || e === f.AT || e === f.BRACKET_L || e === f.BRACKET_R || e === f.BRACE_L || e === f.PIPE || e === f.BRACE_R;
  }(e) ? `"${e}"` : e;
}

var g = 5;

function didYouMean(e, n) {
  var [r, i] = n ? [ e, n ] : [ void 0, e ];
  var a = " Did you mean ";
  if (r) {
    a += r + " ";
  }
  var s = i.map((e => `"${e}"`));
  switch (s.length) {
   case 0:
    return "";

   case 1:
    return a + s[0] + "?";

   case 2:
    return a + s[0] + " or " + s[1] + "?";
  }
  var o = s.slice(0, g);
  var l = o.pop();
  return a + o.join(", ") + ", or " + l + "?";
}

function identityFunc(e) {
  return e;
}

function keyMap(e, n) {
  var r = Object.create(null);
  for (var i of e) {
    r[n(i)] = i;
  }
  return r;
}

function keyValMap(e, n, r) {
  var i = Object.create(null);
  for (var a of e) {
    i[n(a)] = r(a);
  }
  return i;
}

function mapValue(e, n) {
  var r = Object.create(null);
  for (var i of Object.keys(e)) {
    r[i] = n(e[i], i);
  }
  return r;
}

function naturalCompare(e, n) {
  var r = 0;
  var i = 0;
  while (r < e.length && i < n.length) {
    var a = e.charCodeAt(r);
    var s = n.charCodeAt(i);
    if (isDigit(a) && isDigit(s)) {
      var o = 0;
      do {
        ++r;
        o = 10 * o + a - y;
        a = e.charCodeAt(r);
      } while (isDigit(a) && o > 0);
      var l = 0;
      do {
        ++i;
        l = 10 * l + s - y;
        s = n.charCodeAt(i);
      } while (isDigit(s) && l > 0);
      if (o < l) {
        return -1;
      }
      if (o > l) {
        return 1;
      }
    } else {
      if (a < s) {
        return -1;
      }
      if (a > s) {
        return 1;
      }
      ++r;
      ++i;
    }
  }
  return e.length - n.length;
}

var y = 48;

var T = 57;

function isDigit(e) {
  return !isNaN(e) && y <= e && e <= T;
}

function suggestionList(e, n) {
  var r = Object.create(null);
  var i = new LexicalDistance(e);
  var a = Math.floor(.4 * e.length) + 1;
  for (var s of n) {
    var o = i.measure(s, a);
    if (void 0 !== o) {
      r[s] = o;
    }
  }
  return Object.keys(r).sort(((e, n) => {
    var i = r[e] - r[n];
    return 0 !== i ? i : naturalCompare(e, n);
  }));
}

class LexicalDistance {
  constructor(e) {
    this._input = e;
    this._inputLowerCase = e.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [ new Array(e.length + 1).fill(0), new Array(e.length + 1).fill(0), new Array(e.length + 1).fill(0) ];
  }
  measure(e, n) {
    if (this._input === e) {
      return 0;
    }
    var r = e.toLowerCase();
    if (this._inputLowerCase === r) {
      return 1;
    }
    var i = stringToArray(r);
    var a = this._inputArray;
    if (i.length < a.length) {
      var s = i;
      i = a;
      a = s;
    }
    var o = i.length;
    var l = a.length;
    if (o - l > n) {
      return;
    }
    var u = this._rows;
    for (var c = 0; c <= l; c++) {
      u[0][c] = c;
    }
    for (var d = 1; d <= o; d++) {
      var f = u[(d - 1) % 3];
      var v = u[d % 3];
      var h = v[0] = d;
      for (var m = 1; m <= l; m++) {
        var g = Math.min(f[m] + 1, v[m - 1] + 1, f[m - 1] + (i[d - 1] === a[m - 1] ? 0 : 1));
        if (d > 1 && m > 1 && i[d - 1] === a[m - 2] && i[d - 2] === a[m - 1]) {
          g = Math.min(g, u[(d - 2) % 3][m - 2] + 1);
        }
        if (g < h) {
          h = g;
        }
        v[m] = g;
      }
      if (h > n) {
        return;
      }
    }
    var y = u[o % 3][l];
    return y <= n ? y : void 0;
  }
}

function stringToArray(e) {
  var n = e.length;
  var r = new Array(n);
  for (var i = 0; i < n; ++i) {
    r[i] = e.charCodeAt(i);
  }
  return r;
}

function toObjMap(e) {
  if (null == e) {
    return Object.create(null);
  }
  if (null === Object.getPrototypeOf(e)) {
    return e;
  }
  var n = Object.create(null);
  for (var [r, i] of Object.entries(e)) {
    n[r] = i;
  }
  return n;
}

var E = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;

function escapedReplacer(e) {
  return N[e.charCodeAt(0)];
}

var N = [ "\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b", "\\t", "\\n", "\\u000B", "\\f", "\\r", "\\u000E", "\\u000F", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001A", "\\u001B", "\\u001C", "\\u001D", "\\u001E", "\\u001F", "", "", '\\"', "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\\\", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\u007F", "\\u0080", "\\u0081", "\\u0082", "\\u0083", "\\u0084", "\\u0085", "\\u0086", "\\u0087", "\\u0088", "\\u0089", "\\u008A", "\\u008B", "\\u008C", "\\u008D", "\\u008E", "\\u008F", "\\u0090", "\\u0091", "\\u0092", "\\u0093", "\\u0094", "\\u0095", "\\u0096", "\\u0097", "\\u0098", "\\u0099", "\\u009A", "\\u009B", "\\u009C", "\\u009D", "\\u009E", "\\u009F" ];

var I = Object.freeze({});

function visit(e, n, r = o) {
  var i = new Map;
  for (var a of Object.values(d)) {
    i.set(a, getEnterLeaveForKind(n, a));
  }
  var s = void 0;
  var l = Array.isArray(e);
  var u = [ e ];
  var c = -1;
  var f = [];
  var v = e;
  var h = void 0;
  var m = void 0;
  var g = [];
  var y = [];
  do {
    var T = ++c === u.length;
    var E = T && 0 !== f.length;
    if (T) {
      h = 0 === y.length ? void 0 : g[g.length - 1];
      v = m;
      m = y.pop();
      if (E) {
        if (l) {
          v = v.slice();
          var N = 0;
          for (var [b, S] of f) {
            var _ = b - N;
            if (null === S) {
              v.splice(_, 1);
              N++;
            } else {
              v[_] = S;
            }
          }
        } else {
          v = Object.defineProperties({}, Object.getOwnPropertyDescriptors(v));
          for (var [A, O] of f) {
            v[A] = O;
          }
        }
      }
      c = s.index;
      u = s.keys;
      f = s.edits;
      l = s.inArray;
      s = s.prev;
    } else if (m) {
      if (null == (v = m[h = l ? c : u[c]])) {
        continue;
      }
      g.push(h);
    }
    var L = void 0;
    if (!Array.isArray(v)) {
      var D, x;
      isNode(v) || devAssert(!1, `Invalid AST Node: ${inspect(v)}.`);
      var F = T ? null === (D = i.get(v.kind)) || void 0 === D ? void 0 : D.leave : null === (x = i.get(v.kind)) || void 0 === x ? void 0 : x.enter;
      if ((L = null == F ? void 0 : F.call(n, v, h, m, g, y)) === I) {
        break;
      }
      if (!1 === L) {
        if (!T) {
          g.pop();
          continue;
        }
      } else if (void 0 !== L) {
        f.push([ h, L ]);
        if (!T) {
          if (isNode(L)) {
            v = L;
          } else {
            g.pop();
            continue;
          }
        }
      }
    }
    if (void 0 === L && E) {
      f.push([ h, v ]);
    }
    if (T) {
      g.pop();
    } else {
      var w;
      s = {
        inArray: l,
        index: c,
        keys: u,
        edits: f,
        prev: s
      };
      u = (l = Array.isArray(v)) ? v : null !== (w = r[v.kind]) && void 0 !== w ? w : [];
      c = -1;
      f = [];
      if (m) {
        y.push(m);
      }
      m = v;
    }
  } while (void 0 !== s);
  if (0 !== f.length) {
    return f[f.length - 1][1];
  }
  return e;
}

function visitInParallel(e) {
  var n = new Array(e.length).fill(null);
  var r = Object.create(null);
  var _loop = function() {
    var a = !1;
    var s = new Array(e.length).fill(void 0);
    var o = new Array(e.length).fill(void 0);
    for (var l = 0; l < e.length; ++l) {
      var {enter: u, leave: c} = getEnterLeaveForKind(e[l], i);
      a || (a = null != u || null != c);
      s[l] = u;
      o[l] = c;
    }
    if (!a) {
      return 1;
    }
    r[i] = {
      enter(...r) {
        var i = r[0];
        for (var a = 0; a < e.length; a++) {
          if (null === n[a]) {
            var o;
            var l = null === (o = s[a]) || void 0 === o ? void 0 : o.apply(e[a], r);
            if (!1 === l) {
              n[a] = i;
            } else if (l === I) {
              n[a] = I;
            } else if (void 0 !== l) {
              return l;
            }
          }
        }
      },
      leave(...r) {
        var i = r[0];
        for (var a = 0; a < e.length; a++) {
          if (null === n[a]) {
            var s;
            var l = null === (s = o[a]) || void 0 === s ? void 0 : s.apply(e[a], r);
            if (l === I) {
              n[a] = I;
            } else if (void 0 !== l && !1 !== l) {
              return l;
            }
          } else if (n[a] === i) {
            n[a] = null;
          }
        }
      }
    };
  };
  for (var i of Object.values(d)) {
    if (_loop()) {
      continue;
    }
  }
  return r;
}

function getEnterLeaveForKind(e, n) {
  var r = e[n];
  if ("object" == typeof r) {
    return r;
  } else if ("function" == typeof r) {
    return {
      enter: r,
      leave: void 0
    };
  }
  return {
    enter: e.enter,
    leave: e.leave
  };
}

function print$1(e) {
  return visit(e, b);
}

var b = {
  Name: {
    leave: e => e.value
  },
  Variable: {
    leave: e => "$" + e.name
  },
  Document: {
    leave: e => join(e.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(e) {
      var n = wrap("(", join(e.variableDefinitions, ", "), ")");
      var r = join([ e.operation, join([ e.name, n ]), join(e.directives, " ") ], " ");
      return ("query" === r ? "" : r + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({variable: e, type: n, defaultValue: r, directives: i}) => e + ": " + n + wrap(" = ", r) + wrap(" ", join(i, " "))
  },
  SelectionSet: {
    leave: ({selections: e}) => block(e)
  },
  Field: {
    leave({alias: e, name: n, arguments: r, directives: i, selectionSet: a}) {
      var s = wrap("", e, ": ") + n;
      var o = s + wrap("(", join(r, ", "), ")");
      if (o.length > 80) {
        o = s + wrap("(\n", indent(join(r, "\n")), "\n)");
      }
      return join([ o, join(i, " "), a ], " ");
    }
  },
  Argument: {
    leave: ({name: e, value: n}) => e + ": " + n
  },
  FragmentSpread: {
    leave: ({name: e, directives: n}) => "..." + e + wrap(" ", join(n, " "))
  },
  InlineFragment: {
    leave: ({typeCondition: e, directives: n, selectionSet: r}) => join([ "...", wrap("on ", e), join(n, " "), r ], " ")
  },
  FragmentDefinition: {
    leave: ({name: e, typeCondition: n, variableDefinitions: r, directives: i, selectionSet: a}) => `fragment ${e}${wrap("(", join(r, ", "), ")")} on ${n} ${wrap("", join(i, " "), " ")}` + a
  },
  IntValue: {
    leave: ({value: e}) => e
  },
  FloatValue: {
    leave: ({value: e}) => e
  },
  StringValue: {
    leave: ({value: e, block: n}) => n ? function printBlockString$1(e, n) {
      var r = e.replace(/"""/g, '\\"""');
      var i = r.split(/\r\n|[\n\r]/g);
      var a = 1 === i.length;
      var s = i.length > 1 && i.slice(1).every((e => 0 === e.length || isWhiteSpace(e.charCodeAt(0))));
      var o = r.endsWith('\\"""');
      var l = e.endsWith('"') && !o;
      var u = e.endsWith("\\");
      var c = l || u;
      var d = !(null != n && n.minimize) && (!a || e.length > 70 || c || s || o);
      var f = "";
      var v = a && isWhiteSpace(e.charCodeAt(0));
      if (d && !v || s) {
        f += "\n";
      }
      f += r;
      if (d || c) {
        f += "\n";
      }
      return '"""' + f + '"""';
    }(e) : function printString$1(e) {
      return `"${e.replace(E, escapedReplacer)}"`;
    }(e)
  },
  BooleanValue: {
    leave: ({value: e}) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({value: e}) => e
  },
  ListValue: {
    leave: ({values: e}) => "[" + join(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({fields: e}) => "{" + join(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({name: e, value: n}) => e + ": " + n
  },
  Directive: {
    leave: ({name: e, arguments: n}) => "@" + e + wrap("(", join(n, ", "), ")")
  },
  NamedType: {
    leave: ({name: e}) => e
  },
  ListType: {
    leave: ({type: e}) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({type: e}) => e + "!"
  },
  SchemaDefinition: {
    leave: ({description: e, directives: n, operationTypes: r}) => wrap("", e, "\n") + join([ "schema", join(n, " "), block(r) ], " ")
  },
  OperationTypeDefinition: {
    leave: ({operation: e, type: n}) => e + ": " + n
  },
  ScalarTypeDefinition: {
    leave: ({description: e, name: n, directives: r}) => wrap("", e, "\n") + join([ "scalar", n, join(r, " ") ], " ")
  },
  ObjectTypeDefinition: {
    leave: ({description: e, name: n, interfaces: r, directives: i, fields: a}) => wrap("", e, "\n") + join([ "type", n, wrap("implements ", join(r, " & ")), join(i, " "), block(a) ], " ")
  },
  FieldDefinition: {
    leave: ({description: e, name: n, arguments: r, type: i, directives: a}) => wrap("", e, "\n") + n + (hasMultilineItems(r) ? wrap("(\n", indent(join(r, "\n")), "\n)") : wrap("(", join(r, ", "), ")")) + ": " + i + wrap(" ", join(a, " "))
  },
  InputValueDefinition: {
    leave: ({description: e, name: n, type: r, defaultValue: i, directives: a}) => wrap("", e, "\n") + join([ n + ": " + r, wrap("= ", i), join(a, " ") ], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({description: e, name: n, interfaces: r, directives: i, fields: a}) => wrap("", e, "\n") + join([ "interface", n, wrap("implements ", join(r, " & ")), join(i, " "), block(a) ], " ")
  },
  UnionTypeDefinition: {
    leave: ({description: e, name: n, directives: r, types: i}) => wrap("", e, "\n") + join([ "union", n, join(r, " "), wrap("= ", join(i, " | ")) ], " ")
  },
  EnumTypeDefinition: {
    leave: ({description: e, name: n, directives: r, values: i}) => wrap("", e, "\n") + join([ "enum", n, join(r, " "), block(i) ], " ")
  },
  EnumValueDefinition: {
    leave: ({description: e, name: n, directives: r}) => wrap("", e, "\n") + join([ n, join(r, " ") ], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({description: e, name: n, directives: r, fields: i}) => wrap("", e, "\n") + join([ "input", n, join(r, " "), block(i) ], " ")
  },
  DirectiveDefinition: {
    leave: ({description: e, name: n, arguments: r, repeatable: i, locations: a}) => wrap("", e, "\n") + "directive @" + n + (hasMultilineItems(r) ? wrap("(\n", indent(join(r, "\n")), "\n)") : wrap("(", join(r, ", "), ")")) + (i ? " repeatable" : "") + " on " + join(a, " | ")
  },
  SchemaExtension: {
    leave: ({directives: e, operationTypes: n}) => join([ "extend schema", join(e, " "), block(n) ], " ")
  },
  ScalarTypeExtension: {
    leave: ({name: e, directives: n}) => join([ "extend scalar", e, join(n, " ") ], " ")
  },
  ObjectTypeExtension: {
    leave: ({name: e, interfaces: n, directives: r, fields: i}) => join([ "extend type", e, wrap("implements ", join(n, " & ")), join(r, " "), block(i) ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({name: e, interfaces: n, directives: r, fields: i}) => join([ "extend interface", e, wrap("implements ", join(n, " & ")), join(r, " "), block(i) ], " ")
  },
  UnionTypeExtension: {
    leave: ({name: e, directives: n, types: r}) => join([ "extend union", e, join(n, " "), wrap("= ", join(r, " | ")) ], " ")
  },
  EnumTypeExtension: {
    leave: ({name: e, directives: n, values: r}) => join([ "extend enum", e, join(n, " "), block(r) ], " ")
  },
  InputObjectTypeExtension: {
    leave: ({name: e, directives: n, fields: r}) => join([ "extend input", e, join(n, " "), block(r) ], " ")
  }
};

function join(e, n = "") {
  var r;
  return null !== (r = null == e ? void 0 : e.filter((e => e)).join(n)) && void 0 !== r ? r : "";
}

function block(e) {
  return wrap("{\n", indent(join(e, "\n")), "\n}");
}

function wrap(e, n, r = "") {
  return null != n && "" !== n ? e + n + r : "";
}

function indent(e) {
  return wrap("  ", e.replace(/\n/g, "\n  "));
}

function hasMultilineItems(e) {
  var n;
  return null !== (n = null == e ? void 0 : e.some((e => e.includes("\n")))) && void 0 !== n ? n : !1;
}

function valueFromASTUntyped(e, n) {
  switch (e.kind) {
   case d.NULL:
    return null;

   case d.INT:
    return parseInt(e.value, 10);

   case d.FLOAT:
    return parseFloat(e.value);

   case d.STRING:
   case d.ENUM:
   case d.BOOLEAN:
    return e.value;

   case d.LIST:
    return e.values.map((e => valueFromASTUntyped(e, n)));

   case d.OBJECT:
    return keyValMap(e.fields, (e => e.name.value), (e => valueFromASTUntyped(e.value, n)));

   case d.VARIABLE:
    return null == n ? void 0 : n[e.name.value];
  }
}

function assertName(e) {
  null != e || devAssert(!1, "Must provide name.");
  "string" == typeof e || devAssert(!1, "Expected name to be a string.");
  if (0 === e.length) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (var n = 1; n < e.length; ++n) {
    if (!isNameContinue(e.charCodeAt(n))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${e}" does not.`);
    }
  }
  if (!isNameStart(e.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${e}" does not.`);
  }
  return e;
}

function assertEnumValueName(e) {
  if ("true" === e || "false" === e || "null" === e) {
    throw new GraphQLError(`Enum values cannot be named: ${e}`);
  }
  return assertName(e);
}

function isType(e) {
  return isScalarType(e) || isObjectType(e) || isInterfaceType(e) || isUnionType(e) || isEnumType(e) || isInputObjectType(e) || isListType(e) || isNonNullType(e);
}

function isScalarType(e) {
  return m(e, GraphQLScalarType);
}

function isObjectType(e) {
  return m(e, GraphQLObjectType);
}

function isInterfaceType(e) {
  return m(e, GraphQLInterfaceType);
}

function isUnionType(e) {
  return m(e, GraphQLUnionType);
}

function isEnumType(e) {
  return m(e, GraphQLEnumType);
}

function isInputObjectType(e) {
  return m(e, GraphQLInputObjectType);
}

function isListType(e) {
  return m(e, GraphQLList);
}

function isNonNullType(e) {
  return m(e, GraphQLNonNull);
}

function isInputType(e) {
  return isScalarType(e) || isEnumType(e) || isInputObjectType(e) || isWrappingType(e) && isInputType(e.ofType);
}

function isOutputType(e) {
  return isScalarType(e) || isObjectType(e) || isInterfaceType(e) || isUnionType(e) || isEnumType(e) || isWrappingType(e) && isOutputType(e.ofType);
}

function isLeafType(e) {
  return isScalarType(e) || isEnumType(e);
}

function isCompositeType(e) {
  return isObjectType(e) || isInterfaceType(e) || isUnionType(e);
}

function isAbstractType(e) {
  return isInterfaceType(e) || isUnionType(e);
}

class GraphQLList {
  constructor(e) {
    isType(e) || devAssert(!1, `Expected ${inspect(e)} to be a GraphQL type.`);
    this.ofType = e;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLNonNull {
  constructor(e) {
    isNullableType(e) || devAssert(!1, `Expected ${inspect(e)} to be a GraphQL nullable type.`);
    this.ofType = e;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}

function isWrappingType(e) {
  return isListType(e) || isNonNullType(e);
}

function isNullableType(e) {
  return isType(e) && !isNonNullType(e);
}

function getNullableType(e) {
  if (e) {
    return isNonNullType(e) ? e.ofType : e;
  }
}

function isNamedType(e) {
  return isScalarType(e) || isObjectType(e) || isInterfaceType(e) || isUnionType(e) || isEnumType(e) || isInputObjectType(e);
}

function getNamedType(e) {
  if (e) {
    var n = e;
    while (isWrappingType(n)) {
      n = n.ofType;
    }
    return n;
  }
}

function resolveReadonlyArrayThunk(e) {
  return "function" == typeof e ? e() : e;
}

function resolveObjMapThunk(e) {
  return "function" == typeof e ? e() : e;
}

class GraphQLScalarType {
  constructor(e) {
    var n, r, i, a;
    var s = null !== (n = e.parseValue) && void 0 !== n ? n : identityFunc;
    this.name = assertName(e.name);
    this.description = e.description;
    this.specifiedByURL = e.specifiedByURL;
    this.serialize = null !== (r = e.serialize) && void 0 !== r ? r : identityFunc;
    this.parseValue = s;
    this.parseLiteral = null !== (i = e.parseLiteral) && void 0 !== i ? i : (e, n) => s(valueFromASTUntyped(e, n));
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (a = e.extensionASTNodes) && void 0 !== a ? a : [];
    null == e.specifiedByURL || "string" == typeof e.specifiedByURL || devAssert(!1, `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(e.specifiedByURL)}.`);
    null == e.serialize || "function" == typeof e.serialize || devAssert(!1, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (e.parseLiteral) {
      "function" == typeof e.parseValue && "function" == typeof e.parseLiteral || devAssert(!1, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLObjectType {
  constructor(e) {
    var n;
    this.name = assertName(e.name);
    this.description = e.description;
    this.isTypeOf = e.isTypeOf;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (n = e.extensionASTNodes) && void 0 !== n ? n : [];
    this._fields = () => defineFieldMap(e);
    this._interfaces = () => defineInterfaces(e);
    null == e.isTypeOf || "function" == typeof e.isTypeOf || devAssert(!1, `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(e.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if ("function" == typeof this._fields) {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if ("function" == typeof this._interfaces) {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

function defineInterfaces(e) {
  var n;
  var r = resolveReadonlyArrayThunk(null !== (n = e.interfaces) && void 0 !== n ? n : []);
  Array.isArray(r) || devAssert(!1, `${e.name} interfaces must be an Array or a function which returns an Array.`);
  return r;
}

function defineFieldMap(e) {
  var n = resolveObjMapThunk(e.fields);
  isPlainObj(n) || devAssert(!1, `${e.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(n, ((n, r) => {
    var i;
    isPlainObj(n) || devAssert(!1, `${e.name}.${r} field config must be an object.`);
    null == n.resolve || "function" == typeof n.resolve || devAssert(!1, `${e.name}.${r} field resolver must be a function if provided, but got: ${inspect(n.resolve)}.`);
    var a = null !== (i = n.args) && void 0 !== i ? i : {};
    isPlainObj(a) || devAssert(!1, `${e.name}.${r} args must be an object with argument names as keys.`);
    return {
      name: assertName(r),
      description: n.description,
      type: n.type,
      args: defineArguments(a),
      resolve: n.resolve,
      subscribe: n.subscribe,
      deprecationReason: n.deprecationReason,
      extensions: toObjMap(n.extensions),
      astNode: n.astNode
    };
  }));
}

function defineArguments(e) {
  return Object.entries(e).map((([e, n]) => ({
    name: assertName(e),
    description: n.description,
    type: n.type,
    defaultValue: n.defaultValue,
    deprecationReason: n.deprecationReason,
    extensions: toObjMap(n.extensions),
    astNode: n.astNode
  })));
}

function isPlainObj(e) {
  return isObjectLike(e) && !Array.isArray(e);
}

function fieldsToFieldsConfig(e) {
  return mapValue(e, (e => ({
    description: e.description,
    type: e.type,
    args: argsToArgsConfig(e.args),
    resolve: e.resolve,
    subscribe: e.subscribe,
    deprecationReason: e.deprecationReason,
    extensions: e.extensions,
    astNode: e.astNode
  })));
}

function argsToArgsConfig(e) {
  return keyValMap(e, (e => e.name), (e => ({
    description: e.description,
    type: e.type,
    defaultValue: e.defaultValue,
    deprecationReason: e.deprecationReason,
    extensions: e.extensions,
    astNode: e.astNode
  })));
}

function isRequiredArgument(e) {
  return isNonNullType(e.type) && void 0 === e.defaultValue;
}

class GraphQLInterfaceType {
  constructor(e) {
    var n;
    this.name = assertName(e.name);
    this.description = e.description;
    this.resolveType = e.resolveType;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (n = e.extensionASTNodes) && void 0 !== n ? n : [];
    this._fields = defineFieldMap.bind(void 0, e);
    this._interfaces = defineInterfaces.bind(void 0, e);
    null == e.resolveType || "function" == typeof e.resolveType || devAssert(!1, `${this.name} must provide "resolveType" as a function, but got: ${inspect(e.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if ("function" == typeof this._fields) {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if ("function" == typeof this._interfaces) {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLUnionType {
  constructor(e) {
    var n;
    this.name = assertName(e.name);
    this.description = e.description;
    this.resolveType = e.resolveType;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (n = e.extensionASTNodes) && void 0 !== n ? n : [];
    this._types = defineTypes.bind(void 0, e);
    null == e.resolveType || "function" == typeof e.resolveType || devAssert(!1, `${this.name} must provide "resolveType" as a function, but got: ${inspect(e.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if ("function" == typeof this._types) {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

function defineTypes(e) {
  var n = resolveReadonlyArrayThunk(e.types);
  Array.isArray(n) || devAssert(!1, `Must provide Array of types or a function which returns such an array for Union ${e.name}.`);
  return n;
}

class GraphQLEnumType {
  constructor(e) {
    var n;
    this.name = assertName(e.name);
    this.description = e.description;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (n = e.extensionASTNodes) && void 0 !== n ? n : [];
    this._values = function defineEnumValues(e, n) {
      isPlainObj(n) || devAssert(!1, `${e} values must be an object with value names as keys.`);
      return Object.entries(n).map((([n, r]) => {
        isPlainObj(r) || devAssert(!1, `${e}.${n} must refer to an object with a "value" key representing an internal value but got: ${inspect(r)}.`);
        return {
          name: assertEnumValueName(n),
          description: r.description,
          value: void 0 !== r.value ? r.value : n,
          deprecationReason: r.deprecationReason,
          extensions: toObjMap(r.extensions),
          astNode: r.astNode
        };
      }));
    }(this.name, e.values);
    this._valueLookup = new Map(this._values.map((e => [ e.value, e ])));
    this._nameLookup = keyMap(this._values, (e => e.name));
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(e) {
    return this._nameLookup[e];
  }
  serialize(e) {
    var n = this._valueLookup.get(e);
    if (void 0 === n) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(e)}`);
    }
    return n.name;
  }
  parseValue(e) {
    if ("string" != typeof e) {
      var n = inspect(e);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${n}.` + didYouMeanEnumValue(this, n));
    }
    var r = this.getValue(e);
    if (null == r) {
      throw new GraphQLError(`Value "${e}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, e));
    }
    return r.value;
  }
  parseLiteral(e, n) {
    if (e.kind !== d.ENUM) {
      var r = print$1(e);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${r}.` + didYouMeanEnumValue(this, r), {
        nodes: e
      });
    }
    var i = this.getValue(e.value);
    if (null == i) {
      var a = print$1(e);
      throw new GraphQLError(`Value "${a}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, a), {
        nodes: e
      });
    }
    return i.value;
  }
  toConfig() {
    var e = keyValMap(this.getValues(), (e => e.name), (e => ({
      description: e.description,
      value: e.value,
      deprecationReason: e.deprecationReason,
      extensions: e.extensions,
      astNode: e.astNode
    })));
    return {
      name: this.name,
      description: this.description,
      values: e,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

function didYouMeanEnumValue(e, n) {
  return didYouMean("the enum value", suggestionList(n, e.getValues().map((e => e.name))));
}

class GraphQLInputObjectType {
  constructor(e) {
    var n;
    this.name = assertName(e.name);
    this.description = e.description;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (n = e.extensionASTNodes) && void 0 !== n ? n : [];
    this._fields = defineInputFieldMap.bind(void 0, e);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if ("function" == typeof this._fields) {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    var e = mapValue(this.getFields(), (e => ({
      description: e.description,
      type: e.type,
      defaultValue: e.defaultValue,
      deprecationReason: e.deprecationReason,
      extensions: e.extensions,
      astNode: e.astNode
    })));
    return {
      name: this.name,
      description: this.description,
      fields: e,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

function defineInputFieldMap(e) {
  var n = resolveObjMapThunk(e.fields);
  isPlainObj(n) || devAssert(!1, `${e.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(n, ((n, r) => {
    !("resolve" in n) || devAssert(!1, `${e.name}.${r} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(r),
      description: n.description,
      type: n.type,
      defaultValue: n.defaultValue,
      deprecationReason: n.deprecationReason,
      extensions: toObjMap(n.extensions),
      astNode: n.astNode
    };
  }));
}

function isRequiredInputField(e) {
  return isNonNullType(e.type) && void 0 === e.defaultValue;
}

function isEqualType(e, n) {
  if (e === n) {
    return !0;
  }
  if (isNonNullType(e) && isNonNullType(n)) {
    return isEqualType(e.ofType, n.ofType);
  }
  if (isListType(e) && isListType(n)) {
    return isEqualType(e.ofType, n.ofType);
  }
  return !1;
}

function isTypeSubTypeOf(e, n, r) {
  if (n === r) {
    return !0;
  }
  if (isNonNullType(r)) {
    if (isNonNullType(n)) {
      return isTypeSubTypeOf(e, n.ofType, r.ofType);
    }
    return !1;
  }
  if (isNonNullType(n)) {
    return isTypeSubTypeOf(e, n.ofType, r);
  }
  if (isListType(r)) {
    if (isListType(n)) {
      return isTypeSubTypeOf(e, n.ofType, r.ofType);
    }
    return !1;
  }
  if (isListType(n)) {
    return !1;
  }
  return isAbstractType(r) && (isInterfaceType(n) || isObjectType(n)) && e.isSubType(r, n);
}

function doTypesOverlap(e, n, r) {
  if (n === r) {
    return !0;
  }
  if (isAbstractType(n)) {
    if (isAbstractType(r)) {
      return e.getPossibleTypes(n).some((n => e.isSubType(r, n)));
    }
    return e.isSubType(n, r);
  }
  if (isAbstractType(r)) {
    return e.isSubType(r, n);
  }
  return !1;
}

var S = 2147483647;

var _ = -2147483648;

var A = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(e) {
    var n = serializeObject(e);
    if ("boolean" == typeof n) {
      return n ? 1 : 0;
    }
    var r = n;
    if ("string" == typeof n && "" !== n) {
      r = Number(n);
    }
    if ("number" != typeof r || !Number.isInteger(r)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(n)}`);
    }
    if (r > S || r < _) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(n));
    }
    return r;
  },
  parseValue(e) {
    if ("number" != typeof e || !Number.isInteger(e)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(e)}`);
    }
    if (e > S || e < _) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${e}`);
    }
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== d.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print$1(e)}`, {
        nodes: e
      });
    }
    var n = parseInt(e.value, 10);
    if (n > S || n < _) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${e.value}`, {
        nodes: e
      });
    }
    return n;
  }
});

var O = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(e) {
    var n = serializeObject(e);
    if ("boolean" == typeof n) {
      return n ? 1 : 0;
    }
    var r = n;
    if ("string" == typeof n && "" !== n) {
      r = Number(n);
    }
    if ("number" != typeof r || !Number.isFinite(r)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(n)}`);
    }
    return r;
  },
  parseValue(e) {
    if ("number" != typeof e || !Number.isFinite(e)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(e)}`);
    }
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== d.FLOAT && e.kind !== d.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print$1(e)}`, e);
    }
    return parseFloat(e.value);
  }
});

var L = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(e) {
    var n = serializeObject(e);
    if ("string" == typeof n) {
      return n;
    }
    if ("boolean" == typeof n) {
      return n ? "true" : "false";
    }
    if ("number" == typeof n && Number.isFinite(n)) {
      return n.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(e)}`);
  },
  parseValue(e) {
    if ("string" != typeof e) {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(e)}`);
    }
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== d.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print$1(e)}`, {
        nodes: e
      });
    }
    return e.value;
  }
});

var D = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(e) {
    var n = serializeObject(e);
    if ("boolean" == typeof n) {
      return n;
    }
    if (Number.isFinite(n)) {
      return 0 !== n;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(n)}`);
  },
  parseValue(e) {
    if ("boolean" != typeof e) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(e)}`);
    }
    return e;
  },
  parseLiteral(e) {
    if (e.kind !== d.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print$1(e)}`, {
        nodes: e
      });
    }
    return e.value;
  }
});

var x = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(e) {
    var n = serializeObject(e);
    if ("string" == typeof n) {
      return n;
    }
    if (Number.isInteger(n)) {
      return String(n);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(e)}`);
  },
  parseValue(e) {
    if ("string" == typeof e) {
      return e;
    }
    if ("number" == typeof e && Number.isInteger(e)) {
      return e.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(e)}`);
  },
  parseLiteral(e) {
    if (e.kind !== d.STRING && e.kind !== d.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print$1(e), {
        nodes: e
      });
    }
    return e.value;
  }
});

var F = Object.freeze([ L, A, O, D, x ]);

function serializeObject(e) {
  if (isObjectLike(e)) {
    if ("function" == typeof e.valueOf) {
      var n = e.valueOf();
      if (!isObjectLike(n)) {
        return n;
      }
    }
    if ("function" == typeof e.toJSON) {
      return e.toJSON();
    }
  }
  return e;
}

function isDirective(e) {
  return m(e, GraphQLDirective);
}

class GraphQLDirective {
  constructor(e) {
    var n, r;
    this.name = assertName(e.name);
    this.description = e.description;
    this.locations = e.locations;
    this.isRepeatable = null !== (n = e.isRepeatable) && void 0 !== n ? n : !1;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    Array.isArray(e.locations) || devAssert(!1, `@${e.name} locations must be an Array.`);
    var i = null !== (r = e.args) && void 0 !== r ? r : {};
    isObjectLike(i) && !Array.isArray(i) || devAssert(!1, `@${e.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(i);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}

var w = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [ c.FIELD, c.FRAGMENT_SPREAD, c.INLINE_FRAGMENT ],
  args: {
    if: {
      type: new GraphQLNonNull(D),
      description: "Included when true."
    }
  }
});

var k = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [ c.FIELD, c.FRAGMENT_SPREAD, c.INLINE_FRAGMENT ],
  args: {
    if: {
      type: new GraphQLNonNull(D),
      description: "Skipped when true."
    }
  }
});

var C = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [ c.FIELD_DEFINITION, c.ARGUMENT_DEFINITION, c.INPUT_FIELD_DEFINITION, c.ENUM_VALUE ],
  args: {
    reason: {
      type: L,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: "No longer supported"
    }
  }
});

var R = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [ c.SCALAR ],
  args: {
    url: {
      type: new GraphQLNonNull(L),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});

var j = Object.freeze([ w, k, C, R ]);

function isIterableObject(e) {
  return "object" == typeof e && "function" == typeof (null == e ? void 0 : e[Symbol.iterator]);
}

function astFromValue(e, n) {
  if (isNonNullType(n)) {
    var r = astFromValue(e, n.ofType);
    if ((null == r ? void 0 : r.kind) === d.NULL) {
      return null;
    }
    return r;
  }
  if (null === e) {
    return {
      kind: d.NULL
    };
  }
  if (void 0 === e) {
    return null;
  }
  if (isListType(n)) {
    var i = n.ofType;
    if (isIterableObject(e)) {
      var a = [];
      for (var s of e) {
        var o = astFromValue(s, i);
        if (null != o) {
          a.push(o);
        }
      }
      return {
        kind: d.LIST,
        values: a
      };
    }
    return astFromValue(e, i);
  }
  if (isInputObjectType(n)) {
    if (!isObjectLike(e)) {
      return null;
    }
    var l = [];
    for (var u of Object.values(n.getFields())) {
      var c = astFromValue(e[u.name], u.type);
      if (c) {
        l.push({
          kind: d.OBJECT_FIELD,
          name: {
            kind: d.NAME,
            value: u.name
          },
          value: c
        });
      }
    }
    return {
      kind: d.OBJECT,
      fields: l
    };
  }
  if (isLeafType(n)) {
    var f = n.serialize(e);
    if (null == f) {
      return null;
    }
    if ("boolean" == typeof f) {
      return {
        kind: d.BOOLEAN,
        value: f
      };
    }
    if ("number" == typeof f && Number.isFinite(f)) {
      var v = String(f);
      return V.test(v) ? {
        kind: d.INT,
        value: v
      } : {
        kind: d.FLOAT,
        value: v
      };
    }
    if ("string" == typeof f) {
      if (isEnumType(n)) {
        return {
          kind: d.ENUM,
          value: f
        };
      }
      if (n === x && V.test(f)) {
        return {
          kind: d.INT,
          value: f
        };
      }
      return {
        kind: d.STRING,
        value: f
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(f)}.`);
  }
  invariant$1(!1, "Unexpected input type: " + inspect(n));
}

var V = /^-?(?:0|[1-9][0-9]*)$/;

var U = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: L,
      resolve: e => e.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(P))),
      resolve: e => Object.values(e.getTypeMap())
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(P),
      resolve: e => e.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: P,
      resolve: e => e.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: P,
      resolve: e => e.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(M))),
      resolve: e => e.getDirectives()
    }
  })
});

var M = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(L),
      resolve: e => e.name
    },
    description: {
      type: L,
      resolve: e => e.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(D),
      resolve: e => e.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull($))),
      resolve: e => e.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(Q))),
      args: {
        includeDeprecated: {
          type: D,
          defaultValue: !1
        }
      },
      resolve: (e, {includeDeprecated: n}) => n ? e.args : e.args.filter((e => null == e.deprecationReason))
    }
  })
});

var $ = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: c.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: c.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: c.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: c.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: c.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: c.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: c.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: c.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: c.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: c.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: c.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: c.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: c.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: c.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: c.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: c.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: c.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: c.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: c.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});

var P = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(Y),
      resolve(e) {
        if (isScalarType(e)) {
          return z.SCALAR;
        }
        if (isObjectType(e)) {
          return z.OBJECT;
        }
        if (isInterfaceType(e)) {
          return z.INTERFACE;
        }
        if (isUnionType(e)) {
          return z.UNION;
        }
        if (isEnumType(e)) {
          return z.ENUM;
        }
        if (isInputObjectType(e)) {
          return z.INPUT_OBJECT;
        }
        if (isListType(e)) {
          return z.LIST;
        }
        if (isNonNullType(e)) {
          return z.NON_NULL;
        }
        invariant$1(!1, `Unexpected type: "${inspect(e)}".`);
      }
    },
    name: {
      type: L,
      resolve: e => "name" in e ? e.name : void 0
    },
    description: {
      type: L,
      resolve: e => "description" in e ? e.description : void 0
    },
    specifiedByURL: {
      type: L,
      resolve: e => "specifiedByURL" in e ? e.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(G)),
      args: {
        includeDeprecated: {
          type: D,
          defaultValue: !1
        }
      },
      resolve(e, {includeDeprecated: n}) {
        if (isObjectType(e) || isInterfaceType(e)) {
          var r = Object.values(e.getFields());
          return n ? r : r.filter((e => null == e.deprecationReason));
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(P)),
      resolve(e) {
        if (isObjectType(e) || isInterfaceType(e)) {
          return e.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(P)),
      resolve(e, n, r, {schema: i}) {
        if (isAbstractType(e)) {
          return i.getPossibleTypes(e);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(B)),
      args: {
        includeDeprecated: {
          type: D,
          defaultValue: !1
        }
      },
      resolve(e, {includeDeprecated: n}) {
        if (isEnumType(e)) {
          var r = e.getValues();
          return n ? r : r.filter((e => null == e.deprecationReason));
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(Q)),
      args: {
        includeDeprecated: {
          type: D,
          defaultValue: !1
        }
      },
      resolve(e, {includeDeprecated: n}) {
        if (isInputObjectType(e)) {
          var r = Object.values(e.getFields());
          return n ? r : r.filter((e => null == e.deprecationReason));
        }
      }
    },
    ofType: {
      type: P,
      resolve: e => "ofType" in e ? e.ofType : void 0
    }
  })
});

var G = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(L),
      resolve: e => e.name
    },
    description: {
      type: L,
      resolve: e => e.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(Q))),
      args: {
        includeDeprecated: {
          type: D,
          defaultValue: !1
        }
      },
      resolve: (e, {includeDeprecated: n}) => n ? e.args : e.args.filter((e => null == e.deprecationReason))
    },
    type: {
      type: new GraphQLNonNull(P),
      resolve: e => e.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(D),
      resolve: e => null != e.deprecationReason
    },
    deprecationReason: {
      type: L,
      resolve: e => e.deprecationReason
    }
  })
});

var Q = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(L),
      resolve: e => e.name
    },
    description: {
      type: L,
      resolve: e => e.description
    },
    type: {
      type: new GraphQLNonNull(P),
      resolve: e => e.type
    },
    defaultValue: {
      type: L,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(e) {
        var {type: n, defaultValue: r} = e;
        var i = astFromValue(r, n);
        return i ? print$1(i) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(D),
      resolve: e => null != e.deprecationReason
    },
    deprecationReason: {
      type: L,
      resolve: e => e.deprecationReason
    }
  })
});

var B = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(L),
      resolve: e => e.name
    },
    description: {
      type: L,
      resolve: e => e.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(D),
      resolve: e => null != e.deprecationReason
    },
    deprecationReason: {
      type: L,
      resolve: e => e.deprecationReason
    }
  })
});

var z;

!function(e) {
  e.SCALAR = "SCALAR";
  e.OBJECT = "OBJECT";
  e.INTERFACE = "INTERFACE";
  e.UNION = "UNION";
  e.ENUM = "ENUM";
  e.INPUT_OBJECT = "INPUT_OBJECT";
  e.LIST = "LIST";
  e.NON_NULL = "NON_NULL";
}(z || (z = {}));

var Y = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: z.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: z.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: z.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: z.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: z.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: z.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: z.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: z.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});

var q = {
  name: "__schema",
  type: new GraphQLNonNull(U),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (e, n, r, {schema: i}) => i,
  deprecationReason: void 0,
  extensions: Object.create(null),
  astNode: void 0
};

var J = {
  name: "__type",
  type: P,
  description: "Request the type information of a single type.",
  args: [ {
    name: "name",
    description: void 0,
    type: new GraphQLNonNull(L),
    defaultValue: void 0,
    deprecationReason: void 0,
    extensions: Object.create(null),
    astNode: void 0
  } ],
  resolve: (e, {name: n}, r, {schema: i}) => i.getType(n),
  deprecationReason: void 0,
  extensions: Object.create(null),
  astNode: void 0
};

var W = {
  name: "__typename",
  type: new GraphQLNonNull(L),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (e, n, r, {parentType: i}) => i.name,
  deprecationReason: void 0,
  extensions: Object.create(null),
  astNode: void 0
};

var X = Object.freeze([ U, M, $, P, G, Q, B, Y ]);

function isIntrospectionType(e) {
  return X.some((({name: n}) => e.name === n));
}

function assertSchema(e) {
  if (!function isSchema(e) {
    return m(e, GraphQLSchema);
  }(e)) {
    throw new Error(`Expected ${inspect(e)} to be a GraphQL schema.`);
  }
  return e;
}

class GraphQLSchema {
  constructor(e) {
    var n, r;
    this.__validationErrors = !0 === e.assumeValid ? [] : void 0;
    isObjectLike(e) || devAssert(!1, "Must provide configuration object.");
    !e.types || Array.isArray(e.types) || devAssert(!1, `"types" must be Array if provided but got: ${inspect(e.types)}.`);
    !e.directives || Array.isArray(e.directives) || devAssert(!1, `"directives" must be Array if provided but got: ${inspect(e.directives)}.`);
    this.description = e.description;
    this.extensions = toObjMap(e.extensions);
    this.astNode = e.astNode;
    this.extensionASTNodes = null !== (n = e.extensionASTNodes) && void 0 !== n ? n : [];
    this._queryType = e.query;
    this._mutationType = e.mutation;
    this._subscriptionType = e.subscription;
    this._directives = null !== (r = e.directives) && void 0 !== r ? r : j;
    var i = new Set(e.types);
    if (null != e.types) {
      for (var a of e.types) {
        i.delete(a);
        collectReferencedTypes(a, i);
      }
    }
    if (null != this._queryType) {
      collectReferencedTypes(this._queryType, i);
    }
    if (null != this._mutationType) {
      collectReferencedTypes(this._mutationType, i);
    }
    if (null != this._subscriptionType) {
      collectReferencedTypes(this._subscriptionType, i);
    }
    for (var s of this._directives) {
      if (isDirective(s)) {
        for (var o of s.args) {
          collectReferencedTypes(o.type, i);
        }
      }
    }
    collectReferencedTypes(U, i);
    this._typeMap = Object.create(null);
    this._subTypeMap = Object.create(null);
    this._implementationsMap = Object.create(null);
    for (var l of i) {
      if (null == l) {
        continue;
      }
      var u = l.name;
      u || devAssert(!1, "One of the provided types for building the Schema is missing a name.");
      if (void 0 !== this._typeMap[u]) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${u}".`);
      }
      this._typeMap[u] = l;
      if (isInterfaceType(l)) {
        for (var c of l.getInterfaces()) {
          if (isInterfaceType(c)) {
            var d = this._implementationsMap[c.name];
            if (void 0 === d) {
              d = this._implementationsMap[c.name] = {
                objects: [],
                interfaces: []
              };
            }
            d.interfaces.push(l);
          }
        }
      } else if (isObjectType(l)) {
        for (var f of l.getInterfaces()) {
          if (isInterfaceType(f)) {
            var v = this._implementationsMap[f.name];
            if (void 0 === v) {
              v = this._implementationsMap[f.name] = {
                objects: [],
                interfaces: []
              };
            }
            v.objects.push(l);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(e) {
    switch (e) {
     case u.QUERY:
      return this.getQueryType();

     case u.MUTATION:
      return this.getMutationType();

     case u.SUBSCRIPTION:
      return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(e) {
    return this.getTypeMap()[e];
  }
  getPossibleTypes(e) {
    return isUnionType(e) ? e.getTypes() : this.getImplementations(e).objects;
  }
  getImplementations(e) {
    var n = this._implementationsMap[e.name];
    return null != n ? n : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(e, n) {
    var r = this._subTypeMap[e.name];
    if (void 0 === r) {
      r = Object.create(null);
      if (isUnionType(e)) {
        for (var i of e.getTypes()) {
          r[i.name] = !0;
        }
      } else {
        var a = this.getImplementations(e);
        for (var s of a.objects) {
          r[s.name] = !0;
        }
        for (var o of a.interfaces) {
          r[o.name] = !0;
        }
      }
      this._subTypeMap[e.name] = r;
    }
    return void 0 !== r[n.name];
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(e) {
    return this.getDirectives().find((n => n.name === e));
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: void 0 !== this.__validationErrors
    };
  }
}

function collectReferencedTypes(e, n) {
  var r = getNamedType(e);
  if (!n.has(r)) {
    n.add(r);
    if (isUnionType(r)) {
      for (var i of r.getTypes()) {
        collectReferencedTypes(i, n);
      }
    } else if (isObjectType(r) || isInterfaceType(r)) {
      for (var a of r.getInterfaces()) {
        collectReferencedTypes(a, n);
      }
      for (var s of Object.values(r.getFields())) {
        collectReferencedTypes(s.type, n);
        for (var o of s.args) {
          collectReferencedTypes(o.type, n);
        }
      }
    } else if (isInputObjectType(r)) {
      for (var l of Object.values(r.getFields())) {
        collectReferencedTypes(l.type, n);
      }
    }
  }
  return n;
}

function validateSchema(e) {
  assertSchema(e);
  if (e.__validationErrors) {
    return e.__validationErrors;
  }
  var n = new SchemaValidationContext(e);
  !function validateRootTypes(e) {
    var n = e.schema;
    var r = n.getQueryType();
    if (!r) {
      e.reportError("Query root type must be provided.", n.astNode);
    } else if (!isObjectType(r)) {
      var i;
      e.reportError(`Query root type must be Object type, it cannot be ${inspect(r)}.`, null !== (i = getOperationTypeNode(n, u.QUERY)) && void 0 !== i ? i : r.astNode);
    }
    var a = n.getMutationType();
    if (a && !isObjectType(a)) {
      var s;
      e.reportError(`Mutation root type must be Object type if provided, it cannot be ${inspect(a)}.`, null !== (s = getOperationTypeNode(n, u.MUTATION)) && void 0 !== s ? s : a.astNode);
    }
    var o = n.getSubscriptionType();
    if (o && !isObjectType(o)) {
      var l;
      e.reportError(`Subscription root type must be Object type if provided, it cannot be ${inspect(o)}.`, null !== (l = getOperationTypeNode(n, u.SUBSCRIPTION)) && void 0 !== l ? l : o.astNode);
    }
  }(n);
  !function validateDirectives(e) {
    for (var n of e.schema.getDirectives()) {
      if (!isDirective(n)) {
        e.reportError(`Expected directive but got: ${inspect(n)}.`, null == n ? void 0 : n.astNode);
        continue;
      }
      validateName(e, n);
      for (var r of n.args) {
        validateName(e, r);
        if (!isInputType(r.type)) {
          e.reportError(`The type of @${n.name}(${r.name}:) must be Input Type but got: ${inspect(r.type)}.`, r.astNode);
        }
        if (isRequiredArgument(r) && null != r.deprecationReason) {
          var i;
          e.reportError(`Required argument @${n.name}(${r.name}:) cannot be deprecated.`, [ getDeprecatedDirectiveNode(r.astNode), null === (i = r.astNode) || void 0 === i ? void 0 : i.type ]);
        }
      }
    }
  }(n);
  !function validateTypes(e) {
    var n = function createInputObjectCircularRefsValidator(e) {
      var n = Object.create(null);
      var r = [];
      var i = Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(a) {
        if (n[a.name]) {
          return;
        }
        n[a.name] = !0;
        i[a.name] = r.length;
        var s = Object.values(a.getFields());
        for (var o of s) {
          if (isNonNullType(o.type) && isInputObjectType(o.type.ofType)) {
            var l = o.type.ofType;
            var u = i[l.name];
            r.push(o);
            if (void 0 === u) {
              detectCycleRecursive(l);
            } else {
              var c = r.slice(u);
              var d = c.map((e => e.name)).join(".");
              e.reportError(`Cannot reference Input Object "${l.name}" within itself through a series of non-null fields: "${d}".`, c.map((e => e.astNode)));
            }
            r.pop();
          }
        }
        i[a.name] = void 0;
      }
    }(e);
    var r = e.schema.getTypeMap();
    for (var i of Object.values(r)) {
      if (!isNamedType(i)) {
        e.reportError(`Expected GraphQL named type but got: ${inspect(i)}.`, i.astNode);
        continue;
      }
      if (!isIntrospectionType(i)) {
        validateName(e, i);
      }
      if (isObjectType(i)) {
        validateFields(e, i);
        validateInterfaces(e, i);
      } else if (isInterfaceType(i)) {
        validateFields(e, i);
        validateInterfaces(e, i);
      } else if (isUnionType(i)) {
        validateUnionMembers(e, i);
      } else if (isEnumType(i)) {
        validateEnumValues(e, i);
      } else if (isInputObjectType(i)) {
        validateInputFields(e, i);
        n(i);
      }
    }
  }(n);
  var r = n.getErrors();
  e.__validationErrors = r;
  return r;
}

function assertValidSchema(e) {
  var n = validateSchema(e);
  if (0 !== n.length) {
    throw new Error(n.map((e => e.message)).join("\n\n"));
  }
}

class SchemaValidationContext {
  constructor(e) {
    this._errors = [];
    this.schema = e;
  }
  reportError(e, n) {
    var r = Array.isArray(n) ? n.filter(Boolean) : n;
    this._errors.push(new GraphQLError(e, {
      nodes: r
    }));
  }
  getErrors() {
    return this._errors;
  }
}

function getOperationTypeNode(e, n) {
  var r;
  return null === (r = [ e.astNode, ...e.extensionASTNodes ].flatMap((e => {
    var n;
    return null !== (n = null == e ? void 0 : e.operationTypes) && void 0 !== n ? n : [];
  })).find((e => e.operation === n))) || void 0 === r ? void 0 : r.type;
}

function validateName(e, n) {
  if (n.name.startsWith("__")) {
    e.reportError(`Name "${n.name}" must not begin with "__", which is reserved by GraphQL introspection.`, n.astNode);
  }
}

function validateFields(e, n) {
  var r = Object.values(n.getFields());
  if (0 === r.length) {
    e.reportError(`Type ${n.name} must define one or more fields.`, [ n.astNode, ...n.extensionASTNodes ]);
  }
  for (var i of r) {
    validateName(e, i);
    if (!isOutputType(i.type)) {
      var a;
      e.reportError(`The type of ${n.name}.${i.name} must be Output Type but got: ${inspect(i.type)}.`, null === (a = i.astNode) || void 0 === a ? void 0 : a.type);
    }
    for (var s of i.args) {
      var o = s.name;
      validateName(e, s);
      if (!isInputType(s.type)) {
        var l;
        e.reportError(`The type of ${n.name}.${i.name}(${o}:) must be Input Type but got: ${inspect(s.type)}.`, null === (l = s.astNode) || void 0 === l ? void 0 : l.type);
      }
      if (isRequiredArgument(s) && null != s.deprecationReason) {
        var u;
        e.reportError(`Required argument ${n.name}.${i.name}(${o}:) cannot be deprecated.`, [ getDeprecatedDirectiveNode(s.astNode), null === (u = s.astNode) || void 0 === u ? void 0 : u.type ]);
      }
    }
  }
}

function validateInterfaces(e, n) {
  var r = Object.create(null);
  for (var i of n.getInterfaces()) {
    if (!isInterfaceType(i)) {
      e.reportError(`Type ${inspect(n)} must only implement Interface types, it cannot implement ${inspect(i)}.`, getAllImplementsInterfaceNodes(n, i));
      continue;
    }
    if (n === i) {
      e.reportError(`Type ${n.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(n, i));
      continue;
    }
    if (r[i.name]) {
      e.reportError(`Type ${n.name} can only implement ${i.name} once.`, getAllImplementsInterfaceNodes(n, i));
      continue;
    }
    r[i.name] = !0;
    validateTypeImplementsAncestors(e, n, i);
    validateTypeImplementsInterface(e, n, i);
  }
}

function validateTypeImplementsInterface(e, n, r) {
  var i = n.getFields();
  for (var a of Object.values(r.getFields())) {
    var s = a.name;
    var o = i[s];
    if (!o) {
      e.reportError(`Interface field ${r.name}.${s} expected but ${n.name} does not provide it.`, [ a.astNode, n.astNode, ...n.extensionASTNodes ]);
      continue;
    }
    if (!isTypeSubTypeOf(e.schema, o.type, a.type)) {
      var l, u;
      e.reportError(`Interface field ${r.name}.${s} expects type ${inspect(a.type)} but ${n.name}.${s} is type ${inspect(o.type)}.`, [ null === (l = a.astNode) || void 0 === l ? void 0 : l.type, null === (u = o.astNode) || void 0 === u ? void 0 : u.type ]);
    }
    var c, d, _loop = function() {
      var i = f.name;
      var a = o.args.find((e => e.name === i));
      if (!a) {
        e.reportError(`Interface field argument ${r.name}.${s}(${i}:) expected but ${n.name}.${s} does not provide it.`, [ f.astNode, o.astNode ]);
        return 1;
      }
      if (!isEqualType(f.type, a.type)) {
        e.reportError(`Interface field argument ${r.name}.${s}(${i}:) expects type ${inspect(f.type)} but ${n.name}.${s}(${i}:) is type ${inspect(a.type)}.`, [ null === (c = f.astNode) || void 0 === c ? void 0 : c.type, null === (d = a.astNode) || void 0 === d ? void 0 : d.type ]);
      }
    };
    for (var f of a.args) {
      if (_loop()) {
        continue;
      }
    }
    var _loop2 = function() {
      var i = v.name;
      if (!a.args.find((e => e.name === i)) && isRequiredArgument(v)) {
        e.reportError(`Object field ${n.name}.${s} includes required argument ${i} that is missing from the Interface field ${r.name}.${s}.`, [ v.astNode, a.astNode ]);
      }
    };
    for (var v of o.args) {
      _loop2();
    }
  }
}

function validateTypeImplementsAncestors(e, n, r) {
  var i = n.getInterfaces();
  for (var a of r.getInterfaces()) {
    if (!i.includes(a)) {
      e.reportError(a === n ? `Type ${n.name} cannot implement ${r.name} because it would create a circular reference.` : `Type ${n.name} must implement ${a.name} because it is implemented by ${r.name}.`, [ ...getAllImplementsInterfaceNodes(r, a), ...getAllImplementsInterfaceNodes(n, r) ]);
    }
  }
}

function validateUnionMembers(e, n) {
  var r = n.getTypes();
  if (0 === r.length) {
    e.reportError(`Union type ${n.name} must define one or more member types.`, [ n.astNode, ...n.extensionASTNodes ]);
  }
  var i = Object.create(null);
  for (var a of r) {
    if (i[a.name]) {
      e.reportError(`Union type ${n.name} can only include type ${a.name} once.`, getUnionMemberTypeNodes(n, a.name));
      continue;
    }
    i[a.name] = !0;
    if (!isObjectType(a)) {
      e.reportError(`Union type ${n.name} can only include Object types, it cannot include ${inspect(a)}.`, getUnionMemberTypeNodes(n, String(a)));
    }
  }
}

function validateEnumValues(e, n) {
  var r = n.getValues();
  if (0 === r.length) {
    e.reportError(`Enum type ${n.name} must define one or more values.`, [ n.astNode, ...n.extensionASTNodes ]);
  }
  for (var i of r) {
    validateName(e, i);
  }
}

function validateInputFields(e, n) {
  var r = Object.values(n.getFields());
  if (0 === r.length) {
    e.reportError(`Input Object type ${n.name} must define one or more fields.`, [ n.astNode, ...n.extensionASTNodes ]);
  }
  for (var i of r) {
    validateName(e, i);
    if (!isInputType(i.type)) {
      var a;
      e.reportError(`The type of ${n.name}.${i.name} must be Input Type but got: ${inspect(i.type)}.`, null === (a = i.astNode) || void 0 === a ? void 0 : a.type);
    }
    if (isRequiredInputField(i) && null != i.deprecationReason) {
      var s;
      e.reportError(`Required input field ${n.name}.${i.name} cannot be deprecated.`, [ getDeprecatedDirectiveNode(i.astNode), null === (s = i.astNode) || void 0 === s ? void 0 : s.type ]);
    }
  }
}

function getAllImplementsInterfaceNodes(e, n) {
  var {astNode: r, extensionASTNodes: i} = e;
  return (null != r ? [ r, ...i ] : i).flatMap((e => {
    var n;
    return null !== (n = e.interfaces) && void 0 !== n ? n : [];
  })).filter((e => e.name.value === n.name));
}

function getUnionMemberTypeNodes(e, n) {
  var {astNode: r, extensionASTNodes: i} = e;
  return (null != r ? [ r, ...i ] : i).flatMap((e => {
    var n;
    return null !== (n = e.types) && void 0 !== n ? n : [];
  })).filter((e => e.name.value === n));
}

function getDeprecatedDirectiveNode(e) {
  var n;
  return null == e ? void 0 : null === (n = e.directives) || void 0 === n ? void 0 : n.find((e => e.name.value === C.name));
}

function typeFromAST(e, n) {
  switch (n.kind) {
   case d.LIST_TYPE:
    var r = typeFromAST(e, n.type);
    return r && new GraphQLList(r);

   case d.NON_NULL_TYPE:
    var i = typeFromAST(e, n.type);
    return i && new GraphQLNonNull(i);

   case d.NAMED_TYPE:
    return e.getType(n.name.value);
  }
}

class TypeInfo {
  constructor(e, n, r) {
    this._schema = e;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = null != r ? r : getFieldDef$2;
    if (n) {
      if (isInputType(n)) {
        this._inputTypeStack.push(n);
      }
      if (isCompositeType(n)) {
        this._parentTypeStack.push(n);
      }
      if (isOutputType(n)) {
        this._typeStack.push(n);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(e) {
    var n = this._schema;
    switch (e.kind) {
     case d.SELECTION_SET:
      var r = getNamedType(this.getType());
      this._parentTypeStack.push(isCompositeType(r) ? r : void 0);
      break;

     case d.FIELD:
      var i = this.getParentType();
      var a;
      var s;
      if (i) {
        if (a = this._getFieldDef(n, i, e)) {
          s = a.type;
        }
      }
      this._fieldDefStack.push(a);
      this._typeStack.push(isOutputType(s) ? s : void 0);
      break;

     case d.DIRECTIVE:
      this._directive = n.getDirective(e.name.value);
      break;

     case d.OPERATION_DEFINITION:
      var o = n.getRootType(e.operation);
      this._typeStack.push(isObjectType(o) ? o : void 0);
      break;

     case d.INLINE_FRAGMENT:
     case d.FRAGMENT_DEFINITION:
      var l = e.typeCondition;
      var u = l ? typeFromAST(n, l) : getNamedType(this.getType());
      this._typeStack.push(isOutputType(u) ? u : void 0);
      break;

     case d.VARIABLE_DEFINITION:
      var c = typeFromAST(n, e.type);
      this._inputTypeStack.push(isInputType(c) ? c : void 0);
      break;

     case d.ARGUMENT:
      var f;
      var v;
      var h;
      var m = null !== (f = this.getDirective()) && void 0 !== f ? f : this.getFieldDef();
      if (m) {
        if (v = m.args.find((n => n.name === e.name.value))) {
          h = v.type;
        }
      }
      this._argument = v;
      this._defaultValueStack.push(v ? v.defaultValue : void 0);
      this._inputTypeStack.push(isInputType(h) ? h : void 0);
      break;

     case d.LIST:
      var g = getNullableType(this.getInputType());
      var y = isListType(g) ? g.ofType : g;
      this._defaultValueStack.push(void 0);
      this._inputTypeStack.push(isInputType(y) ? y : void 0);
      break;

     case d.OBJECT_FIELD:
      var T = getNamedType(this.getInputType());
      var E;
      var N;
      if (isInputObjectType(T)) {
        if (N = T.getFields()[e.name.value]) {
          E = N.type;
        }
      }
      this._defaultValueStack.push(N ? N.defaultValue : void 0);
      this._inputTypeStack.push(isInputType(E) ? E : void 0);
      break;

     case d.ENUM:
      var I = getNamedType(this.getInputType());
      var b;
      if (isEnumType(I)) {
        b = I.getValue(e.value);
      }
      this._enumValue = b;
    }
  }
  leave(e) {
    switch (e.kind) {
     case d.SELECTION_SET:
      this._parentTypeStack.pop();
      break;

     case d.FIELD:
      this._fieldDefStack.pop();
      this._typeStack.pop();
      break;

     case d.DIRECTIVE:
      this._directive = null;
      break;

     case d.OPERATION_DEFINITION:
     case d.INLINE_FRAGMENT:
     case d.FRAGMENT_DEFINITION:
      this._typeStack.pop();
      break;

     case d.VARIABLE_DEFINITION:
      this._inputTypeStack.pop();
      break;

     case d.ARGUMENT:
      this._argument = null;
      this._defaultValueStack.pop();
      this._inputTypeStack.pop();
      break;

     case d.LIST:
     case d.OBJECT_FIELD:
      this._defaultValueStack.pop();
      this._inputTypeStack.pop();
      break;

     case d.ENUM:
      this._enumValue = null;
    }
  }
}

function getFieldDef$2(e, n, r) {
  var i = r.name.value;
  if (i === q.name && e.getQueryType() === n) {
    return q;
  }
  if (i === J.name && e.getQueryType() === n) {
    return J;
  }
  if (i === W.name && isCompositeType(n)) {
    return W;
  }
  if (isObjectType(n) || isInterfaceType(n)) {
    return n.getFields()[i];
  }
}

function visitWithTypeInfo(e, n) {
  return {
    enter(...r) {
      var i = r[0];
      e.enter(i);
      var a = getEnterLeaveForKind(n, i.kind).enter;
      if (a) {
        var s = a.apply(n, r);
        if (void 0 !== s) {
          e.leave(i);
          if (isNode(s)) {
            e.enter(s);
          }
        }
        return s;
      }
    },
    leave(...r) {
      var i = r[0];
      var a = getEnterLeaveForKind(n, i.kind).leave;
      var s;
      if (a) {
        s = a.apply(n, r);
      }
      e.leave(i);
      return s;
    }
  };
}

function isExecutableDefinitionNode(e) {
  return e.kind === d.OPERATION_DEFINITION || e.kind === d.FRAGMENT_DEFINITION;
}

function isTypeDefinitionNode(e) {
  return e.kind === d.SCALAR_TYPE_DEFINITION || e.kind === d.OBJECT_TYPE_DEFINITION || e.kind === d.INTERFACE_TYPE_DEFINITION || e.kind === d.UNION_TYPE_DEFINITION || e.kind === d.ENUM_TYPE_DEFINITION || e.kind === d.INPUT_OBJECT_TYPE_DEFINITION;
}

function isTypeExtensionNode(e) {
  return e.kind === d.SCALAR_TYPE_EXTENSION || e.kind === d.OBJECT_TYPE_EXTENSION || e.kind === d.INTERFACE_TYPE_EXTENSION || e.kind === d.UNION_TYPE_EXTENSION || e.kind === d.ENUM_TYPE_EXTENSION || e.kind === d.INPUT_OBJECT_TYPE_EXTENSION;
}

function ExecutableDefinitionsRule(e) {
  return {
    Document(n) {
      for (var r of n.definitions) {
        if (!isExecutableDefinitionNode(r)) {
          e.reportError(new GraphQLError(`The ${r.kind === d.SCHEMA_DEFINITION || r.kind === d.SCHEMA_EXTENSION ? "schema" : '"' + r.name.value + '"'} definition is not executable.`, {
            nodes: r
          }));
        }
      }
      return !1;
    }
  };
}

function KnownArgumentNamesOnDirectivesRule(e) {
  var n = Object.create(null);
  var r = e.getSchema();
  var i = r ? r.getDirectives() : j;
  for (var a of i) {
    n[a.name] = a.args.map((e => e.name));
  }
  var s = e.getDocument().definitions;
  for (var o of s) {
    if (o.kind === d.DIRECTIVE_DEFINITION) {
      var l;
      var u = null !== (l = o.arguments) && void 0 !== l ? l : [];
      n[o.name.value] = u.map((e => e.name.value));
    }
  }
  return {
    Directive(r) {
      var i = r.name.value;
      var a = n[i];
      if (r.arguments && a) {
        for (var s of r.arguments) {
          var o = s.name.value;
          if (!a.includes(o)) {
            var l = suggestionList(o, a);
            e.reportError(new GraphQLError(`Unknown argument "${o}" on directive "@${i}".` + didYouMean(l), {
              nodes: s
            }));
          }
        }
      }
      return !1;
    }
  };
}

function KnownDirectivesRule(e) {
  var n = Object.create(null);
  var r = e.getSchema();
  var i = r ? r.getDirectives() : j;
  for (var a of i) {
    n[a.name] = a.locations;
  }
  var s = e.getDocument().definitions;
  for (var o of s) {
    if (o.kind === d.DIRECTIVE_DEFINITION) {
      n[o.name.value] = o.locations.map((e => e.value));
    }
  }
  return {
    Directive(r, i, a, s, o) {
      var l = r.name.value;
      var f = n[l];
      if (!f) {
        e.reportError(new GraphQLError(`Unknown directive "@${l}".`, {
          nodes: r
        }));
        return;
      }
      var v = function getDirectiveLocationForASTPath(e) {
        var n = e[e.length - 1];
        "kind" in n || invariant$1(!1);
        switch (n.kind) {
         case d.OPERATION_DEFINITION:
          return function getDirectiveLocationForOperation(e) {
            switch (e) {
             case u.QUERY:
              return c.QUERY;

             case u.MUTATION:
              return c.MUTATION;

             case u.SUBSCRIPTION:
              return c.SUBSCRIPTION;
            }
          }(n.operation);

         case d.FIELD:
          return c.FIELD;

         case d.FRAGMENT_SPREAD:
          return c.FRAGMENT_SPREAD;

         case d.INLINE_FRAGMENT:
          return c.INLINE_FRAGMENT;

         case d.FRAGMENT_DEFINITION:
          return c.FRAGMENT_DEFINITION;

         case d.VARIABLE_DEFINITION:
          return c.VARIABLE_DEFINITION;

         case d.SCHEMA_DEFINITION:
         case d.SCHEMA_EXTENSION:
          return c.SCHEMA;

         case d.SCALAR_TYPE_DEFINITION:
         case d.SCALAR_TYPE_EXTENSION:
          return c.SCALAR;

         case d.OBJECT_TYPE_DEFINITION:
         case d.OBJECT_TYPE_EXTENSION:
          return c.OBJECT;

         case d.FIELD_DEFINITION:
          return c.FIELD_DEFINITION;

         case d.INTERFACE_TYPE_DEFINITION:
         case d.INTERFACE_TYPE_EXTENSION:
          return c.INTERFACE;

         case d.UNION_TYPE_DEFINITION:
         case d.UNION_TYPE_EXTENSION:
          return c.UNION;

         case d.ENUM_TYPE_DEFINITION:
         case d.ENUM_TYPE_EXTENSION:
          return c.ENUM;

         case d.ENUM_VALUE_DEFINITION:
          return c.ENUM_VALUE;

         case d.INPUT_OBJECT_TYPE_DEFINITION:
         case d.INPUT_OBJECT_TYPE_EXTENSION:
          return c.INPUT_OBJECT;

         case d.INPUT_VALUE_DEFINITION:
          var r = e[e.length - 3];
          "kind" in r || invariant$1(!1);
          return r.kind === d.INPUT_OBJECT_TYPE_DEFINITION ? c.INPUT_FIELD_DEFINITION : c.ARGUMENT_DEFINITION;

         default:
          invariant$1(!1, "Unexpected kind: " + inspect(n.kind));
        }
      }(o);
      if (v && !f.includes(v)) {
        e.reportError(new GraphQLError(`Directive "@${l}" may not be used on ${v}.`, {
          nodes: r
        }));
      }
    }
  };
}

function KnownFragmentNamesRule(e) {
  return {
    FragmentSpread(n) {
      var r = n.name.value;
      if (!e.getFragment(r)) {
        e.reportError(new GraphQLError(`Unknown fragment "${r}".`, {
          nodes: n.name
        }));
      }
    }
  };
}

function KnownTypeNamesRule(e) {
  var n = e.getSchema();
  var r = n ? n.getTypeMap() : Object.create(null);
  var i = Object.create(null);
  for (var a of e.getDocument().definitions) {
    if (isTypeDefinitionNode(a)) {
      i[a.name.value] = !0;
    }
  }
  var s = [ ...Object.keys(r), ...Object.keys(i) ];
  return {
    NamedType(n, a, o, l, u) {
      var c = n.name.value;
      if (!r[c] && !i[c]) {
        var f;
        var v = null !== (f = u[2]) && void 0 !== f ? f : o;
        var h = null != v && function isSDLNode(e) {
          return "kind" in e && (function isTypeSystemDefinitionNode(e) {
            return e.kind === d.SCHEMA_DEFINITION || isTypeDefinitionNode(e) || e.kind === d.DIRECTIVE_DEFINITION;
          }(e) || function isTypeSystemExtensionNode(e) {
            return e.kind === d.SCHEMA_EXTENSION || isTypeExtensionNode(e);
          }(e));
        }(v);
        if (h && K.includes(c)) {
          return;
        }
        var m = suggestionList(c, h ? K.concat(s) : s);
        e.reportError(new GraphQLError(`Unknown type "${c}".` + didYouMean(m), {
          nodes: n
        }));
      }
    }
  };
}

var K = [ ...F, ...X ].map((e => e.name));

function LoneSchemaDefinitionRule(e) {
  var n, r, i;
  var a = e.getSchema();
  var s = null !== (n = null !== (r = null !== (i = null == a ? void 0 : a.astNode) && void 0 !== i ? i : null == a ? void 0 : a.getQueryType()) && void 0 !== r ? r : null == a ? void 0 : a.getMutationType()) && void 0 !== n ? n : null == a ? void 0 : a.getSubscriptionType();
  var o = 0;
  return {
    SchemaDefinition(n) {
      if (s) {
        e.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", {
          nodes: n
        }));
        return;
      }
      if (o > 0) {
        e.reportError(new GraphQLError("Must provide only one schema definition.", {
          nodes: n
        }));
      }
      ++o;
    }
  };
}

function NoUnusedFragmentsRule(e) {
  var n = [];
  var r = [];
  return {
    OperationDefinition(e) {
      n.push(e);
      return !1;
    },
    FragmentDefinition(e) {
      r.push(e);
      return !1;
    },
    Document: {
      leave() {
        var i = Object.create(null);
        for (var a of n) {
          for (var s of e.getRecursivelyReferencedFragments(a)) {
            i[s.name.value] = !0;
          }
        }
        for (var o of r) {
          var l = o.name.value;
          if (!0 !== i[l]) {
            e.reportError(new GraphQLError(`Fragment "${l}" is never used.`, {
              nodes: o
            }));
          }
        }
      }
    }
  };
}

function sortValueNode(e) {
  switch (e.kind) {
   case d.OBJECT:
    return {
      ...e,
      fields: (n = e.fields, n.map((e => ({
        ...e,
        value: sortValueNode(e.value)
      }))).sort(((e, n) => naturalCompare(e.name.value, n.name.value))))
    };

   case d.LIST:
    return {
      ...e,
      values: e.values.map(sortValueNode)
    };

   case d.INT:
   case d.FLOAT:
   case d.STRING:
   case d.BOOLEAN:
   case d.NULL:
   case d.ENUM:
   case d.VARIABLE:
    return e;
  }
  var n;
}

function reasonMessage(e) {
  if (Array.isArray(e)) {
    return e.map((([e, n]) => `subfields "${e}" conflict because ` + reasonMessage(n))).join(" and ");
  }
  return e;
}

function collectConflictsBetweenFieldsAndFragment(e, n, r, i, a, s, o) {
  var l = e.getFragment(o);
  if (!l) {
    return;
  }
  var [u, c] = getReferencedFieldsAndFragmentNames(e, r, l);
  if (s === u) {
    return;
  }
  collectConflictsBetween(e, n, r, i, a, s, u);
  for (var d of c) {
    if (i.has(d, o, a)) {
      continue;
    }
    i.add(d, o, a);
    collectConflictsBetweenFieldsAndFragment(e, n, r, i, a, s, d);
  }
}

function collectConflictsBetweenFragments(e, n, r, i, a, s, o) {
  if (s === o) {
    return;
  }
  if (i.has(s, o, a)) {
    return;
  }
  i.add(s, o, a);
  var l = e.getFragment(s);
  var u = e.getFragment(o);
  if (!l || !u) {
    return;
  }
  var [c, d] = getReferencedFieldsAndFragmentNames(e, r, l);
  var [f, v] = getReferencedFieldsAndFragmentNames(e, r, u);
  collectConflictsBetween(e, n, r, i, a, c, f);
  for (var h of v) {
    collectConflictsBetweenFragments(e, n, r, i, a, s, h);
  }
  for (var m of d) {
    collectConflictsBetweenFragments(e, n, r, i, a, m, o);
  }
}

function collectConflictsBetween(e, n, r, i, a, s, o) {
  for (var [l, u] of Object.entries(s)) {
    var c = o[l];
    if (c) {
      for (var d of u) {
        for (var f of c) {
          var v = findConflict(e, r, i, a, l, d, f);
          if (v) {
            n.push(v);
          }
        }
      }
    }
  }
}

function findConflict(e, n, r, i, a, s, o) {
  var [l, u, c] = s;
  var [d, f, v] = o;
  var h = i || l !== d && isObjectType(l) && isObjectType(d);
  if (!h) {
    var m = u.name.value;
    var g = f.name.value;
    if (m !== g) {
      return [ [ a, `"${m}" and "${g}" are different fields` ], [ u ], [ f ] ];
    }
    if (!function sameArguments(e, n) {
      var r = e.arguments;
      var i = n.arguments;
      if (void 0 === r || 0 === r.length) {
        return void 0 === i || 0 === i.length;
      }
      if (void 0 === i || 0 === i.length) {
        return !1;
      }
      if (r.length !== i.length) {
        return !1;
      }
      var a = new Map(i.map((({name: e, value: n}) => [ e.value, n ])));
      return r.every((e => {
        var n = e.value;
        var r = a.get(e.name.value);
        if (void 0 === r) {
          return !1;
        }
        return stringifyValue(n) === stringifyValue(r);
      }));
    }(u, f)) {
      return [ [ a, "they have differing arguments" ], [ u ], [ f ] ];
    }
  }
  var y = null == c ? void 0 : c.type;
  var T = null == v ? void 0 : v.type;
  if (y && T && doTypesConflict(y, T)) {
    return [ [ a, `they return conflicting types "${inspect(y)}" and "${inspect(T)}"` ], [ u ], [ f ] ];
  }
  var E = u.selectionSet;
  var N = f.selectionSet;
  if (E && N) {
    var I = function findConflictsBetweenSubSelectionSets(e, n, r, i, a, s, o, l) {
      var u = [];
      var [c, d] = getFieldsAndFragmentNames(e, n, a, s);
      var [f, v] = getFieldsAndFragmentNames(e, n, o, l);
      collectConflictsBetween(e, u, n, r, i, c, f);
      for (var h of v) {
        collectConflictsBetweenFieldsAndFragment(e, u, n, r, i, c, h);
      }
      for (var m of d) {
        collectConflictsBetweenFieldsAndFragment(e, u, n, r, i, f, m);
      }
      for (var g of d) {
        for (var y of v) {
          collectConflictsBetweenFragments(e, u, n, r, i, g, y);
        }
      }
      return u;
    }(e, n, r, h, getNamedType(y), E, getNamedType(T), N);
    return function subfieldConflicts(e, n, r, i) {
      if (e.length > 0) {
        return [ [ n, e.map((([e]) => e)) ], [ r, ...e.map((([, e]) => e)).flat() ], [ i, ...e.map((([, , e]) => e)).flat() ] ];
      }
    }(I, a, u, f);
  }
}

function stringifyValue(e) {
  return print$1(sortValueNode(e));
}

function doTypesConflict(e, n) {
  if (isListType(e)) {
    return isListType(n) ? doTypesConflict(e.ofType, n.ofType) : !0;
  }
  if (isListType(n)) {
    return !0;
  }
  if (isNonNullType(e)) {
    return isNonNullType(n) ? doTypesConflict(e.ofType, n.ofType) : !0;
  }
  if (isNonNullType(n)) {
    return !0;
  }
  if (isLeafType(e) || isLeafType(n)) {
    return e !== n;
  }
  return !1;
}

function getFieldsAndFragmentNames(e, n, r, i) {
  var a = n.get(i);
  if (a) {
    return a;
  }
  var s = Object.create(null);
  var o = Object.create(null);
  _collectFieldsAndFragmentNames(e, r, i, s, o);
  var l = [ s, Object.keys(o) ];
  n.set(i, l);
  return l;
}

function getReferencedFieldsAndFragmentNames(e, n, r) {
  var i = n.get(r.selectionSet);
  if (i) {
    return i;
  }
  var a = typeFromAST(e.getSchema(), r.typeCondition);
  return getFieldsAndFragmentNames(e, n, a, r.selectionSet);
}

function _collectFieldsAndFragmentNames(e, n, r, i, a) {
  for (var s of r.selections) {
    switch (s.kind) {
     case d.FIELD:
      var o = s.name.value;
      var l = void 0;
      if (isObjectType(n) || isInterfaceType(n)) {
        l = n.getFields()[o];
      }
      var u = s.alias ? s.alias.value : o;
      if (!i[u]) {
        i[u] = [];
      }
      i[u].push([ n, s, l ]);
      break;

     case d.FRAGMENT_SPREAD:
      a[s.name.value] = !0;
      break;

     case d.INLINE_FRAGMENT:
      var c = s.typeCondition;
      var f = c ? typeFromAST(e.getSchema(), c) : n;
      _collectFieldsAndFragmentNames(e, f, s.selectionSet, i, a);
    }
  }
}

class PairSet {
  constructor() {
    this._data = new Map;
  }
  has(e, n, r) {
    var i;
    var [a, s] = e < n ? [ e, n ] : [ n, e ];
    var o = null === (i = this._data.get(a)) || void 0 === i ? void 0 : i.get(s);
    if (void 0 === o) {
      return !1;
    }
    return r ? !0 : r === o;
  }
  add(e, n, r) {
    var [i, a] = e < n ? [ e, n ] : [ n, e ];
    var s = this._data.get(i);
    if (void 0 === s) {
      this._data.set(i, new Map([ [ a, r ] ]));
    } else {
      s.set(a, r);
    }
  }
}

function PossibleTypeExtensionsRule(e) {
  var n = e.getSchema();
  var r = Object.create(null);
  for (var i of e.getDocument().definitions) {
    if (isTypeDefinitionNode(i)) {
      r[i.name.value] = i;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(i) {
    var a = i.name.value;
    var s = r[a];
    var o = null == n ? void 0 : n.getType(a);
    var l;
    if (s) {
      l = H[s.kind];
    } else if (o) {
      l = function typeToExtKind(e) {
        if (isScalarType(e)) {
          return d.SCALAR_TYPE_EXTENSION;
        }
        if (isObjectType(e)) {
          return d.OBJECT_TYPE_EXTENSION;
        }
        if (isInterfaceType(e)) {
          return d.INTERFACE_TYPE_EXTENSION;
        }
        if (isUnionType(e)) {
          return d.UNION_TYPE_EXTENSION;
        }
        if (isEnumType(e)) {
          return d.ENUM_TYPE_EXTENSION;
        }
        if (isInputObjectType(e)) {
          return d.INPUT_OBJECT_TYPE_EXTENSION;
        }
        invariant$1(!1, "Unexpected type: " + inspect(e));
      }(o);
    }
    if (l) {
      if (l !== i.kind) {
        var u = function extensionKindToTypeName(e) {
          switch (e) {
           case d.SCALAR_TYPE_EXTENSION:
            return "scalar";

           case d.OBJECT_TYPE_EXTENSION:
            return "object";

           case d.INTERFACE_TYPE_EXTENSION:
            return "interface";

           case d.UNION_TYPE_EXTENSION:
            return "union";

           case d.ENUM_TYPE_EXTENSION:
            return "enum";

           case d.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";

           default:
            invariant$1(!1, "Unexpected kind: " + inspect(e));
          }
        }(i.kind);
        e.reportError(new GraphQLError(`Cannot extend non-${u} type "${a}".`, {
          nodes: s ? [ s, i ] : i
        }));
      }
    } else {
      var c = suggestionList(a, Object.keys({
        ...r,
        ...null == n ? void 0 : n.getTypeMap()
      }));
      e.reportError(new GraphQLError(`Cannot extend type "${a}" because it is not defined.` + didYouMean(c), {
        nodes: i.name
      }));
    }
  }
}

var H = {
  [d.SCALAR_TYPE_DEFINITION]: d.SCALAR_TYPE_EXTENSION,
  [d.OBJECT_TYPE_DEFINITION]: d.OBJECT_TYPE_EXTENSION,
  [d.INTERFACE_TYPE_DEFINITION]: d.INTERFACE_TYPE_EXTENSION,
  [d.UNION_TYPE_DEFINITION]: d.UNION_TYPE_EXTENSION,
  [d.ENUM_TYPE_DEFINITION]: d.ENUM_TYPE_EXTENSION,
  [d.INPUT_OBJECT_TYPE_DEFINITION]: d.INPUT_OBJECT_TYPE_EXTENSION
};

function ProvidedRequiredArgumentsOnDirectivesRule(e) {
  var n;
  var r = Object.create(null);
  var i = e.getSchema();
  var a = null !== (n = null == i ? void 0 : i.getDirectives()) && void 0 !== n ? n : j;
  for (var s of a) {
    r[s.name] = keyMap(s.args.filter(isRequiredArgument), (e => e.name));
  }
  var o = e.getDocument().definitions;
  for (var l of o) {
    if (l.kind === d.DIRECTIVE_DEFINITION) {
      var u;
      var c = null !== (u = l.arguments) && void 0 !== u ? u : [];
      r[l.name.value] = keyMap(c.filter(isRequiredArgumentNode), (e => e.name.value));
    }
  }
  return {
    Directive: {
      leave(n) {
        var i = n.name.value;
        var a = r[i];
        if (a) {
          var s;
          var o = null !== (s = n.arguments) && void 0 !== s ? s : [];
          var l = new Set(o.map((e => e.name.value)));
          for (var [u, c] of Object.entries(a)) {
            if (!l.has(u)) {
              var d = isType(c.type) ? inspect(c.type) : print$1(c.type);
              e.reportError(new GraphQLError(`Directive "@${i}" argument "${u}" of type "${d}" is required, but it was not provided.`, {
                nodes: n
              }));
            }
          }
        }
      }
    }
  };
}

function isRequiredArgumentNode(e) {
  return e.type.kind === d.NON_NULL_TYPE && null == e.defaultValue;
}

function printPathArray(e) {
  return e.map((e => "number" == typeof e ? "[" + e.toString() + "]" : "." + e)).join("");
}

function addPath(e, n, r) {
  return {
    prev: e,
    key: n,
    typename: r
  };
}

function pathToArray(e) {
  var n = [];
  var r = e;
  while (r) {
    n.push(r.key);
    r = r.prev;
  }
  return n.reverse();
}

function coerceInputValue(e, n, r = defaultOnError) {
  return coerceInputValueImpl(e, n, r, void 0);
}

function defaultOnError(e, n, r) {
  var i = "Invalid value " + inspect(n);
  if (e.length > 0) {
    i += ` at "value${printPathArray(e)}"`;
  }
  r.message = i + ": " + r.message;
  throw r;
}

function coerceInputValueImpl(e, n, r, i) {
  if (isNonNullType(n)) {
    if (null != e) {
      return coerceInputValueImpl(e, n.ofType, r, i);
    }
    r(pathToArray(i), e, new GraphQLError(`Expected non-nullable type "${inspect(n)}" not to be null.`));
    return;
  }
  if (null == e) {
    return null;
  }
  if (isListType(n)) {
    var a = n.ofType;
    if (isIterableObject(e)) {
      return Array.from(e, ((e, n) => {
        var s = addPath(i, n, void 0);
        return coerceInputValueImpl(e, a, r, s);
      }));
    }
    return [ coerceInputValueImpl(e, a, r, i) ];
  }
  if (isInputObjectType(n)) {
    if (!isObjectLike(e)) {
      r(pathToArray(i), e, new GraphQLError(`Expected type "${n.name}" to be an object.`));
      return;
    }
    var s = {};
    var o = n.getFields();
    for (var l of Object.values(o)) {
      var u = e[l.name];
      if (void 0 === u) {
        if (void 0 !== l.defaultValue) {
          s[l.name] = l.defaultValue;
        } else if (isNonNullType(l.type)) {
          var c = inspect(l.type);
          r(pathToArray(i), e, new GraphQLError(`Field "${l.name}" of required type "${c}" was not provided.`));
        }
        continue;
      }
      s[l.name] = coerceInputValueImpl(u, l.type, r, addPath(i, l.name, n.name));
    }
    for (var d of Object.keys(e)) {
      if (!o[d]) {
        var f = suggestionList(d, Object.keys(n.getFields()));
        r(pathToArray(i), e, new GraphQLError(`Field "${d}" is not defined by type "${n.name}".` + didYouMean(f)));
      }
    }
    return s;
  }
  if (isLeafType(n)) {
    var v;
    try {
      v = n.parseValue(e);
    } catch (a) {
      if (a instanceof GraphQLError) {
        r(pathToArray(i), e, a);
      } else {
        r(pathToArray(i), e, new GraphQLError(`Expected type "${n.name}". ` + a.message, {
          originalError: a
        }));
      }
      return;
    }
    if (void 0 === v) {
      r(pathToArray(i), e, new GraphQLError(`Expected type "${n.name}".`));
    }
    return v;
  }
  invariant$1(!1, "Unexpected input type: " + inspect(n));
}

function valueFromAST(e, n, r) {
  if (!e) {
    return;
  }
  if (e.kind === d.VARIABLE) {
    var i = e.name.value;
    if (null == r || void 0 === r[i]) {
      return;
    }
    var a = r[i];
    if (null === a && isNonNullType(n)) {
      return;
    }
    return a;
  }
  if (isNonNullType(n)) {
    if (e.kind === d.NULL) {
      return;
    }
    return valueFromAST(e, n.ofType, r);
  }
  if (e.kind === d.NULL) {
    return null;
  }
  if (isListType(n)) {
    var s = n.ofType;
    if (e.kind === d.LIST) {
      var o = [];
      for (var l of e.values) {
        if (isMissingVariable(l, r)) {
          if (isNonNullType(s)) {
            return;
          }
          o.push(null);
        } else {
          var u = valueFromAST(l, s, r);
          if (void 0 === u) {
            return;
          }
          o.push(u);
        }
      }
      return o;
    }
    var c = valueFromAST(e, s, r);
    if (void 0 === c) {
      return;
    }
    return [ c ];
  }
  if (isInputObjectType(n)) {
    if (e.kind !== d.OBJECT) {
      return;
    }
    var f = Object.create(null);
    var v = keyMap(e.fields, (e => e.name.value));
    for (var h of Object.values(n.getFields())) {
      var m = v[h.name];
      if (!m || isMissingVariable(m.value, r)) {
        if (void 0 !== h.defaultValue) {
          f[h.name] = h.defaultValue;
        } else if (isNonNullType(h.type)) {
          return;
        }
        continue;
      }
      var g = valueFromAST(m.value, h.type, r);
      if (void 0 === g) {
        return;
      }
      f[h.name] = g;
    }
    return f;
  }
  if (isLeafType(n)) {
    var y;
    try {
      y = n.parseLiteral(e, r);
    } catch (e) {
      return;
    }
    if (void 0 === y) {
      return;
    }
    return y;
  }
  invariant$1(!1, "Unexpected input type: " + inspect(n));
}

function isMissingVariable(e, n) {
  return e.kind === d.VARIABLE && (null == n || void 0 === n[e.name.value]);
}

function getVariableValues(e, n, r, i) {
  var a = [];
  var s = null == i ? void 0 : i.maxErrors;
  try {
    var o = function coerceVariableValues(e, n, r, i) {
      var a = {};
      var _loop = function(n) {
        var s = n.variable.name.value;
        var o = typeFromAST(e, n.type);
        if (!isInputType(o)) {
          var l = print$1(n.type);
          i(new GraphQLError(`Variable "$${s}" expected value of type "${l}" which cannot be used as an input type.`, {
            nodes: n.type
          }));
          return 0;
        }
        if (!hasOwnProperty(r, s)) {
          if (n.defaultValue) {
            a[s] = valueFromAST(n.defaultValue, o);
          } else if (isNonNullType(o)) {
            var u = inspect(o);
            i(new GraphQLError(`Variable "$${s}" of required type "${u}" was not provided.`, {
              nodes: n
            }));
          }
          return 0;
        }
        var c = r[s];
        if (null === c && isNonNullType(o)) {
          var d = inspect(o);
          i(new GraphQLError(`Variable "$${s}" of non-null type "${d}" must not be null.`, {
            nodes: n
          }));
          return 0;
        }
        a[s] = coerceInputValue(c, o, ((e, r, a) => {
          var o = `Variable "$${s}" got invalid value ` + inspect(r);
          if (e.length > 0) {
            o += ` at "${s}${printPathArray(e)}"`;
          }
          i(new GraphQLError(o + "; " + a.message, {
            nodes: n,
            originalError: a
          }));
        }));
      };
      for (var s of n) {
        if (0 === _loop(s)) {
          continue;
        }
      }
      return a;
    }(e, n, r, (e => {
      if (null != s && a.length >= s) {
        throw new GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      a.push(e);
    }));
    if (0 === a.length) {
      return {
        coerced: o
      };
    }
  } catch (e) {
    a.push(e);
  }
  return {
    errors: a
  };
}

function getArgumentValues(e, n, r) {
  var i;
  var a = {};
  var s = keyMap(null !== (i = n.arguments) && void 0 !== i ? i : [], (e => e.name.value));
  for (var o of e.args) {
    var l = o.name;
    var u = o.type;
    var c = s[l];
    if (!c) {
      if (void 0 !== o.defaultValue) {
        a[l] = o.defaultValue;
      } else if (isNonNullType(u)) {
        throw new GraphQLError(`Argument "${l}" of required type "${inspect(u)}" was not provided.`, {
          nodes: n
        });
      }
      continue;
    }
    var f = c.value;
    var v = f.kind === d.NULL;
    if (f.kind === d.VARIABLE) {
      var h = f.name.value;
      if (null == r || !hasOwnProperty(r, h)) {
        if (void 0 !== o.defaultValue) {
          a[l] = o.defaultValue;
        } else if (isNonNullType(u)) {
          throw new GraphQLError(`Argument "${l}" of required type "${inspect(u)}" was provided the variable "$${h}" which was not provided a runtime value.`, {
            nodes: f
          });
        }
        continue;
      }
      v = null == r[h];
    }
    if (v && isNonNullType(u)) {
      throw new GraphQLError(`Argument "${l}" of non-null type "${inspect(u)}" must not be null.`, {
        nodes: f
      });
    }
    var m = valueFromAST(f, u, r);
    if (void 0 === m) {
      throw new GraphQLError(`Argument "${l}" has invalid value ${print$1(f)}.`, {
        nodes: f
      });
    }
    a[l] = m;
  }
  return a;
}

function getDirectiveValues(e, n, r) {
  var i;
  var a = null === (i = n.directives) || void 0 === i ? void 0 : i.find((n => n.name.value === e.name));
  if (a) {
    return getArgumentValues(e, a, r);
  }
}

function hasOwnProperty(e, n) {
  return Object.prototype.hasOwnProperty.call(e, n);
}

function collectFields(e, n, r, i, a) {
  var s = new Map;
  collectFieldsImpl(e, n, r, i, a, s, new Set);
  return s;
}

function collectFieldsImpl(e, n, r, i, a, s, o) {
  for (var l of a.selections) {
    switch (l.kind) {
     case d.FIELD:
      if (!shouldIncludeNode(r, l)) {
        continue;
      }
      var u = (h = l).alias ? h.alias.value : h.name.value;
      var c = s.get(u);
      if (void 0 !== c) {
        c.push(l);
      } else {
        s.set(u, [ l ]);
      }
      break;

     case d.INLINE_FRAGMENT:
      if (!shouldIncludeNode(r, l) || !doesFragmentConditionMatch(e, l, i)) {
        continue;
      }
      collectFieldsImpl(e, n, r, i, l.selectionSet, s, o);
      break;

     case d.FRAGMENT_SPREAD:
      var f = l.name.value;
      if (o.has(f) || !shouldIncludeNode(r, l)) {
        continue;
      }
      o.add(f);
      var v = n[f];
      if (!v || !doesFragmentConditionMatch(e, v, i)) {
        continue;
      }
      collectFieldsImpl(e, n, r, i, v.selectionSet, s, o);
    }
  }
  var h;
}

function shouldIncludeNode(e, n) {
  var r = getDirectiveValues(k, n, e);
  if (!0 === (null == r ? void 0 : r.if)) {
    return !1;
  }
  var i = getDirectiveValues(w, n, e);
  if (!1 === (null == i ? void 0 : i.if)) {
    return !1;
  }
  return !0;
}

function doesFragmentConditionMatch(e, n, r) {
  var i = n.typeCondition;
  if (!i) {
    return !0;
  }
  var a = typeFromAST(e, i);
  if (a === r) {
    return !0;
  }
  if (isAbstractType(a)) {
    return e.isSubType(a, r);
  }
  return !1;
}

function groupBy(e, n) {
  var r = new Map;
  for (var i of e) {
    var a = n(i);
    var s = r.get(a);
    if (void 0 === s) {
      r.set(a, [ i ]);
    } else {
      s.push(i);
    }
  }
  return r;
}

function UniqueArgumentNamesRule(e) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(n) {
    var r;
    var i = groupBy(null !== (r = n.arguments) && void 0 !== r ? r : [], (e => e.name.value));
    for (var [a, s] of i) {
      if (s.length > 1) {
        e.reportError(new GraphQLError(`There can be only one argument named "${a}".`, {
          nodes: s.map((e => e.name))
        }));
      }
    }
  }
}

function UniqueDirectiveNamesRule(e) {
  var n = Object.create(null);
  var r = e.getSchema();
  return {
    DirectiveDefinition(i) {
      var a = i.name.value;
      if (null != r && r.getDirective(a)) {
        e.reportError(new GraphQLError(`Directive "@${a}" already exists in the schema. It cannot be redefined.`, {
          nodes: i.name
        }));
        return;
      }
      if (n[a]) {
        e.reportError(new GraphQLError(`There can be only one directive named "@${a}".`, {
          nodes: [ n[a], i.name ]
        }));
      } else {
        n[a] = i.name;
      }
      return !1;
    }
  };
}

function UniqueDirectivesPerLocationRule(e) {
  var n = Object.create(null);
  var r = e.getSchema();
  var i = r ? r.getDirectives() : j;
  for (var a of i) {
    n[a.name] = !a.isRepeatable;
  }
  var s = e.getDocument().definitions;
  for (var o of s) {
    if (o.kind === d.DIRECTIVE_DEFINITION) {
      n[o.name.value] = !o.repeatable;
    }
  }
  var l = Object.create(null);
  var u = Object.create(null);
  return {
    enter(r) {
      if (!("directives" in r) || !r.directives) {
        return;
      }
      var i;
      if (r.kind === d.SCHEMA_DEFINITION || r.kind === d.SCHEMA_EXTENSION) {
        i = l;
      } else if (isTypeDefinitionNode(r) || isTypeExtensionNode(r)) {
        var a = r.name.value;
        if (void 0 === (i = u[a])) {
          u[a] = i = Object.create(null);
        }
      } else {
        i = Object.create(null);
      }
      for (var s of r.directives) {
        var o = s.name.value;
        if (n[o]) {
          if (i[o]) {
            e.reportError(new GraphQLError(`The directive "@${o}" can only be used once at this location.`, {
              nodes: [ i[o], s ]
            }));
          } else {
            i[o] = s;
          }
        }
      }
    }
  };
}

function UniqueEnumValueNamesRule(e) {
  var n = e.getSchema();
  var r = n ? n.getTypeMap() : Object.create(null);
  var i = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(n) {
    var a;
    var s = n.name.value;
    if (!i[s]) {
      i[s] = Object.create(null);
    }
    var o = null !== (a = n.values) && void 0 !== a ? a : [];
    var l = i[s];
    for (var u of o) {
      var c = u.name.value;
      var d = r[s];
      if (isEnumType(d) && d.getValue(c)) {
        e.reportError(new GraphQLError(`Enum value "${s}.${c}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: u.name
        }));
      } else if (l[c]) {
        e.reportError(new GraphQLError(`Enum value "${s}.${c}" can only be defined once.`, {
          nodes: [ l[c], u.name ]
        }));
      } else {
        l[c] = u.name;
      }
    }
    return !1;
  }
}

function UniqueFieldDefinitionNamesRule(e) {
  var n = e.getSchema();
  var r = n ? n.getTypeMap() : Object.create(null);
  var i = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(n) {
    var a;
    var s = n.name.value;
    if (!i[s]) {
      i[s] = Object.create(null);
    }
    var o = null !== (a = n.fields) && void 0 !== a ? a : [];
    var l = i[s];
    for (var u of o) {
      var c = u.name.value;
      if (hasField(r[s], c)) {
        e.reportError(new GraphQLError(`Field "${s}.${c}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: u.name
        }));
      } else if (l[c]) {
        e.reportError(new GraphQLError(`Field "${s}.${c}" can only be defined once.`, {
          nodes: [ l[c], u.name ]
        }));
      } else {
        l[c] = u.name;
      }
    }
    return !1;
  }
}

function hasField(e, n) {
  if (isObjectType(e) || isInterfaceType(e) || isInputObjectType(e)) {
    return null != e.getFields()[n];
  }
  return !1;
}

function UniqueInputFieldNamesRule(e) {
  var n = [];
  var r = Object.create(null);
  return {
    ObjectValue: {
      enter() {
        n.push(r);
        r = Object.create(null);
      },
      leave() {
        var e = n.pop();
        e || invariant$1(!1);
        r = e;
      }
    },
    ObjectField(n) {
      var i = n.name.value;
      if (r[i]) {
        e.reportError(new GraphQLError(`There can be only one input field named "${i}".`, {
          nodes: [ r[i], n.name ]
        }));
      } else {
        r[i] = n.name;
      }
    }
  };
}

function UniqueOperationTypesRule(e) {
  var n = e.getSchema();
  var r = Object.create(null);
  var i = n ? {
    query: n.getQueryType(),
    mutation: n.getMutationType(),
    subscription: n.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(n) {
    var a;
    var s = null !== (a = n.operationTypes) && void 0 !== a ? a : [];
    for (var o of s) {
      var l = o.operation;
      var u = r[l];
      if (i[l]) {
        e.reportError(new GraphQLError(`Type for ${l} already defined in the schema. It cannot be redefined.`, {
          nodes: o
        }));
      } else if (u) {
        e.reportError(new GraphQLError(`There can be only one ${l} type in schema.`, {
          nodes: [ u, o ]
        }));
      } else {
        r[l] = o;
      }
    }
    return !1;
  }
}

function UniqueTypeNamesRule(e) {
  var n = Object.create(null);
  var r = e.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(i) {
    var a = i.name.value;
    if (null != r && r.getType(a)) {
      e.reportError(new GraphQLError(`Type "${a}" already exists in the schema. It cannot also be defined in this type definition.`, {
        nodes: i.name
      }));
      return;
    }
    if (n[a]) {
      e.reportError(new GraphQLError(`There can be only one type named "${a}".`, {
        nodes: [ n[a], i.name ]
      }));
    } else {
      n[a] = i.name;
    }
    return !1;
  }
}

function isValidValueNode(e, n) {
  var r = e.getInputType();
  if (!r) {
    return;
  }
  var i = getNamedType(r);
  if (!isLeafType(i)) {
    var a = inspect(r);
    e.reportError(new GraphQLError(`Expected value of type "${a}", found ${print$1(n)}.`, {
      nodes: n
    }));
    return;
  }
  try {
    if (void 0 === i.parseLiteral(n, void 0)) {
      var s = inspect(r);
      e.reportError(new GraphQLError(`Expected value of type "${s}", found ${print$1(n)}.`, {
        nodes: n
      }));
    }
  } catch (i) {
    var o = inspect(r);
    if (i instanceof GraphQLError) {
      e.reportError(i);
    } else {
      e.reportError(new GraphQLError(`Expected value of type "${o}", found ${print$1(n)}; ` + i.message, {
        nodes: n,
        originalError: i
      }));
    }
  }
}

function allowedVariableUsage(e, n, r, i, a) {
  if (isNonNullType(i) && !isNonNullType(n)) {
    if (!(null != r && r.kind !== d.NULL) && !(void 0 !== a)) {
      return !1;
    }
    return isTypeSubTypeOf(e, n, i.ofType);
  }
  return isTypeSubTypeOf(e, n, i);
}

var Z = Object.freeze([ ExecutableDefinitionsRule, function UniqueOperationNamesRule(e) {
  var n = Object.create(null);
  return {
    OperationDefinition(r) {
      var i = r.name;
      if (i) {
        if (n[i.value]) {
          e.reportError(new GraphQLError(`There can be only one operation named "${i.value}".`, {
            nodes: [ n[i.value], i ]
          }));
        } else {
          n[i.value] = i;
        }
      }
      return !1;
    },
    FragmentDefinition: () => !1
  };
}, function LoneAnonymousOperationRule(e) {
  var n = 0;
  return {
    Document(e) {
      n = e.definitions.filter((e => e.kind === d.OPERATION_DEFINITION)).length;
    },
    OperationDefinition(r) {
      if (!r.name && n > 1) {
        e.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", {
          nodes: r
        }));
      }
    }
  };
}, function SingleFieldSubscriptionsRule(e) {
  return {
    OperationDefinition(n) {
      if ("subscription" === n.operation) {
        var r = e.getSchema();
        var i = r.getSubscriptionType();
        if (i) {
          var a = n.name ? n.name.value : null;
          var s = Object.create(null);
          var o = e.getDocument();
          var l = Object.create(null);
          for (var u of o.definitions) {
            if (u.kind === d.FRAGMENT_DEFINITION) {
              l[u.name.value] = u;
            }
          }
          var c = collectFields(r, l, s, i, n.selectionSet);
          if (c.size > 1) {
            var f = [ ...c.values() ].slice(1).flat();
            e.reportError(new GraphQLError(null != a ? `Subscription "${a}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
              nodes: f
            }));
          }
          for (var v of c.values()) {
            if (v[0].name.value.startsWith("__")) {
              e.reportError(new GraphQLError(null != a ? `Subscription "${a}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                nodes: v
              }));
            }
          }
        }
      }
    }
  };
}, KnownTypeNamesRule, function FragmentsOnCompositeTypesRule(e) {
  return {
    InlineFragment(n) {
      var r = n.typeCondition;
      if (r) {
        var i = typeFromAST(e.getSchema(), r);
        if (i && !isCompositeType(i)) {
          var a = print$1(r);
          e.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${a}".`, {
            nodes: r
          }));
        }
      }
    },
    FragmentDefinition(n) {
      var r = typeFromAST(e.getSchema(), n.typeCondition);
      if (r && !isCompositeType(r)) {
        var i = print$1(n.typeCondition);
        e.reportError(new GraphQLError(`Fragment "${n.name.value}" cannot condition on non composite type "${i}".`, {
          nodes: n.typeCondition
        }));
      }
    }
  };
}, function VariablesAreInputTypesRule(e) {
  return {
    VariableDefinition(n) {
      var r = typeFromAST(e.getSchema(), n.type);
      if (void 0 !== r && !isInputType(r)) {
        var i = n.variable.name.value;
        var a = print$1(n.type);
        e.reportError(new GraphQLError(`Variable "$${i}" cannot be non-input type "${a}".`, {
          nodes: n.type
        }));
      }
    }
  };
}, function ScalarLeafsRule(e) {
  return {
    Field(n) {
      var r = e.getType();
      var i = n.selectionSet;
      if (r) {
        if (isLeafType(getNamedType(r))) {
          if (i) {
            var a = n.name.value;
            var s = inspect(r);
            e.reportError(new GraphQLError(`Field "${a}" must not have a selection since type "${s}" has no subfields.`, {
              nodes: i
            }));
          }
        } else if (!i) {
          var o = n.name.value;
          var l = inspect(r);
          e.reportError(new GraphQLError(`Field "${o}" of type "${l}" must have a selection of subfields. Did you mean "${o} { ... }"?`, {
            nodes: n
          }));
        }
      }
    }
  };
}, function FieldsOnCorrectTypeRule(e) {
  return {
    Field(n) {
      var r = e.getParentType();
      if (r) {
        if (!e.getFieldDef()) {
          var i = e.getSchema();
          var a = n.name.value;
          var s = didYouMean("to use an inline fragment on", function getSuggestedTypeNames(e, n, r) {
            if (!isAbstractType(n)) {
              return [];
            }
            var i = new Set;
            var a = Object.create(null);
            for (var s of e.getPossibleTypes(n)) {
              if (!s.getFields()[r]) {
                continue;
              }
              i.add(s);
              a[s.name] = 1;
              for (var o of s.getInterfaces()) {
                var l;
                if (!o.getFields()[r]) {
                  continue;
                }
                i.add(o);
                a[o.name] = (null !== (l = a[o.name]) && void 0 !== l ? l : 0) + 1;
              }
            }
            return [ ...i ].sort(((n, r) => {
              var i = a[r.name] - a[n.name];
              if (0 !== i) {
                return i;
              }
              if (isInterfaceType(n) && e.isSubType(n, r)) {
                return -1;
              }
              if (isInterfaceType(r) && e.isSubType(r, n)) {
                return 1;
              }
              return naturalCompare(n.name, r.name);
            })).map((e => e.name));
          }(i, r, a));
          if ("" === s) {
            s = didYouMean(function getSuggestedFieldNames(e, n) {
              if (isObjectType(e) || isInterfaceType(e)) {
                return suggestionList(n, Object.keys(e.getFields()));
              }
              return [];
            }(r, a));
          }
          e.reportError(new GraphQLError(`Cannot query field "${a}" on type "${r.name}".` + s, {
            nodes: n
          }));
        }
      }
    }
  };
}, function UniqueFragmentNamesRule(e) {
  var n = Object.create(null);
  return {
    OperationDefinition: () => !1,
    FragmentDefinition(r) {
      var i = r.name.value;
      if (n[i]) {
        e.reportError(new GraphQLError(`There can be only one fragment named "${i}".`, {
          nodes: [ n[i], r.name ]
        }));
      } else {
        n[i] = r.name;
      }
      return !1;
    }
  };
}, KnownFragmentNamesRule, NoUnusedFragmentsRule, function PossibleFragmentSpreadsRule(e) {
  return {
    InlineFragment(n) {
      var r = e.getType();
      var i = e.getParentType();
      if (isCompositeType(r) && isCompositeType(i) && !doTypesOverlap(e.getSchema(), r, i)) {
        var a = inspect(i);
        var s = inspect(r);
        e.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${a}" can never be of type "${s}".`, {
          nodes: n
        }));
      }
    },
    FragmentSpread(n) {
      var r = n.name.value;
      var i = function getFragmentType(e, n) {
        var r = e.getFragment(n);
        if (r) {
          var i = typeFromAST(e.getSchema(), r.typeCondition);
          if (isCompositeType(i)) {
            return i;
          }
        }
      }(e, r);
      var a = e.getParentType();
      if (i && a && !doTypesOverlap(e.getSchema(), i, a)) {
        var s = inspect(a);
        var o = inspect(i);
        e.reportError(new GraphQLError(`Fragment "${r}" cannot be spread here as objects of type "${s}" can never be of type "${o}".`, {
          nodes: n
        }));
      }
    }
  };
}, function NoFragmentCyclesRule(e) {
  var n = Object.create(null);
  var r = [];
  var i = Object.create(null);
  return {
    OperationDefinition: () => !1,
    FragmentDefinition(e) {
      detectCycleRecursive(e);
      return !1;
    }
  };
  function detectCycleRecursive(a) {
    if (n[a.name.value]) {
      return;
    }
    var s = a.name.value;
    n[s] = !0;
    var o = e.getFragmentSpreads(a.selectionSet);
    if (0 === o.length) {
      return;
    }
    i[s] = r.length;
    for (var l of o) {
      var u = l.name.value;
      var c = i[u];
      r.push(l);
      if (void 0 === c) {
        var d = e.getFragment(u);
        if (d) {
          detectCycleRecursive(d);
        }
      } else {
        var f = r.slice(c);
        var v = f.slice(0, -1).map((e => '"' + e.name.value + '"')).join(", ");
        e.reportError(new GraphQLError(`Cannot spread fragment "${u}" within itself` + ("" !== v ? ` via ${v}.` : "."), {
          nodes: f
        }));
      }
      r.pop();
    }
    i[s] = void 0;
  }
}, function UniqueVariableNamesRule(e) {
  return {
    OperationDefinition(n) {
      var r;
      var i = groupBy(null !== (r = n.variableDefinitions) && void 0 !== r ? r : [], (e => e.variable.name.value));
      for (var [a, s] of i) {
        if (s.length > 1) {
          e.reportError(new GraphQLError(`There can be only one variable named "$${a}".`, {
            nodes: s.map((e => e.variable.name))
          }));
        }
      }
    }
  };
}, function NoUndefinedVariablesRule(e) {
  var n = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        n = Object.create(null);
      },
      leave(r) {
        var i = e.getRecursiveVariableUsages(r);
        for (var {node: a} of i) {
          var s = a.name.value;
          if (!0 !== n[s]) {
            e.reportError(new GraphQLError(r.name ? `Variable "$${s}" is not defined by operation "${r.name.value}".` : `Variable "$${s}" is not defined.`, {
              nodes: [ a, r ]
            }));
          }
        }
      }
    },
    VariableDefinition(e) {
      n[e.variable.name.value] = !0;
    }
  };
}, function NoUnusedVariablesRule(e) {
  var n = [];
  return {
    OperationDefinition: {
      enter() {
        n = [];
      },
      leave(r) {
        var i = Object.create(null);
        var a = e.getRecursiveVariableUsages(r);
        for (var {node: s} of a) {
          i[s.name.value] = !0;
        }
        for (var o of n) {
          var l = o.variable.name.value;
          if (!0 !== i[l]) {
            e.reportError(new GraphQLError(r.name ? `Variable "$${l}" is never used in operation "${r.name.value}".` : `Variable "$${l}" is never used.`, {
              nodes: o
            }));
          }
        }
      }
    },
    VariableDefinition(e) {
      n.push(e);
    }
  };
}, KnownDirectivesRule, UniqueDirectivesPerLocationRule, function KnownArgumentNamesRule(e) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(e),
    Argument(n) {
      var r = e.getArgument();
      var i = e.getFieldDef();
      var a = e.getParentType();
      if (!r && i && a) {
        var s = n.name.value;
        var o = suggestionList(s, i.args.map((e => e.name)));
        e.reportError(new GraphQLError(`Unknown argument "${s}" on field "${a.name}.${i.name}".` + didYouMean(o), {
          nodes: n
        }));
      }
    }
  };
}, UniqueArgumentNamesRule, function ValuesOfCorrectTypeRule(e) {
  return {
    ListValue(n) {
      if (!isListType(getNullableType(e.getParentInputType()))) {
        isValidValueNode(e, n);
        return !1;
      }
    },
    ObjectValue(n) {
      var r = getNamedType(e.getInputType());
      if (!isInputObjectType(r)) {
        isValidValueNode(e, n);
        return !1;
      }
      var i = keyMap(n.fields, (e => e.name.value));
      for (var a of Object.values(r.getFields())) {
        if (!i[a.name] && isRequiredInputField(a)) {
          var s = inspect(a.type);
          e.reportError(new GraphQLError(`Field "${r.name}.${a.name}" of required type "${s}" was not provided.`, {
            nodes: n
          }));
        }
      }
    },
    ObjectField(n) {
      var r = getNamedType(e.getParentInputType());
      if (!e.getInputType() && isInputObjectType(r)) {
        var i = suggestionList(n.name.value, Object.keys(r.getFields()));
        e.reportError(new GraphQLError(`Field "${n.name.value}" is not defined by type "${r.name}".` + didYouMean(i), {
          nodes: n
        }));
      }
    },
    NullValue(n) {
      var r = e.getInputType();
      if (isNonNullType(r)) {
        e.reportError(new GraphQLError(`Expected value of type "${inspect(r)}", found ${print$1(n)}.`, {
          nodes: n
        }));
      }
    },
    EnumValue: n => isValidValueNode(e, n),
    IntValue: n => isValidValueNode(e, n),
    FloatValue: n => isValidValueNode(e, n),
    StringValue: n => isValidValueNode(e, n),
    BooleanValue: n => isValidValueNode(e, n)
  };
}, function ProvidedRequiredArgumentsRule(e) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(e),
    Field: {
      leave(n) {
        var r;
        var i = e.getFieldDef();
        if (!i) {
          return !1;
        }
        var a = new Set(null === (r = n.arguments) || void 0 === r ? void 0 : r.map((e => e.name.value)));
        for (var s of i.args) {
          if (!a.has(s.name) && isRequiredArgument(s)) {
            var o = inspect(s.type);
            e.reportError(new GraphQLError(`Field "${i.name}" argument "${s.name}" of type "${o}" is required, but it was not provided.`, {
              nodes: n
            }));
          }
        }
      }
    }
  };
}, function VariablesInAllowedPositionRule(e) {
  var n = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        n = Object.create(null);
      },
      leave(r) {
        var i = e.getRecursiveVariableUsages(r);
        for (var {node: a, type: s, defaultValue: o} of i) {
          var l = a.name.value;
          var u = n[l];
          if (u && s) {
            var c = e.getSchema();
            var d = typeFromAST(c, u.type);
            if (d && !allowedVariableUsage(c, d, u.defaultValue, s, o)) {
              var f = inspect(d);
              var v = inspect(s);
              e.reportError(new GraphQLError(`Variable "$${l}" of type "${f}" used in position expecting type "${v}".`, {
                nodes: [ u, a ]
              }));
            }
          }
        }
      }
    },
    VariableDefinition(e) {
      n[e.variable.name.value] = e;
    }
  };
}, function OverlappingFieldsCanBeMergedRule(e) {
  var n = new PairSet;
  var r = new Map;
  return {
    SelectionSet(i) {
      var a = function findConflictsWithinSelectionSet(e, n, r, i, a) {
        var s = [];
        var [o, l] = getFieldsAndFragmentNames(e, n, i, a);
        !function collectConflictsWithin(e, n, r, i, a) {
          for (var [s, o] of Object.entries(a)) {
            if (o.length > 1) {
              for (var l = 0; l < o.length; l++) {
                for (var u = l + 1; u < o.length; u++) {
                  var c = findConflict(e, r, i, !1, s, o[l], o[u]);
                  if (c) {
                    n.push(c);
                  }
                }
              }
            }
          }
        }(e, s, n, r, o);
        if (0 !== l.length) {
          for (var u = 0; u < l.length; u++) {
            collectConflictsBetweenFieldsAndFragment(e, s, n, r, !1, o, l[u]);
            for (var c = u + 1; c < l.length; c++) {
              collectConflictsBetweenFragments(e, s, n, r, !1, l[u], l[c]);
            }
          }
        }
        return s;
      }(e, r, n, e.getParentType(), i);
      for (var [[s, o], l, u] of a) {
        var c = reasonMessage(o);
        e.reportError(new GraphQLError(`Fields "${s}" conflict because ${c}. Use different aliases on the fields to fetch both if this was intentional.`, {
          nodes: l.concat(u)
        }));
      }
    }
  };
}, UniqueInputFieldNamesRule ]);

var ee = Object.freeze([ LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, function UniqueArgumentDefinitionNamesRule(e) {
  return {
    DirectiveDefinition(e) {
      var n;
      var r = null !== (n = e.arguments) && void 0 !== n ? n : [];
      return checkArgUniqueness(`@${e.name.value}`, r);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(e) {
    var n;
    var r = e.name.value;
    var i = null !== (n = e.fields) && void 0 !== n ? n : [];
    for (var a of i) {
      var s;
      checkArgUniqueness(`${r}.${a.name.value}`, null !== (s = a.arguments) && void 0 !== s ? s : []);
    }
    return !1;
  }
  function checkArgUniqueness(n, r) {
    var i = groupBy(r, (e => e.name.value));
    for (var [a, s] of i) {
      if (s.length > 1) {
        e.reportError(new GraphQLError(`Argument "${n}(${a}:)" can only be defined once.`, {
          nodes: s.map((e => e.name))
        }));
      }
    }
    return !1;
  }
}, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule ]);

class ASTValidationContext {
  constructor(e, n) {
    this._ast = e;
    this._fragments = void 0;
    this._fragmentSpreads = new Map;
    this._recursivelyReferencedFragments = new Map;
    this._onError = n;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(e) {
    this._onError(e);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(e) {
    var n;
    if (this._fragments) {
      n = this._fragments;
    } else {
      n = Object.create(null);
      for (var r of this.getDocument().definitions) {
        if (r.kind === d.FRAGMENT_DEFINITION) {
          n[r.name.value] = r;
        }
      }
      this._fragments = n;
    }
    return n[e];
  }
  getFragmentSpreads(e) {
    var n = this._fragmentSpreads.get(e);
    if (!n) {
      n = [];
      var r = [ e ];
      var i;
      while (i = r.pop()) {
        for (var a of i.selections) {
          if (a.kind === d.FRAGMENT_SPREAD) {
            n.push(a);
          } else if (a.selectionSet) {
            r.push(a.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(e, n);
    }
    return n;
  }
  getRecursivelyReferencedFragments(e) {
    var n = this._recursivelyReferencedFragments.get(e);
    if (!n) {
      n = [];
      var r = Object.create(null);
      var i = [ e.selectionSet ];
      var a;
      while (a = i.pop()) {
        for (var s of this.getFragmentSpreads(a)) {
          var o = s.name.value;
          if (!0 !== r[o]) {
            r[o] = !0;
            var l = this.getFragment(o);
            if (l) {
              n.push(l);
              i.push(l.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(e, n);
    }
    return n;
  }
}

class SDLValidationContext extends ASTValidationContext {
  constructor(e, n, r) {
    super(e, r);
    this._schema = n;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}

class ValidationContext extends ASTValidationContext {
  constructor(e, n, r, i) {
    super(n, i);
    this._schema = e;
    this._typeInfo = r;
    this._variableUsages = new Map;
    this._recursiveVariableUsages = new Map;
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(e) {
    var n = this._variableUsages.get(e);
    if (!n) {
      var r = [];
      var i = new TypeInfo(this._schema);
      visit(e, visitWithTypeInfo(i, {
        VariableDefinition: () => !1,
        Variable(e) {
          r.push({
            node: e,
            type: i.getInputType(),
            defaultValue: i.getDefaultValue()
          });
        }
      }));
      this._variableUsages.set(e, n = r);
    }
    return n;
  }
  getRecursiveVariableUsages(e) {
    var n = this._recursiveVariableUsages.get(e);
    if (!n) {
      n = this.getVariableUsages(e);
      for (var r of this.getRecursivelyReferencedFragments(e)) {
        n = n.concat(this.getVariableUsages(r));
      }
      this._recursiveVariableUsages.set(e, n);
    }
    return n;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}

function validate(e, n, r = Z, i, a = new TypeInfo(e)) {
  var s;
  var o = null !== (s = null == i ? void 0 : i.maxErrors) && void 0 !== s ? s : 100;
  n || devAssert(!1, "Must provide document.");
  assertValidSchema(e);
  var l = Object.freeze({});
  var u = [];
  var c = new ValidationContext(e, n, a, (e => {
    if (u.length >= o) {
      u.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw l;
    }
    u.push(e);
  }));
  var d = visitInParallel(r.map((e => e(c))));
  try {
    visit(n, visitWithTypeInfo(a, d));
  } catch (e) {
    if (e !== l) {
      throw e;
    }
  }
  return u;
}

function assertValidSDL(e) {
  var n = function validateSDL(e, n, r = ee) {
    var i = [];
    var a = new SDLValidationContext(e, n, (e => {
      i.push(e);
    }));
    visit(e, visitInParallel(r.map((e => e(a)))));
    return i;
  }(e);
  if (0 !== n.length) {
    throw new Error(n.map((e => e.message)).join("\n\n"));
  }
}

function promiseForObject(e) {
  return Promise.all(Object.values(e)).then((n => {
    var r = Object.create(null);
    for (var [i, a] of Object.keys(e).entries()) {
      r[a] = n[i];
    }
    return r;
  }));
}

class NonErrorThrown extends Error {
  constructor(e) {
    super("Unexpected error value: " + inspect(e));
    this.name = "NonErrorThrown";
    this.thrownValue = e;
  }
}

function locatedError(e, n, r) {
  var i;
  var a = function toError(e) {
    return e instanceof Error ? e : new NonErrorThrown(e);
  }(e);
  if (function isLocatedGraphQLError(e) {
    return Array.isArray(e.path);
  }(a)) {
    return a;
  }
  return new GraphQLError(a.message, {
    nodes: null !== (i = a.nodes) && void 0 !== i ? i : n,
    source: a.source,
    positions: a.positions,
    path: r,
    originalError: a
  });
}

var te = function memoize3(e) {
  var n;
  return function memoized(r, i, a) {
    if (void 0 === n) {
      n = new WeakMap;
    }
    var s = n.get(r);
    if (void 0 === s) {
      s = new WeakMap;
      n.set(r, s);
    }
    var o = s.get(i);
    if (void 0 === o) {
      o = new WeakMap;
      s.set(i, o);
    }
    var l = o.get(a);
    if (void 0 === l) {
      l = e(r, i, a);
      o.set(a, l);
    }
    return l;
  };
}(((e, n, r) => function collectSubfields$1(e, n, r, i, a) {
  var s = new Map;
  var o = new Set;
  for (var l of a) {
    if (l.selectionSet) {
      collectFieldsImpl(e, n, r, i, l.selectionSet, s, o);
    }
  }
  return s;
}(e.schema, e.fragments, e.variableValues, n, r)));

function execute(e) {
  arguments.length < 2 || devAssert(!1, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
  var {schema: n, document: r, variableValues: i, rootValue: a} = e;
  !function assertValidExecutionArguments(e, n, r) {
    n || devAssert(!1, "Must provide document.");
    assertValidSchema(e);
    null == r || isObjectLike(r) || devAssert(!1, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
  }(n, r, i);
  var s = function buildExecutionContext(e) {
    var n, r;
    var {schema: i, document: a, rootValue: s, contextValue: o, variableValues: l, operationName: u, fieldResolver: c, typeResolver: f, subscribeFieldResolver: v} = e;
    var h;
    var m = Object.create(null);
    for (var g of a.definitions) {
      switch (g.kind) {
       case d.OPERATION_DEFINITION:
        if (null == u) {
          if (void 0 !== h) {
            return [ new GraphQLError("Must provide operation name if query contains multiple operations.") ];
          }
          h = g;
        } else if ((null === (n = g.name) || void 0 === n ? void 0 : n.value) === u) {
          h = g;
        }
        break;

       case d.FRAGMENT_DEFINITION:
        m[g.name.value] = g;
      }
    }
    if (!h) {
      if (null != u) {
        return [ new GraphQLError(`Unknown operation named "${u}".`) ];
      }
      return [ new GraphQLError("Must provide an operation.") ];
    }
    var y = null !== (r = h.variableDefinitions) && void 0 !== r ? r : [];
    var T = getVariableValues(i, y, null != l ? l : {}, {
      maxErrors: 50
    });
    if (T.errors) {
      return T.errors;
    }
    return {
      schema: i,
      fragments: m,
      rootValue: s,
      contextValue: o,
      operation: h,
      variableValues: T.coerced,
      fieldResolver: null != c ? c : defaultFieldResolver,
      typeResolver: null != f ? f : defaultTypeResolver,
      subscribeFieldResolver: null != v ? v : defaultFieldResolver,
      errors: []
    };
  }(e);
  if (!("schema" in s)) {
    return {
      errors: s
    };
  }
  try {
    var {operation: o} = s;
    var l = function executeOperation(e, n, r) {
      var i = e.schema.getRootType(n.operation);
      if (null == i) {
        throw new GraphQLError(`Schema is not configured to execute ${n.operation} operation.`, {
          nodes: n
        });
      }
      var a = collectFields(e.schema, e.fragments, e.variableValues, i, n.selectionSet);
      var s = void 0;
      switch (n.operation) {
       case u.QUERY:
        return executeFields(e, i, r, s, a);

       case u.MUTATION:
        return function executeFieldsSerially(e, n, r, i, a) {
          return function promiseReduce(e, n, r) {
            var i = r;
            var _loop = function(e) {
              i = isPromise(i) ? i.then((r => n(r, e))) : n(i, e);
            };
            for (var a of e) {
              _loop(a);
            }
            return i;
          }(a.entries(), ((a, [s, o]) => {
            var l = addPath(i, s, n.name);
            var u = executeField(e, n, r, o, l);
            if (void 0 === u) {
              return a;
            }
            if (isPromise(u)) {
              return u.then((e => {
                a[s] = e;
                return a;
              }));
            }
            a[s] = u;
            return a;
          }), Object.create(null));
        }(e, i, r, s, a);

       case u.SUBSCRIPTION:
        return executeFields(e, i, r, s, a);
      }
    }(s, o, a);
    if (isPromise(l)) {
      return l.then((e => buildResponse(e, s.errors)), (e => {
        s.errors.push(e);
        return buildResponse(null, s.errors);
      }));
    }
    return buildResponse(l, s.errors);
  } catch (e) {
    s.errors.push(e);
    return buildResponse(null, s.errors);
  }
}

function buildResponse(e, n) {
  return 0 === n.length ? {
    data: e
  } : {
    errors: n,
    data: e
  };
}

function executeFields(e, n, r, i, a) {
  var s = Object.create(null);
  var o = !1;
  try {
    for (var [l, u] of a.entries()) {
      var c = executeField(e, n, r, u, addPath(i, l, n.name));
      if (void 0 !== c) {
        s[l] = c;
        if (isPromise(c)) {
          o = !0;
        }
      }
    }
  } catch (e) {
    if (o) {
      return promiseForObject(s).finally((() => {
        throw e;
      }));
    }
    throw e;
  }
  if (!o) {
    return s;
  }
  return promiseForObject(s);
}

function executeField(e, n, r, i, a) {
  var s;
  var o = function getFieldDef$1(e, n, r) {
    var i = r.name.value;
    if (i === q.name && e.getQueryType() === n) {
      return q;
    } else if (i === J.name && e.getQueryType() === n) {
      return J;
    } else if (i === W.name) {
      return W;
    }
    return n.getFields()[i];
  }(e.schema, n, i[0]);
  if (!o) {
    return;
  }
  var l = o.type;
  var u = null !== (s = o.resolve) && void 0 !== s ? s : e.fieldResolver;
  var c = function buildResolveInfo(e, n, r, i, a) {
    return {
      fieldName: n.name,
      fieldNodes: r,
      returnType: n.type,
      parentType: i,
      path: a,
      schema: e.schema,
      fragments: e.fragments,
      rootValue: e.rootValue,
      operation: e.operation,
      variableValues: e.variableValues
    };
  }(e, o, i, n, a);
  try {
    var d = u(r, getArgumentValues(o, i[0], e.variableValues), e.contextValue, c);
    var f;
    if (isPromise(d)) {
      f = d.then((n => completeValue(e, l, i, c, a, n)));
    } else {
      f = completeValue(e, l, i, c, a, d);
    }
    if (isPromise(f)) {
      return f.then(void 0, (n => handleFieldError(locatedError(n, i, pathToArray(a)), l, e)));
    }
    return f;
  } catch (n) {
    return handleFieldError(locatedError(n, i, pathToArray(a)), l, e);
  }
}

function handleFieldError(e, n, r) {
  if (isNonNullType(n)) {
    throw e;
  }
  r.errors.push(e);
  return null;
}

function completeValue(e, n, r, i, a, s) {
  if (s instanceof Error) {
    throw s;
  }
  if (isNonNullType(n)) {
    var o = completeValue(e, n.ofType, r, i, a, s);
    if (null === o) {
      throw new Error(`Cannot return null for non-nullable field ${i.parentType.name}.${i.fieldName}.`);
    }
    return o;
  }
  if (null == s) {
    return null;
  }
  if (isListType(n)) {
    return function completeListValue(e, n, r, i, a, s) {
      if (!isIterableObject(s)) {
        throw new GraphQLError(`Expected Iterable, but did not find one for field "${i.parentType.name}.${i.fieldName}".`);
      }
      var o = n.ofType;
      var l = !1;
      var u = Array.from(s, ((n, s) => {
        var u = addPath(a, s, void 0);
        try {
          var c;
          if (isPromise(n)) {
            c = n.then((n => completeValue(e, o, r, i, u, n)));
          } else {
            c = completeValue(e, o, r, i, u, n);
          }
          if (isPromise(c)) {
            l = !0;
            return c.then(void 0, (n => handleFieldError(locatedError(n, r, pathToArray(u)), o, e)));
          }
          return c;
        } catch (n) {
          return handleFieldError(locatedError(n, r, pathToArray(u)), o, e);
        }
      }));
      return l ? Promise.all(u) : u;
    }(e, n, r, i, a, s);
  }
  if (isLeafType(n)) {
    return function completeLeafValue(e, n) {
      var r = e.serialize(n);
      if (null == r) {
        throw new Error(`Expected \`${inspect(e)}.serialize(${inspect(n)})\` to return non-nullable value, returned: ${inspect(r)}`);
      }
      return r;
    }(n, s);
  }
  if (isAbstractType(n)) {
    return function completeAbstractValue(e, n, r, i, a, s) {
      var o;
      var l = null !== (o = n.resolveType) && void 0 !== o ? o : e.typeResolver;
      var u = e.contextValue;
      var c = l(s, u, i, n);
      if (isPromise(c)) {
        return c.then((o => completeObjectValue(e, ensureValidRuntimeType(o, e, n, r, i, s), r, i, a, s)));
      }
      return completeObjectValue(e, ensureValidRuntimeType(c, e, n, r, i, s), r, i, a, s);
    }(e, n, r, i, a, s);
  }
  if (isObjectType(n)) {
    return completeObjectValue(e, n, r, i, a, s);
  }
  invariant$1(!1, "Cannot complete value of unexpected output type: " + inspect(n));
}

function ensureValidRuntimeType(e, n, r, i, a, s) {
  if (null == e) {
    throw new GraphQLError(`Abstract type "${r.name}" must resolve to an Object type at runtime for field "${a.parentType.name}.${a.fieldName}". Either the "${r.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, i);
  }
  if (isObjectType(e)) {
    throw new GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if ("string" != typeof e) {
    throw new GraphQLError(`Abstract type "${r.name}" must resolve to an Object type at runtime for field "${a.parentType.name}.${a.fieldName}" with value ${inspect(s)}, received "${inspect(e)}".`);
  }
  var o = n.schema.getType(e);
  if (null == o) {
    throw new GraphQLError(`Abstract type "${r.name}" was resolved to a type "${e}" that does not exist inside the schema.`, {
      nodes: i
    });
  }
  if (!isObjectType(o)) {
    throw new GraphQLError(`Abstract type "${r.name}" was resolved to a non-object type "${e}".`, {
      nodes: i
    });
  }
  if (!n.schema.isSubType(r, o)) {
    throw new GraphQLError(`Runtime Object type "${o.name}" is not a possible type for "${r.name}".`, {
      nodes: i
    });
  }
  return o;
}

function completeObjectValue(e, n, r, i, a, s) {
  var o = te(e, n, r);
  if (n.isTypeOf) {
    var l = n.isTypeOf(s, e.contextValue, i);
    if (isPromise(l)) {
      return l.then((i => {
        if (!i) {
          throw invalidReturnTypeError(n, s, r);
        }
        return executeFields(e, n, s, a, o);
      }));
    }
    if (!l) {
      throw invalidReturnTypeError(n, s, r);
    }
  }
  return executeFields(e, n, s, a, o);
}

function invalidReturnTypeError(e, n, r) {
  return new GraphQLError(`Expected value of type "${e.name}" but got: ${inspect(n)}.`, {
    nodes: r
  });
}

var defaultTypeResolver = function(e, n, r, i) {
  if (isObjectLike(e) && "string" == typeof e.__typename) {
    return e.__typename;
  }
  var a = r.schema.getPossibleTypes(i);
  var s = [];
  for (var o = 0; o < a.length; o++) {
    var l = a[o];
    if (l.isTypeOf) {
      var u = l.isTypeOf(e, n, r);
      if (isPromise(u)) {
        s[o] = u;
      } else if (u) {
        return l.name;
      }
    }
  }
  if (s.length) {
    return Promise.all(s).then((e => {
      for (var n = 0; n < e.length; n++) {
        if (e[n]) {
          return a[n].name;
        }
      }
    }));
  }
};

var defaultFieldResolver = function(e, n, r, i) {
  if (isObjectLike(e) || "function" == typeof e) {
    var a = e[i.fieldName];
    if ("function" == typeof a) {
      return e[i.fieldName](n, r, i);
    }
    return a;
  }
};

function NoDeprecatedCustomRule(e) {
  return {
    Field(n) {
      var r = e.getFieldDef();
      var i = null == r ? void 0 : r.deprecationReason;
      if (r && null != i) {
        var a = e.getParentType();
        null != a || invariant$1(!1);
        e.reportError(new GraphQLError(`The field ${a.name}.${r.name} is deprecated. ${i}`, {
          nodes: n
        }));
      }
    },
    Argument(n) {
      var r = e.getArgument();
      var i = null == r ? void 0 : r.deprecationReason;
      if (r && null != i) {
        var a = e.getDirective();
        if (null != a) {
          e.reportError(new GraphQLError(`Directive "@${a.name}" argument "${r.name}" is deprecated. ${i}`, {
            nodes: n
          }));
        } else {
          var s = e.getParentType();
          var o = e.getFieldDef();
          null != s && null != o || invariant$1(!1);
          e.reportError(new GraphQLError(`Field "${s.name}.${o.name}" argument "${r.name}" is deprecated. ${i}`, {
            nodes: n
          }));
        }
      }
    },
    ObjectField(n) {
      var r = getNamedType(e.getParentInputType());
      if (isInputObjectType(r)) {
        var i = r.getFields()[n.name.value];
        var a = null == i ? void 0 : i.deprecationReason;
        if (null != a) {
          e.reportError(new GraphQLError(`The input field ${r.name}.${i.name} is deprecated. ${a}`, {
            nodes: n
          }));
        }
      }
    },
    EnumValue(n) {
      var r = e.getEnumValue();
      var i = null == r ? void 0 : r.deprecationReason;
      if (r && null != i) {
        var a = getNamedType(e.getInputType());
        null != a || invariant$1(!1);
        e.reportError(new GraphQLError(`The enum value "${a.name}.${r.name}" is deprecated. ${i}`, {
          nodes: n
        }));
      }
    }
  };
}

function getIntrospectionQuery(e) {
  var n = {
    descriptions: !0,
    specifiedByUrl: !1,
    directiveIsRepeatable: !1,
    schemaDescription: !1,
    inputValueDeprecation: !1,
    ...e
  };
  var r = n.descriptions ? "description" : "";
  var i = n.specifiedByUrl ? "specifiedByURL" : "";
  function inputDeprecation(e) {
    return n.inputValueDeprecation ? e : "";
  }
  return `\n    query IntrospectionQuery {\n      __schema {\n        ${n.schemaDescription ? r : ""}\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ${r}\n          ${n.directiveIsRepeatable ? "isRepeatable" : ""}\n          locations\n          args${inputDeprecation("(includeDeprecated: true)")} {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ${r}\n      ${i}\n      fields(includeDeprecated: true) {\n        name\n        ${r}\n        args${inputDeprecation("(includeDeprecated: true)")} {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields${inputDeprecation("(includeDeprecated: true)")} {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ${r}\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ${r}\n      type { ...TypeRef }\n      defaultValue\n      ${inputDeprecation("isDeprecated")}\n      ${inputDeprecation("deprecationReason")}\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                    ofType {\n                      kind\n                      name\n                      ofType {\n                        kind\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;
}

function introspectionFromSchema(e, n) {
  var r = function executeSync(e) {
    var n = execute(e);
    if (isPromise(n)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return n;
  }({
    schema: e,
    document: parse(getIntrospectionQuery({
      specifiedByUrl: !0,
      directiveIsRepeatable: !0,
      schemaDescription: !0,
      inputValueDeprecation: !0,
      ...n
    }))
  });
  !r.errors && r.data || invariant$1(!1);
  return r.data;
}

function buildClientSchema(e, n) {
  isObjectLike(e) && isObjectLike(e.__schema) || devAssert(!1, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(e)}.`);
  var r = e.__schema;
  var i = keyValMap(r.types, (e => e.name), (e => function buildType(e) {
    if (null != e && null != e.name && null != e.kind) {
      switch (e.kind) {
       case z.SCALAR:
        return function buildScalarDef(e) {
          return new GraphQLScalarType({
            name: e.name,
            description: e.description,
            specifiedByURL: e.specifiedByURL
          });
        }(e);

       case z.OBJECT:
        return function buildObjectDef(e) {
          return new GraphQLObjectType({
            name: e.name,
            description: e.description,
            interfaces: () => buildImplementationsList(e),
            fields: () => buildFieldDefMap(e)
          });
        }(e);

       case z.INTERFACE:
        return function buildInterfaceDef(e) {
          return new GraphQLInterfaceType({
            name: e.name,
            description: e.description,
            interfaces: () => buildImplementationsList(e),
            fields: () => buildFieldDefMap(e)
          });
        }(e);

       case z.UNION:
        return function buildUnionDef(e) {
          if (!e.possibleTypes) {
            var n = inspect(e);
            throw new Error(`Introspection result missing possibleTypes: ${n}.`);
          }
          return new GraphQLUnionType({
            name: e.name,
            description: e.description,
            types: () => e.possibleTypes.map(getObjectType)
          });
        }(e);

       case z.ENUM:
        return function buildEnumDef(e) {
          if (!e.enumValues) {
            var n = inspect(e);
            throw new Error(`Introspection result missing enumValues: ${n}.`);
          }
          return new GraphQLEnumType({
            name: e.name,
            description: e.description,
            values: keyValMap(e.enumValues, (e => e.name), (e => ({
              description: e.description,
              deprecationReason: e.deprecationReason
            })))
          });
        }(e);

       case z.INPUT_OBJECT:
        return function buildInputObjectDef(e) {
          if (!e.inputFields) {
            var n = inspect(e);
            throw new Error(`Introspection result missing inputFields: ${n}.`);
          }
          return new GraphQLInputObjectType({
            name: e.name,
            description: e.description,
            fields: () => buildInputValueDefMap(e.inputFields)
          });
        }(e);
      }
    }
    var n = inspect(e);
    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${n}.`);
  }(e)));
  for (var a of [ ...F, ...X ]) {
    if (i[a.name]) {
      i[a.name] = a;
    }
  }
  var s = r.queryType ? getObjectType(r.queryType) : null;
  var o = r.mutationType ? getObjectType(r.mutationType) : null;
  var l = r.subscriptionType ? getObjectType(r.subscriptionType) : null;
  var u = r.directives ? r.directives.map((function buildDirective(e) {
    if (!e.args) {
      var n = inspect(e);
      throw new Error(`Introspection result missing directive args: ${n}.`);
    }
    if (!e.locations) {
      var r = inspect(e);
      throw new Error(`Introspection result missing directive locations: ${r}.`);
    }
    return new GraphQLDirective({
      name: e.name,
      description: e.description,
      isRepeatable: e.isRepeatable,
      locations: e.locations.slice(),
      args: buildInputValueDefMap(e.args)
    });
  })) : [];
  return new GraphQLSchema({
    description: r.description,
    query: s,
    mutation: o,
    subscription: l,
    types: Object.values(i),
    directives: u,
    assumeValid: null == n ? void 0 : n.assumeValid
  });
  function getType(e) {
    if (e.kind === z.LIST) {
      var n = e.ofType;
      if (!n) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(n));
    }
    if (e.kind === z.NON_NULL) {
      var r = e.ofType;
      if (!r) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      var i = getType(r);
      return new GraphQLNonNull(function assertNullableType(e) {
        if (!isNullableType(e)) {
          throw new Error(`Expected ${inspect(e)} to be a GraphQL nullable type.`);
        }
        return e;
      }(i));
    }
    return getNamedType(e);
  }
  function getNamedType(e) {
    var n = e.name;
    if (!n) {
      throw new Error(`Unknown type reference: ${inspect(e)}.`);
    }
    var r = i[n];
    if (!r) {
      throw new Error(`Invalid or incomplete schema, unknown type: ${n}. Ensure that a full introspection query is used in order to build a client schema.`);
    }
    return r;
  }
  function getObjectType(e) {
    return function assertObjectType(e) {
      if (!isObjectType(e)) {
        throw new Error(`Expected ${inspect(e)} to be a GraphQL Object type.`);
      }
      return e;
    }(getNamedType(e));
  }
  function getInterfaceType(e) {
    return function assertInterfaceType(e) {
      if (!isInterfaceType(e)) {
        throw new Error(`Expected ${inspect(e)} to be a GraphQL Interface type.`);
      }
      return e;
    }(getNamedType(e));
  }
  function buildImplementationsList(e) {
    if (null === e.interfaces && e.kind === z.INTERFACE) {
      return [];
    }
    if (!e.interfaces) {
      var n = inspect(e);
      throw new Error(`Introspection result missing interfaces: ${n}.`);
    }
    return e.interfaces.map(getInterfaceType);
  }
  function buildFieldDefMap(e) {
    if (!e.fields) {
      throw new Error(`Introspection result missing fields: ${inspect(e)}.`);
    }
    return keyValMap(e.fields, (e => e.name), buildField);
  }
  function buildField(e) {
    var n = getType(e.type);
    if (!isOutputType(n)) {
      var r = inspect(n);
      throw new Error(`Introspection must provide output type for fields, but received: ${r}.`);
    }
    if (!e.args) {
      var i = inspect(e);
      throw new Error(`Introspection result missing field args: ${i}.`);
    }
    return {
      description: e.description,
      deprecationReason: e.deprecationReason,
      type: n,
      args: buildInputValueDefMap(e.args)
    };
  }
  function buildInputValueDefMap(e) {
    return keyValMap(e, (e => e.name), buildInputValue);
  }
  function buildInputValue(e) {
    var n = getType(e.type);
    if (!isInputType(n)) {
      var r = inspect(n);
      throw new Error(`Introspection must provide input type for arguments, but received: ${r}.`);
    }
    var i = null != e.defaultValue ? valueFromAST(function parseValue(e, n) {
      var r = new Parser(e, n);
      r.expectToken(f.SOF);
      var i = r.parseValueLiteral(!1);
      r.expectToken(f.EOF);
      return i;
    }(e.defaultValue), n) : void 0;
    return {
      description: e.description,
      type: n,
      defaultValue: i,
      deprecationReason: e.deprecationReason
    };
  }
}

function extendSchemaImpl(e, n, r) {
  var i, a, s, o;
  var l = [];
  var u = Object.create(null);
  var c = [];
  var f;
  var v = [];
  for (var h of n.definitions) {
    if (h.kind === d.SCHEMA_DEFINITION) {
      f = h;
    } else if (h.kind === d.SCHEMA_EXTENSION) {
      v.push(h);
    } else if (isTypeDefinitionNode(h)) {
      l.push(h);
    } else if (isTypeExtensionNode(h)) {
      var m = h.name.value;
      var g = u[m];
      u[m] = g ? g.concat([ h ]) : [ h ];
    } else if (h.kind === d.DIRECTIVE_DEFINITION) {
      c.push(h);
    }
  }
  if (0 === Object.keys(u).length && 0 === l.length && 0 === c.length && 0 === v.length && null == f) {
    return e;
  }
  var y = Object.create(null);
  for (var T of e.types) {
    y[T.name] = extendNamedType(T);
  }
  for (var E of l) {
    var N;
    var I = E.name.value;
    y[I] = null !== (N = ne[I]) && void 0 !== N ? N : buildType(E);
  }
  var b = {
    query: e.query && replaceNamedType(e.query),
    mutation: e.mutation && replaceNamedType(e.mutation),
    subscription: e.subscription && replaceNamedType(e.subscription),
    ...f && getOperationTypes([ f ]),
    ...getOperationTypes(v)
  };
  return {
    description: null === (i = f) || void 0 === i ? void 0 : null === (a = i.description) || void 0 === a ? void 0 : a.value,
    ...b,
    types: Object.values(y),
    directives: [ ...e.directives.map((function replaceDirective(e) {
      var n = e.toConfig();
      return new GraphQLDirective({
        ...n,
        args: mapValue(n.args, extendArg)
      });
    })), ...c.map((function buildDirective(e) {
      var n;
      return new GraphQLDirective({
        name: e.name.value,
        description: null === (n = e.description) || void 0 === n ? void 0 : n.value,
        locations: e.locations.map((({value: e}) => e)),
        isRepeatable: e.repeatable,
        args: buildArgumentMap(e.arguments),
        astNode: e
      });
    })) ],
    extensions: Object.create(null),
    astNode: null !== (s = f) && void 0 !== s ? s : e.astNode,
    extensionASTNodes: e.extensionASTNodes.concat(v),
    assumeValid: null !== (o = null == r ? void 0 : r.assumeValid) && void 0 !== o ? o : !1
  };
  function replaceType(e) {
    if (isListType(e)) {
      return new GraphQLList(replaceType(e.ofType));
    }
    if (isNonNullType(e)) {
      return new GraphQLNonNull(replaceType(e.ofType));
    }
    return replaceNamedType(e);
  }
  function replaceNamedType(e) {
    return y[e.name];
  }
  function extendNamedType(e) {
    if (isIntrospectionType(e) || function isSpecifiedScalarType(e) {
      return F.some((({name: n}) => e.name === n));
    }(e)) {
      return e;
    }
    if (isScalarType(e)) {
      return function extendScalarType(e) {
        var n;
        var r = e.toConfig();
        var i = null !== (n = u[r.name]) && void 0 !== n ? n : [];
        var a = r.specifiedByURL;
        for (var s of i) {
          var o;
          a = null !== (o = getSpecifiedByURL(s)) && void 0 !== o ? o : a;
        }
        return new GraphQLScalarType({
          ...r,
          specifiedByURL: a,
          extensionASTNodes: r.extensionASTNodes.concat(i)
        });
      }(e);
    }
    if (isObjectType(e)) {
      return function extendObjectType(e) {
        var n;
        var r = e.toConfig();
        var i = null !== (n = u[r.name]) && void 0 !== n ? n : [];
        return new GraphQLObjectType({
          ...r,
          interfaces: () => [ ...e.getInterfaces().map(replaceNamedType), ...buildInterfaces(i) ],
          fields: () => ({
            ...mapValue(r.fields, extendField),
            ...buildFieldMap(i)
          }),
          extensionASTNodes: r.extensionASTNodes.concat(i)
        });
      }(e);
    }
    if (isInterfaceType(e)) {
      return function extendInterfaceType(e) {
        var n;
        var r = e.toConfig();
        var i = null !== (n = u[r.name]) && void 0 !== n ? n : [];
        return new GraphQLInterfaceType({
          ...r,
          interfaces: () => [ ...e.getInterfaces().map(replaceNamedType), ...buildInterfaces(i) ],
          fields: () => ({
            ...mapValue(r.fields, extendField),
            ...buildFieldMap(i)
          }),
          extensionASTNodes: r.extensionASTNodes.concat(i)
        });
      }(e);
    }
    if (isUnionType(e)) {
      return function extendUnionType(e) {
        var n;
        var r = e.toConfig();
        var i = null !== (n = u[r.name]) && void 0 !== n ? n : [];
        return new GraphQLUnionType({
          ...r,
          types: () => [ ...e.getTypes().map(replaceNamedType), ...buildUnionTypes(i) ],
          extensionASTNodes: r.extensionASTNodes.concat(i)
        });
      }(e);
    }
    if (isEnumType(e)) {
      return function extendEnumType(e) {
        var n;
        var r = e.toConfig();
        var i = null !== (n = u[e.name]) && void 0 !== n ? n : [];
        return new GraphQLEnumType({
          ...r,
          values: {
            ...r.values,
            ...buildEnumValueMap(i)
          },
          extensionASTNodes: r.extensionASTNodes.concat(i)
        });
      }(e);
    }
    if (isInputObjectType(e)) {
      return function extendInputObjectType(e) {
        var n;
        var r = e.toConfig();
        var i = null !== (n = u[r.name]) && void 0 !== n ? n : [];
        return new GraphQLInputObjectType({
          ...r,
          fields: () => ({
            ...mapValue(r.fields, (e => ({
              ...e,
              type: replaceType(e.type)
            }))),
            ...buildInputFieldMap(i)
          }),
          extensionASTNodes: r.extensionASTNodes.concat(i)
        });
      }(e);
    }
    invariant$1(!1, "Unexpected type: " + inspect(e));
  }
  function extendField(e) {
    return {
      ...e,
      type: replaceType(e.type),
      args: e.args && mapValue(e.args, extendArg)
    };
  }
  function extendArg(e) {
    return {
      ...e,
      type: replaceType(e.type)
    };
  }
  function getOperationTypes(e) {
    var n = {};
    for (var r of e) {
      var i;
      var a = null !== (i = r.operationTypes) && void 0 !== i ? i : [];
      for (var s of a) {
        n[s.operation] = getNamedType(s.type);
      }
    }
    return n;
  }
  function getNamedType(e) {
    var n;
    var r = e.name.value;
    var i = null !== (n = ne[r]) && void 0 !== n ? n : y[r];
    if (void 0 === i) {
      throw new Error(`Unknown type: "${r}".`);
    }
    return i;
  }
  function getWrappedType(e) {
    if (e.kind === d.LIST_TYPE) {
      return new GraphQLList(getWrappedType(e.type));
    }
    if (e.kind === d.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(e.type));
    }
    return getNamedType(e);
  }
  function buildFieldMap(e) {
    var n = Object.create(null);
    for (var r of e) {
      var i;
      var a = null !== (i = r.fields) && void 0 !== i ? i : [];
      for (var s of a) {
        var o;
        n[s.name.value] = {
          type: getWrappedType(s.type),
          description: null === (o = s.description) || void 0 === o ? void 0 : o.value,
          args: buildArgumentMap(s.arguments),
          deprecationReason: getDeprecationReason(s),
          astNode: s
        };
      }
    }
    return n;
  }
  function buildArgumentMap(e) {
    var n = null != e ? e : [];
    var r = Object.create(null);
    for (var i of n) {
      var a;
      var s = getWrappedType(i.type);
      r[i.name.value] = {
        type: s,
        description: null === (a = i.description) || void 0 === a ? void 0 : a.value,
        defaultValue: valueFromAST(i.defaultValue, s),
        deprecationReason: getDeprecationReason(i),
        astNode: i
      };
    }
    return r;
  }
  function buildInputFieldMap(e) {
    var n = Object.create(null);
    for (var r of e) {
      var i;
      var a = null !== (i = r.fields) && void 0 !== i ? i : [];
      for (var s of a) {
        var o;
        var l = getWrappedType(s.type);
        n[s.name.value] = {
          type: l,
          description: null === (o = s.description) || void 0 === o ? void 0 : o.value,
          defaultValue: valueFromAST(s.defaultValue, l),
          deprecationReason: getDeprecationReason(s),
          astNode: s
        };
      }
    }
    return n;
  }
  function buildEnumValueMap(e) {
    var n = Object.create(null);
    for (var r of e) {
      var i;
      var a = null !== (i = r.values) && void 0 !== i ? i : [];
      for (var s of a) {
        var o;
        n[s.name.value] = {
          description: null === (o = s.description) || void 0 === o ? void 0 : o.value,
          deprecationReason: getDeprecationReason(s),
          astNode: s
        };
      }
    }
    return n;
  }
  function buildInterfaces(e) {
    return e.flatMap((e => {
      var n, r;
      return null !== (n = null === (r = e.interfaces) || void 0 === r ? void 0 : r.map(getNamedType)) && void 0 !== n ? n : [];
    }));
  }
  function buildUnionTypes(e) {
    return e.flatMap((e => {
      var n, r;
      return null !== (n = null === (r = e.types) || void 0 === r ? void 0 : r.map(getNamedType)) && void 0 !== n ? n : [];
    }));
  }
  function buildType(e) {
    var n;
    var r = e.name.value;
    var i = null !== (n = u[r]) && void 0 !== n ? n : [];
    switch (e.kind) {
     case d.OBJECT_TYPE_DEFINITION:
      var a;
      var s = [ e, ...i ];
      return new GraphQLObjectType({
        name: r,
        description: null === (a = e.description) || void 0 === a ? void 0 : a.value,
        interfaces: () => buildInterfaces(s),
        fields: () => buildFieldMap(s),
        astNode: e,
        extensionASTNodes: i
      });

     case d.INTERFACE_TYPE_DEFINITION:
      var o;
      var l = [ e, ...i ];
      return new GraphQLInterfaceType({
        name: r,
        description: null === (o = e.description) || void 0 === o ? void 0 : o.value,
        interfaces: () => buildInterfaces(l),
        fields: () => buildFieldMap(l),
        astNode: e,
        extensionASTNodes: i
      });

     case d.ENUM_TYPE_DEFINITION:
      var c;
      var f = [ e, ...i ];
      return new GraphQLEnumType({
        name: r,
        description: null === (c = e.description) || void 0 === c ? void 0 : c.value,
        values: buildEnumValueMap(f),
        astNode: e,
        extensionASTNodes: i
      });

     case d.UNION_TYPE_DEFINITION:
      var v;
      var h = [ e, ...i ];
      return new GraphQLUnionType({
        name: r,
        description: null === (v = e.description) || void 0 === v ? void 0 : v.value,
        types: () => buildUnionTypes(h),
        astNode: e,
        extensionASTNodes: i
      });

     case d.SCALAR_TYPE_DEFINITION:
      var m;
      return new GraphQLScalarType({
        name: r,
        description: null === (m = e.description) || void 0 === m ? void 0 : m.value,
        specifiedByURL: getSpecifiedByURL(e),
        astNode: e,
        extensionASTNodes: i
      });

     case d.INPUT_OBJECT_TYPE_DEFINITION:
      var g;
      var y = [ e, ...i ];
      return new GraphQLInputObjectType({
        name: r,
        description: null === (g = e.description) || void 0 === g ? void 0 : g.value,
        fields: () => buildInputFieldMap(y),
        astNode: e,
        extensionASTNodes: i
      });
    }
  }
}

var ne = keyMap([ ...F, ...X ], (e => e.name));

function getDeprecationReason(e) {
  var n = getDirectiveValues(C, e);
  return null == n ? void 0 : n.reason;
}

function getSpecifiedByURL(e) {
  var n = getDirectiveValues(R, e);
  return null == n ? void 0 : n.url;
}

function buildSchema(e, n) {
  return function buildASTSchema(e, n) {
    null != e && e.kind === d.DOCUMENT || devAssert(!1, "Must provide valid Document AST.");
    if (!0 !== (null == n ? void 0 : n.assumeValid) && !0 !== (null == n ? void 0 : n.assumeValidSDL)) {
      assertValidSDL(e);
    }
    var r = extendSchemaImpl({
      description: void 0,
      types: [],
      directives: [],
      extensions: Object.create(null),
      extensionASTNodes: [],
      assumeValid: !1
    }, e, n);
    if (null == r.astNode) {
      for (var i of r.types) {
        switch (i.name) {
         case "Query":
          r.query = i;
          break;

         case "Mutation":
          r.mutation = i;
          break;

         case "Subscription":
          r.subscription = i;
        }
      }
    }
    var a = [ ...r.directives, ...j.filter((e => r.directives.every((n => n.name !== e.name)))) ];
    return new GraphQLSchema({
      ...r,
      directives: a
    });
  }(parse(e, {
    noLocation: null == n ? void 0 : n.noLocation,
    allowLegacyFragmentVariables: null == n ? void 0 : n.allowLegacyFragmentVariables
  }), {
    assumeValidSDL: null == n ? void 0 : n.assumeValidSDL,
    assumeValid: null == n ? void 0 : n.assumeValid
  });
}

var re = !1;

var ie = !1;

var ae = !1;

var se = !1;

var oe = {
  kind: "SCALAR",
  name: "Any"
};

var mapType = e => {
  switch (e.kind) {
   case "NON_NULL":
   case "LIST":
    return {
      kind: e.kind,
      ofType: mapType(e.ofType)
    };

   case "SCALAR":
    if (re) {
      return e;
    } else {
      se = !0;
      return oe;
    }

   case "INPUT_OBJECT":
    if (ae) {
      return e;
    } else {
      se = !0;
      return oe;
    }

   case "ENUM":
    if (ie) {
      return e;
    } else {
      se = !0;
      return oe;
    }

   case "OBJECT":
   case "INTERFACE":
   case "UNION":
    return e;

   default:
    throw new TypeError(`Unrecognized type reference of type: ${e.kind}.`);
  }
};

var minifyIntrospectionType = e => {
  switch (e.kind) {
   case "SCALAR":
    return {
      kind: "SCALAR",
      name: e.name
    };

   case "ENUM":
    return {
      kind: "ENUM",
      name: e.name,
      enumValues: e.enumValues.map((e => ({
        name: e.name
      })))
    };

   case "INPUT_OBJECT":
    return {
      kind: "INPUT_OBJECT",
      name: e.name,
      inputFields: e.inputFields.map((e => ({
        name: e.name,
        type: mapType(e.type),
        defaultValue: e.defaultValue || void 0
      })))
    };

   case "OBJECT":
    return {
      kind: "OBJECT",
      name: e.name,
      fields: e.fields.map((e => ({
        name: e.name,
        type: e.type && mapType(e.type),
        args: e.args && e.args.map((e => ({
          name: e.name,
          type: mapType(e.type)
        })))
      }))),
      interfaces: e.interfaces && e.interfaces.map((e => ({
        kind: "INTERFACE",
        name: e.name
      })))
    };

   case "INTERFACE":
    return {
      kind: "INTERFACE",
      name: e.name,
      fields: e.fields.map((e => ({
        name: e.name,
        type: e.type && mapType(e.type),
        args: e.args && e.args.map((e => ({
          name: e.name,
          type: mapType(e.type)
        })))
      }))),
      interfaces: e.interfaces && e.interfaces.map((e => ({
        kind: "INTERFACE",
        name: e.name
      }))),
      possibleTypes: e.possibleTypes && e.possibleTypes.map((e => ({
        kind: e.kind,
        name: e.name
      })))
    };

   case "UNION":
    return {
      kind: "UNION",
      name: e.name,
      possibleTypes: e.possibleTypes.map((e => ({
        kind: e.kind,
        name: e.name
      })))
    };

   default:
    return e;
  }
};

var le = [ "/* eslint-disable */", "/* prettier-ignore */" ].join("\n") + "\n";

var ue = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * It will automatically be used by `gql.tada` to infer the types of your GraphQL documents.", " * If you need to reuse this data or update your `scalars`, update `tadaOutputLocation` to", " * instead save to a .ts instead of a .d.ts file.", " */" ].join("\n");

var ce = [ "/** An IntrospectionQuery representation of your schema.", " *", " * @remarks", " * This is an introspection of your schema saved as a file by GraphQLSP.", " * You may import it to create a `graphql()` tag function with `gql.tada`", " * by importing it and passing it to `initGraphQLTada<>()`.", " *", " * @example", " * ```", " * import { initGraphQLTada } from 'gql.tada';", " * import type { introspection } from './introspection';", " *", " * export const graphql = initGraphQLTada<{", " *   introspection: typeof introspection;", " *   scalars: {", " *     DateTime: string;", " *     Json: any;", " *   };", " * }>();", " * ```", " */" ].join("\n");

async function saveTadaIntrospection(e, i, a, s) {
  var o = ((e, n = {}) => {
    if (!e || !("__schema" in e)) {
      throw new TypeError("Expected to receive an IntrospectionQuery.");
    }
    se = !1;
    re = !!n.includeScalars;
    ie = !!n.includeEnums;
    ae = !!n.includeInputs;
    var {__schema: {queryType: r, mutationType: i, subscriptionType: a, types: s, directives: o}} = e;
    var l = s.filter((e => {
      switch (e.name) {
       case "__Directive":
       case "__DirectiveLocation":
       case "__EnumValue":
       case "__InputValue":
       case "__Field":
       case "__Type":
       case "__TypeKind":
       case "__Schema":
        return !1;

       default:
        return re && "SCALAR" === e.kind || ie && "ENUM" === e.kind || ae && "INPUT_OBJECT" === e.kind || "OBJECT" === e.kind || "INTERFACE" === e.kind || "UNION" === e.kind;
      }
    })).map(minifyIntrospectionType);
    if (se) {
      l.push({
        kind: "SCALAR",
        name: oe.name
      });
    }
    var u = [];
    if (n.includeDirectives) {
      u = (o || []).map((e => ({
        name: e.name,
        isRepeatable: e.isRepeatable ? !0 : void 0,
        locations: e.locations,
        args: e.args.map((e => ({
          name: e.name,
          type: mapType(e.type),
          defaultValue: e.defaultValue || void 0
        })))
      })));
    }
    return {
      __schema: {
        queryType: r,
        mutationType: i,
        subscriptionType: a,
        types: l,
        directives: u
      }
    };
  })(!("__schema" in i) ? introspectionFromSchema(i, {
    descriptions: !1
  }) : i, {
    includeDirectives: !1,
    includeEnums: !0,
    includeInputs: !0,
    includeScalars: !0
  });
  var l = JSON.stringify(o, null, 2);
  var u = n.resolve(n.dirname(e), a);
  var c;
  var d = "";
  try {
    c = await r.promises.stat(u);
  } catch (e) {
    s(`Failed to resolve path @ ${u}`);
  }
  if (!c) {
    try {
      if (!(c = await r.promises.stat(n.dirname(u))).isDirectory()) {
        s(`Output file is not inside a directory @ ${u}`);
        return;
      }
    } catch (e) {
      s(`Directory does not exist @ ${u}`);
      return;
    }
  } else if (c.isDirectory()) {
    u = n.join(u, "introspection.d.ts");
  } else if (!c.isFile()) {
    s(`No file or directory found on path @ ${u}`);
    return;
  }
  if (/\.d\.ts$/.test(u)) {
    d = [ le, ue, `export type introspection = ${l};\n`, "import * as gqlTada from 'gql.tada';\n", "declare module 'gql.tada' {", "  interface setupSchema {", "    introspection: introspection", "  }", "}" ].join("\n");
  } else if (".ts" === n.extname(u)) {
    d = [ le, ce, `const introspection = ${l} as const;\n`, "export { introspection };" ].join("\n");
  } else {
    s(`Unknown file type on path @ ${u}`);
    return;
  }
  await r.promises.writeFile(u, d);
  s(`Introspection saved to path @ ${u}`);
}

function getDefinitionState(e) {
  var n;
  forEachState(e, (e => {
    switch (e.kind) {
     case "Query":
     case "ShortQuery":
     case "Mutation":
     case "Subscription":
     case "FragmentDefinition":
      n = e;
    }
  }));
  return n;
}

function getFieldDef(e, n, r) {
  if (r === q.name && e.getQueryType() === n) {
    return q;
  }
  if (r === J.name && e.getQueryType() === n) {
    return J;
  }
  if (r === W.name && isCompositeType(n)) {
    return W;
  }
  if ("getFields" in n) {
    return n.getFields()[r];
  }
  return null;
}

function forEachState(e, n) {
  var r = [];
  var i = e;
  while (null == i ? void 0 : i.kind) {
    r.push(i);
    i = i.prevState;
  }
  for (var a = r.length - 1; a >= 0; a--) {
    n(r[a]);
  }
}

function objectValues(e) {
  var n = Object.keys(e);
  var r = n.length;
  var i = new Array(r);
  for (var a = 0; a < r; ++a) {
    i[a] = e[n[a]];
  }
  return i;
}

function hintList$1(e, n) {
  return function filterAndSortList$1(e, n) {
    if (!n) {
      return filterNonEmpty$1(e, (e => !e.isDeprecated));
    }
    var r = e.map((e => ({
      proximity: getProximity$1(normalizeText$1(e.label), n),
      entry: e
    })));
    return filterNonEmpty$1(filterNonEmpty$1(r, (e => e.proximity <= 2)), (e => !e.entry.isDeprecated)).sort(((e, n) => (e.entry.isDeprecated ? 1 : 0) - (n.entry.isDeprecated ? 1 : 0) || e.proximity - n.proximity || e.entry.label.length - n.entry.label.length)).map((e => e.entry));
  }(n, normalizeText$1(e.string));
}

function filterNonEmpty$1(e, n) {
  var r = e.filter(n);
  return 0 === r.length ? e : r;
}

function normalizeText$1(e) {
  return e.toLowerCase().replaceAll(/\W/g, "");
}

function getProximity$1(e, n) {
  var r = function lexicalDistance$1(e, n) {
    var r;
    var i;
    var a = [];
    var s = e.length;
    var o = n.length;
    for (r = 0; r <= s; r++) {
      a[r] = [ r ];
    }
    for (i = 1; i <= o; i++) {
      a[0][i] = i;
    }
    for (r = 1; r <= s; r++) {
      for (i = 1; i <= o; i++) {
        var l = e[r - 1] === n[i - 1] ? 0 : 1;
        a[r][i] = Math.min(a[r - 1][i] + 1, a[r][i - 1] + 1, a[r - 1][i - 1] + l);
        if (r > 1 && i > 1 && e[r - 1] === n[i - 2] && e[r - 2] === n[i - 1]) {
          a[r][i] = Math.min(a[r][i], a[r - 2][i - 2] + l);
        }
      }
    }
    return a[s][o];
  }(n, e);
  if (e.length > n.length) {
    r -= e.length - n.length - 1;
    r += 0 === e.indexOf(n) ? 0 : .5;
  }
  return r;
}

var pe;

!function(e) {
  e.is = function is(e) {
    return "string" == typeof e;
  };
}(pe || (pe = {}));

var de;

!function(e) {
  e.is = function is(e) {
    return "string" == typeof e;
  };
}(de || (de = {}));

var fe;

!function(e) {
  e.MIN_VALUE = -2147483648;
  e.MAX_VALUE = 2147483647;
  e.is = function is(n) {
    return "number" == typeof n && e.MIN_VALUE <= n && n <= e.MAX_VALUE;
  };
}(fe || (fe = {}));

var ve;

!function(e) {
  e.MIN_VALUE = 0;
  e.MAX_VALUE = 2147483647;
  e.is = function is(n) {
    return "number" == typeof n && e.MIN_VALUE <= n && n <= e.MAX_VALUE;
  };
}(ve || (ve = {}));

var he;

!function(e) {
  e.create = function create(e, n) {
    if (e === Number.MAX_VALUE) {
      e = ve.MAX_VALUE;
    }
    if (n === Number.MAX_VALUE) {
      n = ve.MAX_VALUE;
    }
    return {
      line: e,
      character: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.uinteger(n.line) && kt.uinteger(n.character);
  };
}(he || (he = {}));

var me;

!function(e) {
  e.create = function create(e, n, r, i) {
    if (kt.uinteger(e) && kt.uinteger(n) && kt.uinteger(r) && kt.uinteger(i)) {
      return {
        start: he.create(e, n),
        end: he.create(r, i)
      };
    } else if (he.is(e) && he.is(n)) {
      return {
        start: e,
        end: n
      };
    } else {
      throw new Error("Range#create called with invalid arguments[".concat(e, ", ").concat(n, ", ").concat(r, ", ").concat(i, "]"));
    }
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && he.is(n.start) && he.is(n.end);
  };
}(me || (me = {}));

var ge;

!function(e) {
  e.create = function create(e, n) {
    return {
      uri: e,
      range: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && me.is(n.range) && (kt.string(n.uri) || kt.undefined(n.uri));
  };
}(ge || (ge = {}));

var ye;

!function(e) {
  e.create = function create(e, n, r, i) {
    return {
      targetUri: e,
      targetRange: n,
      targetSelectionRange: r,
      originSelectionRange: i
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && me.is(n.targetRange) && kt.string(n.targetUri) && me.is(n.targetSelectionRange) && (me.is(n.originSelectionRange) || kt.undefined(n.originSelectionRange));
  };
}(ye || (ye = {}));

var Te;

!function(e) {
  e.create = function create(e, n, r, i) {
    return {
      red: e,
      green: n,
      blue: r,
      alpha: i
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.numberRange(n.red, 0, 1) && kt.numberRange(n.green, 0, 1) && kt.numberRange(n.blue, 0, 1) && kt.numberRange(n.alpha, 0, 1);
  };
}(Te || (Te = {}));

var Ee;

!function(e) {
  e.create = function create(e, n) {
    return {
      range: e,
      color: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && me.is(n.range) && Te.is(n.color);
  };
}(Ee || (Ee = {}));

var Ne;

!function(e) {
  e.create = function create(e, n, r) {
    return {
      label: e,
      textEdit: n,
      additionalTextEdits: r
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.string(n.label) && (kt.undefined(n.textEdit) || xe.is(n)) && (kt.undefined(n.additionalTextEdits) || kt.typedArray(n.additionalTextEdits, xe.is));
  };
}(Ne || (Ne = {}));

var Ie;

!function(e) {
  e.Comment = "comment";
  e.Imports = "imports";
  e.Region = "region";
}(Ie || (Ie = {}));

var be;

!function(e) {
  e.create = function create(e, n, r, i, a, s) {
    var o = {
      startLine: e,
      endLine: n
    };
    if (kt.defined(r)) {
      o.startCharacter = r;
    }
    if (kt.defined(i)) {
      o.endCharacter = i;
    }
    if (kt.defined(a)) {
      o.kind = a;
    }
    if (kt.defined(s)) {
      o.collapsedText = s;
    }
    return o;
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.uinteger(n.startLine) && kt.uinteger(n.startLine) && (kt.undefined(n.startCharacter) || kt.uinteger(n.startCharacter)) && (kt.undefined(n.endCharacter) || kt.uinteger(n.endCharacter)) && (kt.undefined(n.kind) || kt.string(n.kind));
  };
}(be || (be = {}));

var Se;

!function(e) {
  e.create = function create(e, n) {
    return {
      location: e,
      message: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && ge.is(n.location) && kt.string(n.message);
  };
}(Se || (Se = {}));

var _e;

!function(e) {
  e.Error = 1;
  e.Warning = 2;
  e.Information = 3;
  e.Hint = 4;
}(_e || (_e = {}));

var Ae;

!function(e) {
  e.Unnecessary = 1;
  e.Deprecated = 2;
}(Ae || (Ae = {}));

var Oe;

!function(e) {
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.string(n.href);
  };
}(Oe || (Oe = {}));

var Le;

!function(e) {
  e.create = function create(e, n, r, i, a, s) {
    var o = {
      range: e,
      message: n
    };
    if (kt.defined(r)) {
      o.severity = r;
    }
    if (kt.defined(i)) {
      o.code = i;
    }
    if (kt.defined(a)) {
      o.source = a;
    }
    if (kt.defined(s)) {
      o.relatedInformation = s;
    }
    return o;
  };
  e.is = function is(e) {
    var n;
    var r = e;
    return kt.defined(r) && me.is(r.range) && kt.string(r.message) && (kt.number(r.severity) || kt.undefined(r.severity)) && (kt.integer(r.code) || kt.string(r.code) || kt.undefined(r.code)) && (kt.undefined(r.codeDescription) || kt.string(null === (n = r.codeDescription) || void 0 === n ? void 0 : n.href)) && (kt.string(r.source) || kt.undefined(r.source)) && (kt.undefined(r.relatedInformation) || kt.typedArray(r.relatedInformation, Se.is));
  };
}(Le || (Le = {}));

var De;

!function(e) {
  e.create = function create(e, n) {
    var r = [];
    for (var i = 2; i < arguments.length; i++) {
      r[i - 2] = arguments[i];
    }
    var a = {
      title: e,
      command: n
    };
    if (kt.defined(r) && r.length > 0) {
      a.arguments = r;
    }
    return a;
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.string(n.title) && kt.string(n.command);
  };
}(De || (De = {}));

var xe;

!function(e) {
  e.replace = function replace(e, n) {
    return {
      range: e,
      newText: n
    };
  };
  e.insert = function insert(e, n) {
    return {
      range: {
        start: e,
        end: e
      },
      newText: n
    };
  };
  e.del = function del(e) {
    return {
      range: e,
      newText: ""
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.string(n.newText) && me.is(n.range);
  };
}(xe || (xe = {}));

var Fe;

!function(e) {
  e.create = function create(e, n, r) {
    var i = {
      label: e
    };
    if (void 0 !== n) {
      i.needsConfirmation = n;
    }
    if (void 0 !== r) {
      i.description = r;
    }
    return i;
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && kt.string(n.label) && (kt.boolean(n.needsConfirmation) || void 0 === n.needsConfirmation) && (kt.string(n.description) || void 0 === n.description);
  };
}(Fe || (Fe = {}));

var we;

!function(e) {
  e.is = function is(e) {
    return kt.string(e);
  };
}(we || (we = {}));

var ke;

!function(e) {
  e.replace = function replace(e, n, r) {
    return {
      range: e,
      newText: n,
      annotationId: r
    };
  };
  e.insert = function insert(e, n, r) {
    return {
      range: {
        start: e,
        end: e
      },
      newText: n,
      annotationId: r
    };
  };
  e.del = function del(e, n) {
    return {
      range: e,
      newText: "",
      annotationId: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return xe.is(n) && (Fe.is(n.annotationId) || we.is(n.annotationId));
  };
}(ke || (ke = {}));

var Ce;

!function(e) {
  e.create = function create(e, n) {
    return {
      textDocument: e,
      edits: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && Qe.is(n.textDocument) && Array.isArray(n.edits);
  };
}(Ce || (Ce = {}));

var Re;

!function(e) {
  e.create = function create(e, n, r) {
    var i = {
      kind: "create",
      uri: e
    };
    if (void 0 !== n && (void 0 !== n.overwrite || void 0 !== n.ignoreIfExists)) {
      i.options = n;
    }
    if (void 0 !== r) {
      i.annotationId = r;
    }
    return i;
  };
  e.is = function is(e) {
    var n = e;
    return n && "create" === n.kind && kt.string(n.uri) && (void 0 === n.options || (void 0 === n.options.overwrite || kt.boolean(n.options.overwrite)) && (void 0 === n.options.ignoreIfExists || kt.boolean(n.options.ignoreIfExists))) && (void 0 === n.annotationId || we.is(n.annotationId));
  };
}(Re || (Re = {}));

var je;

!function(e) {
  e.create = function create(e, n, r, i) {
    var a = {
      kind: "rename",
      oldUri: e,
      newUri: n
    };
    if (void 0 !== r && (void 0 !== r.overwrite || void 0 !== r.ignoreIfExists)) {
      a.options = r;
    }
    if (void 0 !== i) {
      a.annotationId = i;
    }
    return a;
  };
  e.is = function is(e) {
    var n = e;
    return n && "rename" === n.kind && kt.string(n.oldUri) && kt.string(n.newUri) && (void 0 === n.options || (void 0 === n.options.overwrite || kt.boolean(n.options.overwrite)) && (void 0 === n.options.ignoreIfExists || kt.boolean(n.options.ignoreIfExists))) && (void 0 === n.annotationId || we.is(n.annotationId));
  };
}(je || (je = {}));

var Ve;

!function(e) {
  e.create = function create(e, n, r) {
    var i = {
      kind: "delete",
      uri: e
    };
    if (void 0 !== n && (void 0 !== n.recursive || void 0 !== n.ignoreIfNotExists)) {
      i.options = n;
    }
    if (void 0 !== r) {
      i.annotationId = r;
    }
    return i;
  };
  e.is = function is(e) {
    var n = e;
    return n && "delete" === n.kind && kt.string(n.uri) && (void 0 === n.options || (void 0 === n.options.recursive || kt.boolean(n.options.recursive)) && (void 0 === n.options.ignoreIfNotExists || kt.boolean(n.options.ignoreIfNotExists))) && (void 0 === n.annotationId || we.is(n.annotationId));
  };
}(Ve || (Ve = {}));

var Ue;

!function(e) {
  e.is = function is(e) {
    return e && (void 0 !== e.changes || void 0 !== e.documentChanges) && (void 0 === e.documentChanges || e.documentChanges.every((function(e) {
      if (kt.string(e.kind)) {
        return Re.is(e) || je.is(e) || Ve.is(e);
      } else {
        return Ce.is(e);
      }
    })));
  };
}(Ue || (Ue = {}));

var Me = function() {
  function TextEditChangeImpl(e, n) {
    this.edits = e;
    this.changeAnnotations = n;
  }
  TextEditChangeImpl.prototype.insert = function(e, n, r) {
    var i;
    var a;
    if (void 0 === r) {
      i = xe.insert(e, n);
    } else if (we.is(r)) {
      a = r;
      i = ke.insert(e, n, r);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      a = this.changeAnnotations.manage(r);
      i = ke.insert(e, n, a);
    }
    this.edits.push(i);
    if (void 0 !== a) {
      return a;
    }
  };
  TextEditChangeImpl.prototype.replace = function(e, n, r) {
    var i;
    var a;
    if (void 0 === r) {
      i = xe.replace(e, n);
    } else if (we.is(r)) {
      a = r;
      i = ke.replace(e, n, r);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      a = this.changeAnnotations.manage(r);
      i = ke.replace(e, n, a);
    }
    this.edits.push(i);
    if (void 0 !== a) {
      return a;
    }
  };
  TextEditChangeImpl.prototype.delete = function(e, n) {
    var r;
    var i;
    if (void 0 === n) {
      r = xe.del(e);
    } else if (we.is(n)) {
      i = n;
      r = ke.del(e, n);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      i = this.changeAnnotations.manage(n);
      r = ke.del(e, i);
    }
    this.edits.push(r);
    if (void 0 !== i) {
      return i;
    }
  };
  TextEditChangeImpl.prototype.add = function(e) {
    this.edits.push(e);
  };
  TextEditChangeImpl.prototype.all = function() {
    return this.edits;
  };
  TextEditChangeImpl.prototype.clear = function() {
    this.edits.splice(0, this.edits.length);
  };
  TextEditChangeImpl.prototype.assertChangeAnnotations = function(e) {
    if (void 0 === e) {
      throw new Error("Text edit change is not configured to manage change annotations.");
    }
  };
  return TextEditChangeImpl;
}();

var $e = function() {
  function ChangeAnnotations(e) {
    this._annotations = void 0 === e ? Object.create(null) : e;
    this._counter = 0;
    this._size = 0;
  }
  ChangeAnnotations.prototype.all = function() {
    return this._annotations;
  };
  Object.defineProperty(ChangeAnnotations.prototype, "size", {
    get: function() {
      return this._size;
    },
    enumerable: !1,
    configurable: !0
  });
  ChangeAnnotations.prototype.manage = function(e, n) {
    var r;
    if (we.is(e)) {
      r = e;
    } else {
      r = this.nextId();
      n = e;
    }
    if (void 0 !== this._annotations[r]) {
      throw new Error("Id ".concat(r, " is already in use."));
    }
    if (void 0 === n) {
      throw new Error("No annotation provided for id ".concat(r));
    }
    this._annotations[r] = n;
    this._size++;
    return r;
  };
  ChangeAnnotations.prototype.nextId = function() {
    this._counter++;
    return this._counter.toString();
  };
  return ChangeAnnotations;
}();

!function() {
  function WorkspaceChange(e) {
    var n = this;
    this._textEditChanges = Object.create(null);
    if (void 0 !== e) {
      this._workspaceEdit = e;
      if (e.documentChanges) {
        this._changeAnnotations = new $e(e.changeAnnotations);
        e.changeAnnotations = this._changeAnnotations.all();
        e.documentChanges.forEach((function(e) {
          if (Ce.is(e)) {
            var r = new Me(e.edits, n._changeAnnotations);
            n._textEditChanges[e.textDocument.uri] = r;
          }
        }));
      } else if (e.changes) {
        Object.keys(e.changes).forEach((function(r) {
          var i = new Me(e.changes[r]);
          n._textEditChanges[r] = i;
        }));
      }
    } else {
      this._workspaceEdit = {};
    }
  }
  Object.defineProperty(WorkspaceChange.prototype, "edit", {
    get: function() {
      this.initDocumentChanges();
      if (void 0 !== this._changeAnnotations) {
        if (0 === this._changeAnnotations.size) {
          this._workspaceEdit.changeAnnotations = void 0;
        } else {
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      return this._workspaceEdit;
    },
    enumerable: !1,
    configurable: !0
  });
  WorkspaceChange.prototype.getTextEditChange = function(e) {
    if (Qe.is(e)) {
      this.initDocumentChanges();
      if (void 0 === this._workspaceEdit.documentChanges) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var n = {
        uri: e.uri,
        version: e.version
      };
      if (!(r = this._textEditChanges[n.uri])) {
        this._workspaceEdit.documentChanges.push({
          textDocument: n,
          edits: i = []
        });
        r = new Me(i, this._changeAnnotations);
        this._textEditChanges[n.uri] = r;
      }
      return r;
    } else {
      this.initChanges();
      if (void 0 === this._workspaceEdit.changes) {
        throw new Error("Workspace edit is not configured for normal text edit changes.");
      }
      var r;
      if (!(r = this._textEditChanges[e])) {
        var i;
        this._workspaceEdit.changes[e] = i = [];
        r = new Me(i);
        this._textEditChanges[e] = r;
      }
      return r;
    }
  };
  WorkspaceChange.prototype.initDocumentChanges = function() {
    if (void 0 === this._workspaceEdit.documentChanges && void 0 === this._workspaceEdit.changes) {
      this._changeAnnotations = new $e;
      this._workspaceEdit.documentChanges = [];
      this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
    }
  };
  WorkspaceChange.prototype.initChanges = function() {
    if (void 0 === this._workspaceEdit.documentChanges && void 0 === this._workspaceEdit.changes) {
      this._workspaceEdit.changes = Object.create(null);
    }
  };
  WorkspaceChange.prototype.createFile = function(e, n, r) {
    this.initDocumentChanges();
    if (void 0 === this._workspaceEdit.documentChanges) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var i;
    if (Fe.is(n) || we.is(n)) {
      i = n;
    } else {
      r = n;
    }
    var a;
    var s;
    if (void 0 === i) {
      a = Re.create(e, r);
    } else {
      s = we.is(i) ? i : this._changeAnnotations.manage(i);
      a = Re.create(e, r, s);
    }
    this._workspaceEdit.documentChanges.push(a);
    if (void 0 !== s) {
      return s;
    }
  };
  WorkspaceChange.prototype.renameFile = function(e, n, r, i) {
    this.initDocumentChanges();
    if (void 0 === this._workspaceEdit.documentChanges) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var a;
    if (Fe.is(r) || we.is(r)) {
      a = r;
    } else {
      i = r;
    }
    var s;
    var o;
    if (void 0 === a) {
      s = je.create(e, n, i);
    } else {
      o = we.is(a) ? a : this._changeAnnotations.manage(a);
      s = je.create(e, n, i, o);
    }
    this._workspaceEdit.documentChanges.push(s);
    if (void 0 !== o) {
      return o;
    }
  };
  WorkspaceChange.prototype.deleteFile = function(e, n, r) {
    this.initDocumentChanges();
    if (void 0 === this._workspaceEdit.documentChanges) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var i;
    if (Fe.is(n) || we.is(n)) {
      i = n;
    } else {
      r = n;
    }
    var a;
    var s;
    if (void 0 === i) {
      a = Ve.create(e, r);
    } else {
      s = we.is(i) ? i : this._changeAnnotations.manage(i);
      a = Ve.create(e, r, s);
    }
    this._workspaceEdit.documentChanges.push(a);
    if (void 0 !== s) {
      return s;
    }
  };
}();

var Pe;

!function(e) {
  e.create = function create(e) {
    return {
      uri: e
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.string(n.uri);
  };
}(Pe || (Pe = {}));

var Ge;

!function(e) {
  e.create = function create(e, n) {
    return {
      uri: e,
      version: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.string(n.uri) && kt.integer(n.version);
  };
}(Ge || (Ge = {}));

var Qe;

!function(e) {
  e.create = function create(e, n) {
    return {
      uri: e,
      version: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.string(n.uri) && (null === n.version || kt.integer(n.version));
  };
}(Qe || (Qe = {}));

var Be;

!function(e) {
  e.create = function create(e, n, r, i) {
    return {
      uri: e,
      languageId: n,
      version: r,
      text: i
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.string(n.uri) && kt.string(n.languageId) && kt.integer(n.version) && kt.string(n.text);
  };
}(Be || (Be = {}));

var ze;

!function(e) {
  e.PlainText = "plaintext";
  e.Markdown = "markdown";
  e.is = function is(n) {
    return n === e.PlainText || n === e.Markdown;
  };
}(ze || (ze = {}));

var Ye;

!function(e) {
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(e) && ze.is(n.kind) && kt.string(n.value);
  };
}(Ye || (Ye = {}));

var qe;

!function(e) {
  e.Text = 1;
  e.Method = 2;
  e.Function = 3;
  e.Constructor = 4;
  e.Field = 5;
  e.Variable = 6;
  e.Class = 7;
  e.Interface = 8;
  e.Module = 9;
  e.Property = 10;
  e.Unit = 11;
  e.Value = 12;
  e.Enum = 13;
  e.Keyword = 14;
  e.Snippet = 15;
  e.Color = 16;
  e.File = 17;
  e.Reference = 18;
  e.Folder = 19;
  e.EnumMember = 20;
  e.Constant = 21;
  e.Struct = 22;
  e.Event = 23;
  e.Operator = 24;
  e.TypeParameter = 25;
}(qe || (qe = {}));

var Je;

!function(e) {
  e.PlainText = 1;
  e.Snippet = 2;
}(Je || (Je = {}));

var We;

!function(e) {
  e.Deprecated = 1;
}(We || (We = {}));

var Xe;

!function(e) {
  e.create = function create(e, n, r) {
    return {
      newText: e,
      insert: n,
      replace: r
    };
  };
  e.is = function is(e) {
    var n = e;
    return n && kt.string(n.newText) && me.is(n.insert) && me.is(n.replace);
  };
}(Xe || (Xe = {}));

var Ke;

!function(e) {
  e.asIs = 1;
  e.adjustIndentation = 2;
}(Ke || (Ke = {}));

var He;

!function(e) {
  e.is = function is(e) {
    var n = e;
    return n && (kt.string(n.detail) || void 0 === n.detail) && (kt.string(n.description) || void 0 === n.description);
  };
}(He || (He = {}));

var Ze;

!function(e) {
  e.create = function create(e) {
    return {
      label: e
    };
  };
}(Ze || (Ze = {}));

var et;

!function(e) {
  e.create = function create(e, n) {
    return {
      items: e ? e : [],
      isIncomplete: !!n
    };
  };
}(et || (et = {}));

var tt;

!function(e) {
  e.fromPlainText = function fromPlainText(e) {
    return e.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  };
  e.is = function is(e) {
    var n = e;
    return kt.string(n) || kt.objectLiteral(n) && kt.string(n.language) && kt.string(n.value);
  };
}(tt || (tt = {}));

var nt;

!function(e) {
  e.is = function is(e) {
    var n = e;
    return !!n && kt.objectLiteral(n) && (Ye.is(n.contents) || tt.is(n.contents) || kt.typedArray(n.contents, tt.is)) && (void 0 === e.range || me.is(e.range));
  };
}(nt || (nt = {}));

var rt;

!function(e) {
  e.create = function create(e, n) {
    return n ? {
      label: e,
      documentation: n
    } : {
      label: e
    };
  };
}(rt || (rt = {}));

var it;

!function(e) {
  e.create = function create(e, n) {
    var r = [];
    for (var i = 2; i < arguments.length; i++) {
      r[i - 2] = arguments[i];
    }
    var a = {
      label: e
    };
    if (kt.defined(n)) {
      a.documentation = n;
    }
    if (kt.defined(r)) {
      a.parameters = r;
    } else {
      a.parameters = [];
    }
    return a;
  };
}(it || (it = {}));

var at;

!function(e) {
  e.Text = 1;
  e.Read = 2;
  e.Write = 3;
}(at || (at = {}));

var st;

!function(e) {
  e.create = function create(e, n) {
    var r = {
      range: e
    };
    if (kt.number(n)) {
      r.kind = n;
    }
    return r;
  };
}(st || (st = {}));

var ot;

!function(e) {
  e.File = 1;
  e.Module = 2;
  e.Namespace = 3;
  e.Package = 4;
  e.Class = 5;
  e.Method = 6;
  e.Property = 7;
  e.Field = 8;
  e.Constructor = 9;
  e.Enum = 10;
  e.Interface = 11;
  e.Function = 12;
  e.Variable = 13;
  e.Constant = 14;
  e.String = 15;
  e.Number = 16;
  e.Boolean = 17;
  e.Array = 18;
  e.Object = 19;
  e.Key = 20;
  e.Null = 21;
  e.EnumMember = 22;
  e.Struct = 23;
  e.Event = 24;
  e.Operator = 25;
  e.TypeParameter = 26;
}(ot || (ot = {}));

var lt;

!function(e) {
  e.Deprecated = 1;
}(lt || (lt = {}));

var ut;

!function(e) {
  e.create = function create(e, n, r, i, a) {
    var s = {
      name: e,
      kind: n,
      location: {
        uri: i,
        range: r
      }
    };
    if (a) {
      s.containerName = a;
    }
    return s;
  };
}(ut || (ut = {}));

var ct;

!function(e) {
  e.create = function create(e, n, r, i) {
    return void 0 !== i ? {
      name: e,
      kind: n,
      location: {
        uri: r,
        range: i
      }
    } : {
      name: e,
      kind: n,
      location: {
        uri: r
      }
    };
  };
}(ct || (ct = {}));

var pt;

!function(e) {
  e.create = function create(e, n, r, i, a, s) {
    var o = {
      name: e,
      detail: n,
      kind: r,
      range: i,
      selectionRange: a
    };
    if (void 0 !== s) {
      o.children = s;
    }
    return o;
  };
  e.is = function is(e) {
    var n = e;
    return n && kt.string(n.name) && kt.number(n.kind) && me.is(n.range) && me.is(n.selectionRange) && (void 0 === n.detail || kt.string(n.detail)) && (void 0 === n.deprecated || kt.boolean(n.deprecated)) && (void 0 === n.children || Array.isArray(n.children)) && (void 0 === n.tags || Array.isArray(n.tags));
  };
}(pt || (pt = {}));

var dt;

!function(e) {
  e.Empty = "";
  e.QuickFix = "quickfix";
  e.Refactor = "refactor";
  e.RefactorExtract = "refactor.extract";
  e.RefactorInline = "refactor.inline";
  e.RefactorRewrite = "refactor.rewrite";
  e.Source = "source";
  e.SourceOrganizeImports = "source.organizeImports";
  e.SourceFixAll = "source.fixAll";
}(dt || (dt = {}));

var ft;

!function(e) {
  e.Invoked = 1;
  e.Automatic = 2;
}(ft || (ft = {}));

var vt;

!function(e) {
  e.create = function create(e, n, r) {
    var i = {
      diagnostics: e
    };
    if (null != n) {
      i.only = n;
    }
    if (null != r) {
      i.triggerKind = r;
    }
    return i;
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.typedArray(n.diagnostics, Le.is) && (void 0 === n.only || kt.typedArray(n.only, kt.string)) && (void 0 === n.triggerKind || n.triggerKind === ft.Invoked || n.triggerKind === ft.Automatic);
  };
}(vt || (vt = {}));

var ht;

!function(e) {
  e.create = function create(e, n, r) {
    var i = {
      title: e
    };
    var a = !0;
    if ("string" == typeof n) {
      a = !1;
      i.kind = n;
    } else if (De.is(n)) {
      i.command = n;
    } else {
      i.edit = n;
    }
    if (a && void 0 !== r) {
      i.kind = r;
    }
    return i;
  };
  e.is = function is(e) {
    var n = e;
    return n && kt.string(n.title) && (void 0 === n.diagnostics || kt.typedArray(n.diagnostics, Le.is)) && (void 0 === n.kind || kt.string(n.kind)) && (void 0 !== n.edit || void 0 !== n.command) && (void 0 === n.command || De.is(n.command)) && (void 0 === n.isPreferred || kt.boolean(n.isPreferred)) && (void 0 === n.edit || Ue.is(n.edit));
  };
}(ht || (ht = {}));

var mt;

!function(e) {
  e.create = function create(e, n) {
    var r = {
      range: e
    };
    if (kt.defined(n)) {
      r.data = n;
    }
    return r;
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && me.is(n.range) && (kt.undefined(n.command) || De.is(n.command));
  };
}(mt || (mt = {}));

var gt;

!function(e) {
  e.create = function create(e, n) {
    return {
      tabSize: e,
      insertSpaces: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.uinteger(n.tabSize) && kt.boolean(n.insertSpaces);
  };
}(gt || (gt = {}));

var yt;

!function(e) {
  e.create = function create(e, n, r) {
    return {
      range: e,
      target: n,
      data: r
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && me.is(n.range) && (kt.undefined(n.target) || kt.string(n.target));
  };
}(yt || (yt = {}));

var Tt;

!function(e) {
  e.create = function create(e, n) {
    return {
      range: e,
      parent: n
    };
  };
  e.is = function is(n) {
    var r = n;
    return kt.objectLiteral(r) && me.is(r.range) && (void 0 === r.parent || e.is(r.parent));
  };
}(Tt || (Tt = {}));

var Et;

!function(e) {
  e.namespace = "namespace";
  e.type = "type";
  e.class = "class";
  e.enum = "enum";
  e.interface = "interface";
  e.struct = "struct";
  e.typeParameter = "typeParameter";
  e.parameter = "parameter";
  e.variable = "variable";
  e.property = "property";
  e.enumMember = "enumMember";
  e.event = "event";
  e.function = "function";
  e.method = "method";
  e.macro = "macro";
  e.keyword = "keyword";
  e.modifier = "modifier";
  e.comment = "comment";
  e.string = "string";
  e.number = "number";
  e.regexp = "regexp";
  e.operator = "operator";
  e.decorator = "decorator";
}(Et || (Et = {}));

var Nt;

!function(e) {
  e.declaration = "declaration";
  e.definition = "definition";
  e.readonly = "readonly";
  e.static = "static";
  e.deprecated = "deprecated";
  e.abstract = "abstract";
  e.async = "async";
  e.modification = "modification";
  e.documentation = "documentation";
  e.defaultLibrary = "defaultLibrary";
}(Nt || (Nt = {}));

var It;

!function(e) {
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && (void 0 === n.resultId || "string" == typeof n.resultId) && Array.isArray(n.data) && (0 === n.data.length || "number" == typeof n.data[0]);
  };
}(It || (It = {}));

var bt;

!function(e) {
  e.create = function create(e, n) {
    return {
      range: e,
      text: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return null != n && me.is(n.range) && kt.string(n.text);
  };
}(bt || (bt = {}));

var St;

!function(e) {
  e.create = function create(e, n, r) {
    return {
      range: e,
      variableName: n,
      caseSensitiveLookup: r
    };
  };
  e.is = function is(e) {
    var n = e;
    return null != n && me.is(n.range) && kt.boolean(n.caseSensitiveLookup) && (kt.string(n.variableName) || void 0 === n.variableName);
  };
}(St || (St = {}));

var _t;

!function(e) {
  e.create = function create(e, n) {
    return {
      range: e,
      expression: n
    };
  };
  e.is = function is(e) {
    var n = e;
    return null != n && me.is(n.range) && (kt.string(n.expression) || void 0 === n.expression);
  };
}(_t || (_t = {}));

var At;

!function(e) {
  e.create = function create(e, n) {
    return {
      frameId: e,
      stoppedLocation: n
    };
  };
  e.is = function is(e) {
    return kt.defined(e) && me.is(e.stoppedLocation);
  };
}(At || (At = {}));

var Ot;

!function(e) {
  e.Type = 1;
  e.Parameter = 2;
  e.is = function is(e) {
    return 1 === e || 2 === e;
  };
}(Ot || (Ot = {}));

var Lt;

!function(e) {
  e.create = function create(e) {
    return {
      value: e
    };
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && (void 0 === n.tooltip || kt.string(n.tooltip) || Ye.is(n.tooltip)) && (void 0 === n.location || ge.is(n.location)) && (void 0 === n.command || De.is(n.command));
  };
}(Lt || (Lt = {}));

var Dt;

!function(e) {
  e.create = function create(e, n, r) {
    var i = {
      position: e,
      label: n
    };
    if (void 0 !== r) {
      i.kind = r;
    }
    return i;
  };
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && he.is(n.position) && (kt.string(n.label) || kt.typedArray(n.label, Lt.is)) && (void 0 === n.kind || Ot.is(n.kind)) && void 0 === n.textEdits || kt.typedArray(n.textEdits, xe.is) && (void 0 === n.tooltip || kt.string(n.tooltip) || Ye.is(n.tooltip)) && (void 0 === n.paddingLeft || kt.boolean(n.paddingLeft)) && (void 0 === n.paddingRight || kt.boolean(n.paddingRight));
  };
}(Dt || (Dt = {}));

var xt;

!function(e) {
  e.is = function is(e) {
    var n = e;
    return kt.objectLiteral(n) && de.is(n.uri) && kt.string(n.name);
  };
}(xt || (xt = {}));

var Ft;

!function(e) {
  e.create = function create(e, n, r, i) {
    return new wt(e, n, r, i);
  };
  e.is = function is(e) {
    var n = e;
    return kt.defined(n) && kt.string(n.uri) && (kt.undefined(n.languageId) || kt.string(n.languageId)) && kt.uinteger(n.lineCount) && kt.func(n.getText) && kt.func(n.positionAt) && kt.func(n.offsetAt) ? !0 : !1;
  };
  e.applyEdits = function applyEdits(e, n) {
    var r = e.getText();
    var i = mergeSort(n, (function(e, n) {
      var r = e.range.start.line - n.range.start.line;
      if (0 === r) {
        return e.range.start.character - n.range.start.character;
      }
      return r;
    }));
    var a = r.length;
    for (var s = i.length - 1; s >= 0; s--) {
      var o = i[s];
      var l = e.offsetAt(o.range.start);
      var u = e.offsetAt(o.range.end);
      if (u <= a) {
        r = r.substring(0, l) + o.newText + r.substring(u, r.length);
      } else {
        throw new Error("Overlapping edit");
      }
      a = l;
    }
    return r;
  };
  function mergeSort(e, n) {
    if (e.length <= 1) {
      return e;
    }
    var r = e.length / 2 | 0;
    var i = e.slice(0, r);
    var a = e.slice(r);
    mergeSort(i, n);
    mergeSort(a, n);
    var s = 0;
    var o = 0;
    var l = 0;
    while (s < i.length && o < a.length) {
      if (n(i[s], a[o]) <= 0) {
        e[l++] = i[s++];
      } else {
        e[l++] = a[o++];
      }
    }
    while (s < i.length) {
      e[l++] = i[s++];
    }
    while (o < a.length) {
      e[l++] = a[o++];
    }
    return e;
  }
}(Ft || (Ft = {}));

var wt = function() {
  function FullTextDocument(e, n, r, i) {
    this._uri = e;
    this._languageId = n;
    this._version = r;
    this._content = i;
    this._lineOffsets = void 0;
  }
  Object.defineProperty(FullTextDocument.prototype, "uri", {
    get: function() {
      return this._uri;
    },
    enumerable: !1,
    configurable: !0
  });
  Object.defineProperty(FullTextDocument.prototype, "languageId", {
    get: function() {
      return this._languageId;
    },
    enumerable: !1,
    configurable: !0
  });
  Object.defineProperty(FullTextDocument.prototype, "version", {
    get: function() {
      return this._version;
    },
    enumerable: !1,
    configurable: !0
  });
  FullTextDocument.prototype.getText = function(e) {
    if (e) {
      var n = this.offsetAt(e.start);
      var r = this.offsetAt(e.end);
      return this._content.substring(n, r);
    }
    return this._content;
  };
  FullTextDocument.prototype.update = function(e, n) {
    this._content = e.text;
    this._version = n;
    this._lineOffsets = void 0;
  };
  FullTextDocument.prototype.getLineOffsets = function() {
    if (void 0 === this._lineOffsets) {
      var e = [];
      var n = this._content;
      var r = !0;
      for (var i = 0; i < n.length; i++) {
        if (r) {
          e.push(i);
          r = !1;
        }
        var a = n.charAt(i);
        r = "\r" === a || "\n" === a;
        if ("\r" === a && i + 1 < n.length && "\n" === n.charAt(i + 1)) {
          i++;
        }
      }
      if (r && n.length > 0) {
        e.push(n.length);
      }
      this._lineOffsets = e;
    }
    return this._lineOffsets;
  };
  FullTextDocument.prototype.positionAt = function(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    var n = this.getLineOffsets();
    var r = 0, i = n.length;
    if (0 === i) {
      return he.create(0, e);
    }
    while (r < i) {
      var a = Math.floor((r + i) / 2);
      if (n[a] > e) {
        i = a;
      } else {
        r = a + 1;
      }
    }
    var s = r - 1;
    return he.create(s, e - n[s]);
  };
  FullTextDocument.prototype.offsetAt = function(e) {
    var n = this.getLineOffsets();
    if (e.line >= n.length) {
      return this._content.length;
    } else if (e.line < 0) {
      return 0;
    }
    var r = n[e.line];
    return Math.max(Math.min(r + e.character, e.line + 1 < n.length ? n[e.line + 1] : this._content.length), r);
  };
  Object.defineProperty(FullTextDocument.prototype, "lineCount", {
    get: function() {
      return this.getLineOffsets().length;
    },
    enumerable: !1,
    configurable: !0
  });
  return FullTextDocument;
}();

var kt;

!function(e) {
  var n = Object.prototype.toString;
  e.defined = function defined(e) {
    return void 0 !== e;
  };
  e.undefined = function undefined$1(e) {
    return void 0 === e;
  };
  e.boolean = function boolean(e) {
    return !0 === e || !1 === e;
  };
  e.string = function string(e) {
    return "[object String]" === n.call(e);
  };
  e.number = function number(e) {
    return "[object Number]" === n.call(e);
  };
  e.numberRange = function numberRange(e, r, i) {
    return "[object Number]" === n.call(e) && r <= e && e <= i;
  };
  e.integer = function integer(e) {
    return "[object Number]" === n.call(e) && -2147483648 <= e && e <= 2147483647;
  };
  e.uinteger = function uinteger(e) {
    return "[object Number]" === n.call(e) && 0 <= e && e <= 2147483647;
  };
  e.func = function func(e) {
    return "[object Function]" === n.call(e);
  };
  e.objectLiteral = function objectLiteral(e) {
    return null !== e && "object" == typeof e;
  };
  e.typedArray = function typedArray(e, n) {
    return Array.isArray(e) && e.every(n);
  };
}(kt || (kt = {}));

var Ct;

!function(e) {
  e.Text = 1;
  e.Method = 2;
  e.Function = 3;
  e.Constructor = 4;
  e.Field = 5;
  e.Variable = 6;
  e.Class = 7;
  e.Interface = 8;
  e.Module = 9;
  e.Property = 10;
  e.Unit = 11;
  e.Value = 12;
  e.Enum = 13;
  e.Keyword = 14;
  e.Snippet = 15;
  e.Color = 16;
  e.File = 17;
  e.Reference = 18;
  e.Folder = 19;
  e.EnumMember = 20;
  e.Constant = 21;
  e.Struct = 22;
  e.Event = 23;
  e.Operator = 24;
  e.TypeParameter = 25;
}(Ct || (Ct = {}));

class CharacterStream {
  constructor(e) {
    this._start = 0;
    this._pos = 0;
    this.getStartOfToken = () => this._start;
    this.getCurrentPosition = () => this._pos;
    this.eol = () => this._sourceText.length === this._pos;
    this.sol = () => 0 === this._pos;
    this.peek = () => this._sourceText.charAt(this._pos) || null;
    this.next = () => {
      var e = this._sourceText.charAt(this._pos);
      this._pos++;
      return e;
    };
    this.eat = e => {
      if (this._testNextCharacter(e)) {
        this._start = this._pos;
        this._pos++;
        return this._sourceText.charAt(this._pos - 1);
      }
      return;
    };
    this.eatWhile = e => {
      var n = this._testNextCharacter(e);
      var r = !1;
      if (n) {
        r = n;
        this._start = this._pos;
      }
      while (n) {
        this._pos++;
        n = this._testNextCharacter(e);
        r = !0;
      }
      return r;
    };
    this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
    this.skipToEnd = () => {
      this._pos = this._sourceText.length;
    };
    this.skipTo = e => {
      this._pos = e;
    };
    this.match = (e, n = !0, r = !1) => {
      var i = null;
      var a = null;
      if ("string" == typeof e) {
        a = new RegExp(e, r ? "i" : "g").test(this._sourceText.slice(this._pos, this._pos + e.length));
        i = e;
      } else if (e instanceof RegExp) {
        i = null == (a = this._sourceText.slice(this._pos).match(e)) ? void 0 : a[0];
      }
      if (null != a && ("string" == typeof e || a instanceof Array && this._sourceText.startsWith(a[0], this._pos))) {
        if (n) {
          this._start = this._pos;
          if (i && i.length) {
            this._pos += i.length;
          }
        }
        return a;
      }
      return !1;
    };
    this.backUp = e => {
      this._pos -= e;
    };
    this.column = () => this._pos;
    this.indentation = () => {
      var e = this._sourceText.match(/\s*/);
      var n = 0;
      if (e && 0 !== e.length) {
        var r = e[0];
        var i = 0;
        while (r.length > i) {
          if (9 === r.charCodeAt(i)) {
            n += 2;
          } else {
            n++;
          }
          i++;
        }
      }
      return n;
    };
    this.current = () => this._sourceText.slice(this._start, this._pos);
    this._sourceText = e;
  }
  _testNextCharacter(e) {
    var n = this._sourceText.charAt(this._pos);
    var r = !1;
    if ("string" == typeof e) {
      r = n === e;
    } else {
      r = e instanceof RegExp ? e.test(n) : e(n);
    }
    return r;
  }
}

function opt(e) {
  return {
    ofRule: e
  };
}

function list(e, n) {
  return {
    ofRule: e,
    isList: !0,
    separator: n
  };
}

function t(e, n) {
  return {
    style: n,
    match: n => n.kind === e
  };
}

function p(e, n) {
  return {
    style: n || "punctuation",
    match: n => "Punctuation" === n.kind && n.value === e
  };
}

var isIgnored = e => " " === e || "\t" === e || "," === e || "\n" === e || "\r" === e || "\ufeff" === e || " " === e;

var Rt = {
  Name: /^[_A-Za-z][_0-9A-Za-z]*/,
  Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
  String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
  Comment: /^#.*/
};

var jt = {
  Document: [ list("Definition") ],
  Definition(e) {
    switch (e.value) {
     case "{":
      return "ShortQuery";

     case "query":
      return "Query";

     case "mutation":
      return "Mutation";

     case "subscription":
      return "Subscription";

     case "fragment":
      return d.FRAGMENT_DEFINITION;

     case "schema":
      return "SchemaDef";

     case "scalar":
      return "ScalarDef";

     case "type":
      return "ObjectTypeDef";

     case "interface":
      return "InterfaceDef";

     case "union":
      return "UnionDef";

     case "enum":
      return "EnumDef";

     case "input":
      return "InputDef";

     case "extend":
      return "ExtendDef";

     case "directive":
      return "DirectiveDef";
    }
  },
  ShortQuery: [ "SelectionSet" ],
  Query: [ word("query"), opt(name("def")), opt("VariableDefinitions"), list("Directive"), "SelectionSet" ],
  Mutation: [ word("mutation"), opt(name("def")), opt("VariableDefinitions"), list("Directive"), "SelectionSet" ],
  Subscription: [ word("subscription"), opt(name("def")), opt("VariableDefinitions"), list("Directive"), "SelectionSet" ],
  VariableDefinitions: [ p("("), list("VariableDefinition"), p(")") ],
  VariableDefinition: [ "Variable", p(":"), "Type", opt("DefaultValue") ],
  Variable: [ p("$", "variable"), name("variable") ],
  DefaultValue: [ p("="), "Value" ],
  SelectionSet: [ p("{"), list("Selection"), p("}") ],
  Selection: (e, n) => "..." === e.value ? n.match(/[\s\u00a0,]*(on\b|@|{)/, !1) ? "InlineFragment" : "FragmentSpread" : n.match(/[\s\u00a0,]*:/, !1) ? "AliasedField" : "Field",
  AliasedField: [ name("property"), p(":"), name("qualifier"), opt("Arguments"), list("Directive"), opt("SelectionSet") ],
  Field: [ name("property"), opt("Arguments"), list("Directive"), opt("SelectionSet") ],
  Arguments: [ p("("), list("Argument"), p(")") ],
  Argument: [ name("attribute"), p(":"), "Value" ],
  FragmentSpread: [ p("..."), name("def"), list("Directive") ],
  InlineFragment: [ p("..."), opt("TypeCondition"), list("Directive"), "SelectionSet" ],
  FragmentDefinition: [ word("fragment"), opt(function butNot(e, n) {
    var r = e.match;
    e.match = e => {
      var i = !1;
      if (r) {
        i = r(e);
      }
      return i && n.every((n => n.match && !n.match(e)));
    };
    return e;
  }(name("def"), [ word("on") ])), "TypeCondition", list("Directive"), "SelectionSet" ],
  TypeCondition: [ word("on"), "NamedType" ],
  Value(e) {
    switch (e.kind) {
     case "Number":
      return "NumberValue";

     case "String":
      return "StringValue";

     case "Punctuation":
      switch (e.value) {
       case "[":
        return "ListValue";

       case "{":
        return "ObjectValue";

       case "$":
        return "Variable";

       case "&":
        return "NamedType";
      }
      return null;

     case "Name":
      switch (e.value) {
       case "true":
       case "false":
        return "BooleanValue";
      }
      if ("null" === e.value) {
        return "NullValue";
      }
      return "EnumValue";
    }
  },
  NumberValue: [ t("Number", "number") ],
  StringValue: [ {
    style: "string",
    match: e => "String" === e.kind,
    update(e, n) {
      if (n.value.startsWith('"""')) {
        e.inBlockstring = !n.value.slice(3).endsWith('"""');
      }
    }
  } ],
  BooleanValue: [ t("Name", "builtin") ],
  NullValue: [ t("Name", "keyword") ],
  EnumValue: [ name("string-2") ],
  ListValue: [ p("["), list("Value"), p("]") ],
  ObjectValue: [ p("{"), list("ObjectField"), p("}") ],
  ObjectField: [ name("attribute"), p(":"), "Value" ],
  Type: e => "[" === e.value ? "ListType" : "NonNullType",
  ListType: [ p("["), "Type", p("]"), opt(p("!")) ],
  NonNullType: [ "NamedType", opt(p("!")) ],
  NamedType: [ function type(e) {
    return {
      style: e,
      match: e => "Name" === e.kind,
      update(e, n) {
        var r;
        if (null === (r = e.prevState) || void 0 === r ? void 0 : r.prevState) {
          e.name = n.value;
          e.prevState.prevState.type = n.value;
        }
      }
    };
  }("atom") ],
  Directive: [ p("@", "meta"), name("meta"), opt("Arguments") ],
  DirectiveDef: [ word("directive"), p("@", "meta"), name("meta"), opt("ArgumentsDef"), word("on"), list("DirectiveLocation", p("|")) ],
  InterfaceDef: [ word("interface"), name("atom"), opt("Implements"), list("Directive"), p("{"), list("FieldDef"), p("}") ],
  Implements: [ word("implements"), list("NamedType", p("&")) ],
  DirectiveLocation: [ name("string-2") ],
  SchemaDef: [ word("schema"), list("Directive"), p("{"), list("OperationTypeDef"), p("}") ],
  OperationTypeDef: [ name("keyword"), p(":"), name("atom") ],
  ScalarDef: [ word("scalar"), name("atom"), list("Directive") ],
  ObjectTypeDef: [ word("type"), name("atom"), opt("Implements"), list("Directive"), p("{"), list("FieldDef"), p("}") ],
  FieldDef: [ name("property"), opt("ArgumentsDef"), p(":"), "Type", list("Directive") ],
  ArgumentsDef: [ p("("), list("InputValueDef"), p(")") ],
  InputValueDef: [ name("attribute"), p(":"), "Type", opt("DefaultValue"), list("Directive") ],
  UnionDef: [ word("union"), name("atom"), list("Directive"), p("="), list("UnionMember", p("|")) ],
  UnionMember: [ "NamedType" ],
  EnumDef: [ word("enum"), name("atom"), list("Directive"), p("{"), list("EnumValueDef"), p("}") ],
  EnumValueDef: [ name("string-2"), list("Directive") ],
  InputDef: [ word("input"), name("atom"), list("Directive"), p("{"), list("InputValueDef"), p("}") ],
  ExtendDef: [ word("extend"), "ExtensionDefinition" ],
  ExtensionDefinition(e) {
    switch (e.value) {
     case "schema":
      return d.SCHEMA_EXTENSION;

     case "scalar":
      return d.SCALAR_TYPE_EXTENSION;

     case "type":
      return d.OBJECT_TYPE_EXTENSION;

     case "interface":
      return d.INTERFACE_TYPE_EXTENSION;

     case "union":
      return d.UNION_TYPE_EXTENSION;

     case "enum":
      return d.ENUM_TYPE_EXTENSION;

     case "input":
      return d.INPUT_OBJECT_TYPE_EXTENSION;
    }
  },
  [d.SCHEMA_EXTENSION]: [ "SchemaDef" ],
  [d.SCALAR_TYPE_EXTENSION]: [ "ScalarDef" ],
  [d.OBJECT_TYPE_EXTENSION]: [ "ObjectTypeDef" ],
  [d.INTERFACE_TYPE_EXTENSION]: [ "InterfaceDef" ],
  [d.UNION_TYPE_EXTENSION]: [ "UnionDef" ],
  [d.ENUM_TYPE_EXTENSION]: [ "EnumDef" ],
  [d.INPUT_OBJECT_TYPE_EXTENSION]: [ "InputDef" ]
};

function word(e) {
  return {
    style: "keyword",
    match: n => "Name" === n.kind && n.value === e
  };
}

function name(e) {
  return {
    style: e,
    match: e => "Name" === e.kind,
    update(e, n) {
      e.name = n.value;
    }
  };
}

function onlineParser(e = {
  eatWhitespace: e => e.eatWhile(isIgnored),
  lexRules: Rt,
  parseRules: jt,
  editorConfig: {}
}) {
  return {
    startState() {
      var n = {
        level: 0,
        step: 0,
        name: null,
        kind: null,
        type: null,
        rule: null,
        needsSeparator: !1,
        prevState: null
      };
      pushRule(e.parseRules, n, d.DOCUMENT);
      return n;
    },
    token: (n, r) => function getToken$1(e, n, r) {
      var i;
      if (n.inBlockstring) {
        if (e.match(/.*"""/)) {
          n.inBlockstring = !1;
          return "string";
        }
        e.skipToEnd();
        return "string";
      }
      var {lexRules: a, parseRules: s, eatWhitespace: o, editorConfig: l} = r;
      if (n.rule && 0 === n.rule.length) {
        popRule(n);
      } else if (n.needsAdvance) {
        n.needsAdvance = !1;
        advanceRule(n, !0);
      }
      if (e.sol()) {
        var u = (null == l ? void 0 : l.tabSize) || 2;
        n.indentLevel = Math.floor(e.indentation() / u);
      }
      if (o(e)) {
        return "ws";
      }
      var c = function lex(e, n) {
        var r = Object.keys(e);
        for (var i = 0; i < r.length; i++) {
          var a = n.match(e[r[i]]);
          if (a && a instanceof Array) {
            return {
              kind: r[i],
              value: a[0]
            };
          }
        }
      }(a, e);
      if (!c) {
        if (!e.match(/\S+/)) {
          e.match(/\s/);
        }
        pushRule(Vt, n, "Invalid");
        return "invalidchar";
      }
      if ("Comment" === c.kind) {
        pushRule(Vt, n, "Comment");
        return "comment";
      }
      var d = assign({}, n);
      if ("Punctuation" === c.kind) {
        if (/^[{([]/.test(c.value)) {
          if (void 0 !== n.indentLevel) {
            n.levels = (n.levels || []).concat(n.indentLevel + 1);
          }
        } else if (/^[})\]]/.test(c.value)) {
          var f = n.levels = (n.levels || []).slice(0, -1);
          if (n.indentLevel && f.length > 0 && f.at(-1) < n.indentLevel) {
            n.indentLevel = f.at(-1);
          }
        }
      }
      while (n.rule) {
        var v = "function" == typeof n.rule ? 0 === n.step ? n.rule(c, e) : null : n.rule[n.step];
        if (n.needsSeparator) {
          v = null == v ? void 0 : v.separator;
        }
        if (v) {
          if (v.ofRule) {
            v = v.ofRule;
          }
          if ("string" == typeof v) {
            pushRule(s, n, v);
            continue;
          }
          if (null === (i = v.match) || void 0 === i ? void 0 : i.call(v, c)) {
            if (v.update) {
              v.update(n, c);
            }
            if ("Punctuation" === c.kind) {
              advanceRule(n, !0);
            } else {
              n.needsAdvance = !0;
            }
            return v.style;
          }
        }
        unsuccessful(n);
      }
      assign(n, d);
      pushRule(Vt, n, "Invalid");
      return "invalidchar";
    }(n, r, e)
  };
}

function assign(e, n) {
  var r = Object.keys(n);
  for (var i = 0; i < r.length; i++) {
    e[r[i]] = n[r[i]];
  }
  return e;
}

var Vt = {
  Invalid: [],
  Comment: []
};

function pushRule(e, n, r) {
  if (!e[r]) {
    throw new TypeError("Unknown rule: " + r);
  }
  n.prevState = Object.assign({}, n);
  n.kind = r;
  n.name = null;
  n.type = null;
  n.rule = e[r];
  n.step = 0;
  n.needsSeparator = !1;
}

function popRule(e) {
  if (!e.prevState) {
    return;
  }
  e.kind = e.prevState.kind;
  e.name = e.prevState.name;
  e.type = e.prevState.type;
  e.rule = e.prevState.rule;
  e.step = e.prevState.step;
  e.needsSeparator = e.prevState.needsSeparator;
  e.prevState = e.prevState.prevState;
}

function advanceRule(e, n) {
  var r;
  if (isList(e) && e.rule) {
    var i = e.rule[e.step];
    if (i.separator) {
      var {separator: a} = i;
      e.needsSeparator = !e.needsSeparator;
      if (!e.needsSeparator && a.ofRule) {
        return;
      }
    }
    if (n) {
      return;
    }
  }
  e.needsSeparator = !1;
  e.step++;
  while (e.rule && !(Array.isArray(e.rule) && e.step < e.rule.length)) {
    popRule(e);
    if (e.rule) {
      if (isList(e)) {
        if (null === (r = e.rule) || void 0 === r ? void 0 : r[e.step].separator) {
          e.needsSeparator = !e.needsSeparator;
        }
      } else {
        e.needsSeparator = !1;
        e.step++;
      }
    }
  }
}

function isList(e) {
  var n = Array.isArray(e.rule) && "string" != typeof e.rule[e.step] && e.rule[e.step];
  return n && n.isList;
}

function unsuccessful(e) {
  while (e.rule && (!Array.isArray(e.rule) || !e.rule[e.step].ofRule)) {
    popRule(e);
  }
  if (e.rule) {
    advanceRule(e, !1);
  }
}

var Ut = Object.assign(Object.assign({}, d), {
  ALIASED_FIELD: "AliasedField",
  ARGUMENTS: "Arguments",
  SHORT_QUERY: "ShortQuery",
  QUERY: "Query",
  MUTATION: "Mutation",
  SUBSCRIPTION: "Subscription",
  TYPE_CONDITION: "TypeCondition",
  INVALID: "Invalid",
  COMMENT: "Comment",
  SCHEMA_DEF: "SchemaDef",
  SCALAR_DEF: "ScalarDef",
  OBJECT_TYPE_DEF: "ObjectTypeDef",
  OBJECT_VALUE: "ObjectValue",
  LIST_VALUE: "ListValue",
  INTERFACE_DEF: "InterfaceDef",
  UNION_DEF: "UnionDef",
  ENUM_DEF: "EnumDef",
  ENUM_VALUE: "EnumValue",
  FIELD_DEF: "FieldDef",
  INPUT_DEF: "InputDef",
  INPUT_VALUE_DEF: "InputValueDef",
  ARGUMENTS_DEF: "ArgumentsDef",
  EXTEND_DEF: "ExtendDef",
  EXTENSION_DEFINITION: "ExtensionDefinition",
  DIRECTIVE_DEF: "DirectiveDef",
  IMPLEMENTS: "Implements",
  VARIABLE_DEFINITIONS: "VariableDefinitions",
  TYPE: "Type"
});

var Mt = {
  command: "editor.action.triggerSuggest",
  title: "Suggestions"
};

var collectFragmentDefs = e => {
  var n = [];
  if (e) {
    try {
      visit(parse(e), {
        FragmentDefinition(e) {
          n.push(e);
        }
      });
    } catch (e) {
      return [];
    }
  }
  return n;
};

var $t = [ d.SCHEMA_DEFINITION, d.OPERATION_TYPE_DEFINITION, d.SCALAR_TYPE_DEFINITION, d.OBJECT_TYPE_DEFINITION, d.INTERFACE_TYPE_DEFINITION, d.UNION_TYPE_DEFINITION, d.ENUM_TYPE_DEFINITION, d.INPUT_OBJECT_TYPE_DEFINITION, d.DIRECTIVE_DEFINITION, d.SCHEMA_EXTENSION, d.SCALAR_TYPE_EXTENSION, d.OBJECT_TYPE_EXTENSION, d.INTERFACE_TYPE_EXTENSION, d.UNION_TYPE_EXTENSION, d.ENUM_TYPE_EXTENSION, d.INPUT_OBJECT_TYPE_EXTENSION ];

var hasTypeSystemDefinitions = e => {
  var n = !1;
  if (e) {
    try {
      visit(parse(e), {
        enter(e) {
          if ("Document" === e.kind) {
            return;
          }
          if ($t.includes(e.kind)) {
            n = !0;
            return I;
          }
          return !1;
        }
      });
    } catch (e) {
      return n;
    }
  }
  return n;
};

function getAutocompleteSuggestions(e, n, r, i, a, s) {
  var o;
  var l = Object.assign(Object.assign({}, s), {
    schema: e
  });
  var u = i || getTokenAtPosition(n, r, 1);
  var f = "Invalid" === u.state.kind ? u.state.prevState : u.state;
  var v = (null == s ? void 0 : s.mode) || function getDocumentMode(e, n) {
    if (null == n ? void 0 : n.endsWith(".graphqls")) {
      return Gt.TYPE_SYSTEM;
    }
    return hasTypeSystemDefinitions(e) ? Gt.TYPE_SYSTEM : Gt.EXECUTABLE;
  }(n, null == s ? void 0 : s.uri);
  if (!f) {
    return [];
  }
  var {kind: h, step: m, prevState: g} = f;
  var y = getTypeInfo(e, u.state);
  if (h === Ut.DOCUMENT) {
    if (v === Gt.TYPE_SYSTEM) {
      return function getSuggestionsForTypeSystemDefinitions(e) {
        return hintList$1(e, [ {
          label: "extend",
          kind: Ct.Function
        }, {
          label: "type",
          kind: Ct.Function
        }, {
          label: "interface",
          kind: Ct.Function
        }, {
          label: "union",
          kind: Ct.Function
        }, {
          label: "input",
          kind: Ct.Function
        }, {
          label: "scalar",
          kind: Ct.Function
        }, {
          label: "schema",
          kind: Ct.Function
        } ]);
      }(u);
    }
    return function getSuggestionsForExecutableDefinitions(e) {
      return hintList$1(e, [ {
        label: "query",
        kind: Ct.Function
      }, {
        label: "mutation",
        kind: Ct.Function
      }, {
        label: "subscription",
        kind: Ct.Function
      }, {
        label: "fragment",
        kind: Ct.Function
      }, {
        label: "{",
        kind: Ct.Constructor
      } ]);
    }(u);
  }
  if (h === Ut.EXTEND_DEF) {
    return function getSuggestionsForExtensionDefinitions(e) {
      return hintList$1(e, [ {
        label: "type",
        kind: Ct.Function
      }, {
        label: "interface",
        kind: Ct.Function
      }, {
        label: "union",
        kind: Ct.Function
      }, {
        label: "input",
        kind: Ct.Function
      }, {
        label: "scalar",
        kind: Ct.Function
      }, {
        label: "schema",
        kind: Ct.Function
      } ]);
    }(u);
  }
  if ((null === (o = null == g ? void 0 : g.prevState) || void 0 === o ? void 0 : o.kind) === Ut.EXTENSION_DEFINITION && f.name) {
    return hintList$1(u, []);
  }
  if ((null == g ? void 0 : g.kind) === d.SCALAR_TYPE_EXTENSION) {
    return hintList$1(u, Object.values(e.getTypeMap()).filter(isScalarType).map((e => ({
      label: e.name,
      kind: Ct.Function
    }))));
  }
  if ((null == g ? void 0 : g.kind) === d.OBJECT_TYPE_EXTENSION) {
    return hintList$1(u, Object.values(e.getTypeMap()).filter((e => isObjectType(e) && !e.name.startsWith("__"))).map((e => ({
      label: e.name,
      kind: Ct.Function
    }))));
  }
  if ((null == g ? void 0 : g.kind) === d.INTERFACE_TYPE_EXTENSION) {
    return hintList$1(u, Object.values(e.getTypeMap()).filter(isInterfaceType).map((e => ({
      label: e.name,
      kind: Ct.Function
    }))));
  }
  if ((null == g ? void 0 : g.kind) === d.UNION_TYPE_EXTENSION) {
    return hintList$1(u, Object.values(e.getTypeMap()).filter(isUnionType).map((e => ({
      label: e.name,
      kind: Ct.Function
    }))));
  }
  if ((null == g ? void 0 : g.kind) === d.ENUM_TYPE_EXTENSION) {
    return hintList$1(u, Object.values(e.getTypeMap()).filter((e => isEnumType(e) && !e.name.startsWith("__"))).map((e => ({
      label: e.name,
      kind: Ct.Function
    }))));
  }
  if ((null == g ? void 0 : g.kind) === d.INPUT_OBJECT_TYPE_EXTENSION) {
    return hintList$1(u, Object.values(e.getTypeMap()).filter(isInputObjectType).map((e => ({
      label: e.name,
      kind: Ct.Function
    }))));
  }
  if (h === Ut.IMPLEMENTS || h === Ut.NAMED_TYPE && (null == g ? void 0 : g.kind) === Ut.IMPLEMENTS) {
    return function getSuggestionsForImplements(e, n, r, i, a) {
      if (n.needsSeparator) {
        return [];
      }
      var s = r.getTypeMap();
      var o = objectValues(s).filter(isInterfaceType);
      var l = o.map((({name: e}) => e));
      var u = new Set;
      runOnlineParser$1(i, ((e, n) => {
        var i, s, o, c, d;
        if (n.name) {
          if (n.kind === Ut.INTERFACE_DEF && !l.includes(n.name)) {
            u.add(n.name);
          }
          if (n.kind === Ut.NAMED_TYPE && (null === (i = n.prevState) || void 0 === i ? void 0 : i.kind) === Ut.IMPLEMENTS) {
            if (a.interfaceDef) {
              var f = null === (s = a.interfaceDef) || void 0 === s ? void 0 : s.getInterfaces().find((({name: e}) => e === n.name));
              if (f) {
                return;
              }
              var v = r.getType(n.name);
              var h = null === (o = a.interfaceDef) || void 0 === o ? void 0 : o.toConfig();
              a.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, h), {
                interfaces: [ ...h.interfaces, v || new GraphQLInterfaceType({
                  name: n.name,
                  fields: {}
                }) ]
              }));
            } else if (a.objectTypeDef) {
              var m = null === (c = a.objectTypeDef) || void 0 === c ? void 0 : c.getInterfaces().find((({name: e}) => e === n.name));
              if (m) {
                return;
              }
              var g = r.getType(n.name);
              var y = null === (d = a.objectTypeDef) || void 0 === d ? void 0 : d.toConfig();
              a.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, y), {
                interfaces: [ ...y.interfaces, g || new GraphQLInterfaceType({
                  name: n.name,
                  fields: {}
                }) ]
              }));
            }
          }
        }
      }));
      var c = a.interfaceDef || a.objectTypeDef;
      var d = ((null == c ? void 0 : c.getInterfaces()) || []).map((({name: e}) => e));
      var f = o.concat([ ...u ].map((e => ({
        name: e
      })))).filter((({name: e}) => e !== (null == c ? void 0 : c.name) && !d.includes(e)));
      return hintList$1(e, f.map((e => {
        var n = {
          label: e.name,
          kind: Ct.Interface,
          type: e
        };
        if (null == e ? void 0 : e.description) {
          n.documentation = e.description;
        }
        return n;
      })));
    }(u, f, e, n, y);
  }
  if (h === Ut.SELECTION_SET || h === Ut.FIELD || h === Ut.ALIASED_FIELD) {
    return function getSuggestionsForFieldNames(e, n, r) {
      var i;
      if (n.parentType) {
        var {parentType: a} = n;
        var s = [];
        if ("getFields" in a) {
          s = objectValues(a.getFields());
        }
        if (isCompositeType(a)) {
          s.push(W);
        }
        if (a === (null === (i = null == r ? void 0 : r.schema) || void 0 === i ? void 0 : i.getQueryType())) {
          s.push(q, J);
        }
        return hintList$1(e, s.map(((e, n) => {
          var i;
          var a = {
            sortText: String(n) + e.name,
            label: e.name,
            detail: String(e.type),
            documentation: null !== (i = e.description) && void 0 !== i ? i : void 0,
            deprecated: Boolean(e.deprecationReason),
            isDeprecated: Boolean(e.deprecationReason),
            deprecationReason: e.deprecationReason,
            kind: Ct.Field,
            type: e.type
          };
          if (null == r ? void 0 : r.fillLeafsOnComplete) {
            var s = getInsertText(e);
            if (s) {
              a.insertText = e.name + s;
              a.insertTextFormat = Je.Snippet;
              a.command = Mt;
            }
          }
          return a;
        })));
      }
      return [];
    }(u, y, l);
  }
  if (h === Ut.ARGUMENTS || h === Ut.ARGUMENT && 0 === m) {
    var {argDefs: T} = y;
    if (T) {
      return hintList$1(u, T.map((e => {
        var n;
        return {
          label: e.name,
          insertText: e.name + ": ",
          command: Mt,
          detail: String(e.type),
          documentation: null !== (n = e.description) && void 0 !== n ? n : void 0,
          kind: Ct.Variable,
          type: e.type
        };
      })));
    }
  }
  if ((h === Ut.OBJECT_VALUE || h === Ut.OBJECT_FIELD && 0 === m) && y.objectFieldDefs) {
    var E = objectValues(y.objectFieldDefs);
    var N = h === Ut.OBJECT_VALUE ? Ct.Value : Ct.Field;
    return hintList$1(u, E.map((e => {
      var n;
      return {
        label: e.name,
        detail: String(e.type),
        documentation: null !== (n = e.description) && void 0 !== n ? n : void 0,
        kind: N,
        type: e.type
      };
    })));
  }
  if (h === Ut.ENUM_VALUE || h === Ut.LIST_VALUE && 1 === m || h === Ut.OBJECT_FIELD && 2 === m || h === Ut.ARGUMENT && 2 === m) {
    return function getSuggestionsForInputValues(e, n, r, i) {
      var a = getNamedType(n.inputType);
      var s = getVariableCompletions(r, i, e).filter((e => e.detail === a.name));
      if (a instanceof GraphQLEnumType) {
        return hintList$1(e, a.getValues().map((e => {
          var n;
          return {
            label: e.name,
            detail: String(a),
            documentation: null !== (n = e.description) && void 0 !== n ? n : void 0,
            deprecated: Boolean(e.deprecationReason),
            isDeprecated: Boolean(e.deprecationReason),
            deprecationReason: e.deprecationReason,
            kind: Ct.EnumMember,
            type: a
          };
        })).concat(s));
      }
      if (a === D) {
        return hintList$1(e, s.concat([ {
          label: "true",
          detail: String(D),
          documentation: "Not false.",
          kind: Ct.Variable,
          type: D
        }, {
          label: "false",
          detail: String(D),
          documentation: "Not true.",
          kind: Ct.Variable,
          type: D
        } ]));
      }
      return s;
    }(u, y, n, e);
  }
  if (h === Ut.VARIABLE && 1 === m) {
    var I = getNamedType(y.inputType);
    return hintList$1(u, getVariableCompletions(n, e, u).filter((e => e.detail === (null == I ? void 0 : I.name))));
  }
  if (h === Ut.TYPE_CONDITION && 1 === m || h === Ut.NAMED_TYPE && null != g && g.kind === Ut.TYPE_CONDITION) {
    return function getSuggestionsForFragmentTypeConditions(e, n, r, i) {
      var a;
      if (n.parentType) {
        if (isAbstractType(n.parentType)) {
          var s = function assertAbstractType(e) {
            if (!isAbstractType(e)) {
              throw new Error(`Expected ${inspect(e)} to be a GraphQL abstract type.`);
            }
            return e;
          }(n.parentType);
          var o = r.getPossibleTypes(s);
          var l = Object.create(null);
          for (var u of o) {
            for (var c of u.getInterfaces()) {
              l[c.name] = c;
            }
          }
          a = o.concat(objectValues(l));
        } else {
          a = [ n.parentType ];
        }
      } else {
        a = objectValues(r.getTypeMap()).filter((e => isCompositeType(e) && !e.name.startsWith("__")));
      }
      return hintList$1(e, a.map((e => {
        var n = getNamedType(e);
        return {
          label: String(e),
          documentation: (null == n ? void 0 : n.description) || "",
          kind: Ct.Field
        };
      })));
    }(u, y, e);
  }
  if (h === Ut.FRAGMENT_SPREAD && 1 === m) {
    return function getSuggestionsForFragmentSpread$1(e, n, r, i, a) {
      if (!i) {
        return [];
      }
      var s = r.getTypeMap();
      var o = getDefinitionState(e.state);
      var l = function getFragmentDefinitions(e) {
        var n = [];
        runOnlineParser$1(e, ((e, r) => {
          if (r.kind === Ut.FRAGMENT_DEFINITION && r.name && r.type) {
            n.push({
              kind: Ut.FRAGMENT_DEFINITION,
              name: {
                kind: d.NAME,
                value: r.name
              },
              selectionSet: {
                kind: Ut.SELECTION_SET,
                selections: []
              },
              typeCondition: {
                kind: Ut.NAMED_TYPE,
                name: {
                  kind: d.NAME,
                  value: r.type
                }
              }
            });
          }
        }));
        return n;
      }(i);
      if (a && a.length > 0) {
        l.push(...a);
      }
      var u = l.filter((e => s[e.typeCondition.name.value] && !(o && o.kind === Ut.FRAGMENT_DEFINITION && o.name === e.name.value) && isCompositeType(n.parentType) && isCompositeType(s[e.typeCondition.name.value]) && doTypesOverlap(r, n.parentType, s[e.typeCondition.name.value])));
      return hintList$1(e, u.map((e => ({
        label: e.name.value,
        detail: String(s[e.typeCondition.name.value]),
        documentation: `fragment ${e.name.value} on ${e.typeCondition.name.value}`,
        kind: Ct.Field,
        type: s[e.typeCondition.name.value]
      }))));
    }(u, y, e, n, Array.isArray(a) ? a : collectFragmentDefs(a));
  }
  var b = unwrapType(f);
  if (v === Gt.TYPE_SYSTEM && !b.needsAdvance && h === Ut.NAMED_TYPE || h === Ut.LIST_TYPE) {
    if (b.kind === Ut.FIELD_DEF) {
      return hintList$1(u, Object.values(e.getTypeMap()).filter((e => isOutputType(e) && !e.name.startsWith("__"))).map((e => ({
        label: e.name,
        kind: Ct.Function
      }))));
    }
    if (b.kind === Ut.INPUT_VALUE_DEF) {
      return hintList$1(u, Object.values(e.getTypeMap()).filter((e => isInputType(e) && !e.name.startsWith("__"))).map((e => ({
        label: e.name,
        kind: Ct.Function
      }))));
    }
  }
  if (h === Ut.VARIABLE_DEFINITION && 2 === m || h === Ut.LIST_TYPE && 1 === m || h === Ut.NAMED_TYPE && g && (g.kind === Ut.VARIABLE_DEFINITION || g.kind === Ut.LIST_TYPE || g.kind === Ut.NON_NULL_TYPE)) {
    return function getSuggestionsForVariableDefinition(e, n, r) {
      var i = n.getTypeMap();
      var a = objectValues(i).filter(isInputType);
      return hintList$1(e, a.map((e => ({
        label: e.name,
        documentation: e.description,
        kind: Ct.Variable
      }))));
    }(u, e);
  }
  if (h === Ut.DIRECTIVE) {
    return function getSuggestionsForDirective(e, n, r, i) {
      var a;
      if (null === (a = n.prevState) || void 0 === a ? void 0 : a.kind) {
        var s = r.getDirectives().filter((e => function canUseDirective(e, n) {
          if (!(null == e ? void 0 : e.kind)) {
            return !1;
          }
          var {kind: r, prevState: i} = e;
          var {locations: a} = n;
          switch (r) {
           case Ut.QUERY:
            return a.includes(c.QUERY);

           case Ut.MUTATION:
            return a.includes(c.MUTATION);

           case Ut.SUBSCRIPTION:
            return a.includes(c.SUBSCRIPTION);

           case Ut.FIELD:
           case Ut.ALIASED_FIELD:
            return a.includes(c.FIELD);

           case Ut.FRAGMENT_DEFINITION:
            return a.includes(c.FRAGMENT_DEFINITION);

           case Ut.FRAGMENT_SPREAD:
            return a.includes(c.FRAGMENT_SPREAD);

           case Ut.INLINE_FRAGMENT:
            return a.includes(c.INLINE_FRAGMENT);

           case Ut.SCHEMA_DEF:
            return a.includes(c.SCHEMA);

           case Ut.SCALAR_DEF:
            return a.includes(c.SCALAR);

           case Ut.OBJECT_TYPE_DEF:
            return a.includes(c.OBJECT);

           case Ut.FIELD_DEF:
            return a.includes(c.FIELD_DEFINITION);

           case Ut.INTERFACE_DEF:
            return a.includes(c.INTERFACE);

           case Ut.UNION_DEF:
            return a.includes(c.UNION);

           case Ut.ENUM_DEF:
            return a.includes(c.ENUM);

           case Ut.ENUM_VALUE:
            return a.includes(c.ENUM_VALUE);

           case Ut.INPUT_DEF:
            return a.includes(c.INPUT_OBJECT);

           case Ut.INPUT_VALUE_DEF:
            switch (null == i ? void 0 : i.kind) {
             case Ut.ARGUMENTS_DEF:
              return a.includes(c.ARGUMENT_DEFINITION);

             case Ut.INPUT_DEF:
              return a.includes(c.INPUT_FIELD_DEFINITION);
            }
          }
          return !1;
        }(n.prevState, e)));
        return hintList$1(e, s.map((e => ({
          label: e.name,
          documentation: e.description || "",
          kind: Ct.Function
        }))));
      }
      return [];
    }(u, f, e);
  }
  return [];
}

var Pt = " {\n  $1\n}";

var getInsertText = e => {
  var {type: n} = e;
  if (isCompositeType(n)) {
    return Pt;
  }
  if (isListType(n) && isCompositeType(n.ofType)) {
    return Pt;
  }
  if (isNonNullType(n)) {
    if (isCompositeType(n.ofType)) {
      return Pt;
    }
    if (isListType(n.ofType) && isCompositeType(n.ofType.ofType)) {
      return Pt;
    }
  }
  return null;
};

var getParentDefinition$1 = (e, n) => {
  var r, i, a, s, o, l, u, c, d, f;
  if ((null === (r = e.prevState) || void 0 === r ? void 0 : r.kind) === n) {
    return e.prevState;
  }
  if ((null === (a = null === (i = e.prevState) || void 0 === i ? void 0 : i.prevState) || void 0 === a ? void 0 : a.kind) === n) {
    return e.prevState.prevState;
  }
  if ((null === (l = null === (o = null === (s = e.prevState) || void 0 === s ? void 0 : s.prevState) || void 0 === o ? void 0 : o.prevState) || void 0 === l ? void 0 : l.kind) === n) {
    return e.prevState.prevState.prevState;
  }
  if ((null === (f = null === (d = null === (c = null === (u = e.prevState) || void 0 === u ? void 0 : u.prevState) || void 0 === c ? void 0 : c.prevState) || void 0 === d ? void 0 : d.prevState) || void 0 === f ? void 0 : f.kind) === n) {
    return e.prevState.prevState.prevState.prevState;
  }
};

function getVariableCompletions(e, n, r) {
  var i = null;
  var a;
  var s = Object.create({});
  runOnlineParser$1(e, ((e, o) => {
    if ((null == o ? void 0 : o.kind) === Ut.VARIABLE && o.name) {
      i = o.name;
    }
    if ((null == o ? void 0 : o.kind) === Ut.NAMED_TYPE && i) {
      var l = getParentDefinition$1(o, Ut.TYPE);
      if (null == l ? void 0 : l.type) {
        a = n.getType(null == l ? void 0 : l.type);
      }
    }
    if (i && a && !s[i]) {
      s[i] = {
        detail: a.toString(),
        insertText: "$" === r.string ? i : "$" + i,
        label: i,
        type: a,
        kind: Ct.Variable
      };
      i = null;
      a = null;
    }
  }));
  return objectValues(s);
}

function getTokenAtPosition(e, n, r = 0) {
  var i = null;
  var a = null;
  var s = null;
  var o = runOnlineParser$1(e, ((e, o, l, u) => {
    if (u !== n.line || e.getCurrentPosition() + r < n.character + 1) {
      return;
    }
    i = l;
    a = Object.assign({}, o);
    s = e.current();
    return "BREAK";
  }));
  return {
    start: o.start,
    end: o.end,
    string: s || o.string,
    state: a || o.state,
    style: i || o.style
  };
}

function runOnlineParser$1(e, n) {
  var r = e.split("\n");
  var i = onlineParser();
  var a = i.startState();
  var s = "";
  var o = new CharacterStream("");
  for (var l = 0; l < r.length; l++) {
    o = new CharacterStream(r[l]);
    while (!o.eol()) {
      if ("BREAK" === n(o, a, s = i.token(o, a), l)) {
        break;
      }
    }
    n(o, a, s, l);
    if (!a.kind) {
      a = i.startState();
    }
  }
  return {
    start: o.getStartOfToken(),
    end: o.getCurrentPosition(),
    string: o.current(),
    state: a,
    style: s
  };
}

function getTypeInfo(e, n) {
  var r;
  var i;
  var a;
  var s;
  var o;
  var l;
  var u;
  var c;
  var d;
  var f;
  var v;
  forEachState(n, (n => {
    var h;
    switch (n.kind) {
     case Ut.QUERY:
     case "ShortQuery":
      f = e.getQueryType();
      break;

     case Ut.MUTATION:
      f = e.getMutationType();
      break;

     case Ut.SUBSCRIPTION:
      f = e.getSubscriptionType();
      break;

     case Ut.INLINE_FRAGMENT:
     case Ut.FRAGMENT_DEFINITION:
      if (n.type) {
        f = e.getType(n.type);
      }
      break;

     case Ut.FIELD:
     case Ut.ALIASED_FIELD:
      if (!f || !n.name) {
        o = null;
      } else {
        o = d ? getFieldDef(e, d, n.name) : null;
        f = o ? o.type : null;
      }
      break;

     case Ut.SELECTION_SET:
      d = getNamedType(f);
      break;

     case Ut.DIRECTIVE:
      a = n.name ? e.getDirective(n.name) : null;
      break;

     case Ut.INTERFACE_DEF:
      if (n.name) {
        u = null;
        v = new GraphQLInterfaceType({
          name: n.name,
          interfaces: [],
          fields: {}
        });
      }
      break;

     case Ut.OBJECT_TYPE_DEF:
      if (n.name) {
        v = null;
        u = new GraphQLObjectType({
          name: n.name,
          interfaces: [],
          fields: {}
        });
      }
      break;

     case Ut.ARGUMENTS:
      if (n.prevState) {
        switch (n.prevState.kind) {
         case Ut.FIELD:
          i = o && o.args;
          break;

         case Ut.DIRECTIVE:
          i = a && a.args;
          break;

         case Ut.ALIASED_FIELD:
          var m = null === (h = n.prevState) || void 0 === h ? void 0 : h.name;
          if (!m) {
            i = null;
            break;
          }
          var g = d ? getFieldDef(e, d, m) : null;
          if (!g) {
            i = null;
            break;
          }
          i = g.args;
          break;

         default:
          i = null;
        }
      } else {
        i = null;
      }
      break;

     case Ut.ARGUMENT:
      if (i) {
        for (var y = 0; y < i.length; y++) {
          if (i[y].name === n.name) {
            r = i[y];
            break;
          }
        }
      }
      l = null == r ? void 0 : r.type;
      break;

     case Ut.ENUM_VALUE:
      var T = getNamedType(l);
      s = T instanceof GraphQLEnumType ? T.getValues().find((e => e.value === n.name)) : null;
      break;

     case Ut.LIST_VALUE:
      var E = getNullableType(l);
      l = E instanceof GraphQLList ? E.ofType : null;
      break;

     case Ut.OBJECT_VALUE:
      var N = getNamedType(l);
      c = N instanceof GraphQLInputObjectType ? N.getFields() : null;
      break;

     case Ut.OBJECT_FIELD:
      var I = n.name && c ? c[n.name] : null;
      l = null == I ? void 0 : I.type;
      break;

     case Ut.NAMED_TYPE:
      if (n.name) {
        f = e.getType(n.name);
      }
    }
  }));
  return {
    argDef: r,
    argDefs: i,
    directiveDef: a,
    enumValue: s,
    fieldDef: o,
    inputType: l,
    objectFieldDefs: c,
    parentType: d,
    type: f,
    interfaceDef: v,
    objectTypeDef: u
  };
}

var Gt;

!function(e) {
  e.TYPE_SYSTEM = "TYPE_SYSTEM";
  e.EXECUTABLE = "EXECUTABLE";
}(Gt || (Gt = {}));

function unwrapType(e) {
  if (e.prevState && e.kind && [ Ut.NAMED_TYPE, Ut.LIST_TYPE, Ut.TYPE, Ut.NON_NULL_TYPE ].includes(e.kind)) {
    return unwrapType(e.prevState);
  }
  return e;
}

function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}

class Range {
  constructor(e, n) {
    this.containsPosition = e => {
      if (this.start.line === e.line) {
        return this.start.character <= e.character;
      }
      if (this.end.line === e.line) {
        return this.end.character >= e.character;
      }
      return this.start.line <= e.line && this.end.line >= e.line;
    };
    this.start = e;
    this.end = n;
  }
  setStart(e, n) {
    this.start = new Position(e, n);
  }
  setEnd(e, n) {
    this.end = new Position(e, n);
  }
}

class Position {
  constructor(e, n) {
    this.lessThanOrEqualTo = e => this.line < e.line || this.line === e.line && this.character <= e.character;
    this.line = e;
    this.character = n;
  }
  setLine(e) {
    this.line = e;
  }
  setCharacter(e) {
    this.character = e;
  }
}

var Qt = [ LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule ];

var Bt = {
  ["Error"]: 1,
  ["Warning"]: 2,
  ["Information"]: 3,
  ["Hint"]: 4
};

var invariant = (e, n) => {
  if (!e) {
    throw new Error(n);
  }
};

function getDiagnostics(e, n = null, r, i, a) {
  var s, o;
  var l = null;
  var u = "";
  if (a) {
    u = "string" == typeof a ? a : a.reduce(((e, n) => e + print$1(n) + "\n\n"), "");
  }
  var c = u ? `${e}\n\n${u}` : e;
  try {
    l = parse(c);
  } catch (e) {
    if (e instanceof GraphQLError) {
      var f = function getRange(e, n) {
        var r = onlineParser();
        var i = r.startState();
        var a = n.split("\n");
        invariant(a.length >= e.line, "Query text must have more lines than where the error happened");
        var s = null;
        for (var o = 0; o < e.line; o++) {
          s = new CharacterStream(a[o]);
          while (!s.eol()) {
            if ("invalidchar" === r.token(s, i)) {
              break;
            }
          }
        }
        invariant(s, "Expected Parser stream to be available.");
        var l = e.line - 1;
        var u = s.getStartOfToken();
        var c = s.getCurrentPosition();
        return new Range(new Position(l, u), new Position(l, c));
      }(null !== (o = null === (s = e.locations) || void 0 === s ? void 0 : s[0]) && void 0 !== o ? o : {
        line: 0,
        column: 0
      }, c);
      return [ {
        severity: Bt.Error,
        message: e.message,
        source: "GraphQL: Syntax",
        range: f
      } ];
    }
    throw e;
  }
  return function validateQuery(e, n = null, r, i) {
    if (!n) {
      return [];
    }
    var a = function validateWithCustomRules(e, n, r, i, a) {
      var s = Z.filter((e => {
        if (e === NoUnusedFragmentsRule || e === ExecutableDefinitionsRule) {
          return !1;
        }
        if (i && e === KnownFragmentNamesRule) {
          return !1;
        }
        return !0;
      }));
      if (r) {
        Array.prototype.push.apply(s, r);
      }
      if (a) {
        Array.prototype.push.apply(s, Qt);
      }
      return validate(e, n, s).filter((e => {
        if (e.message.includes("Unknown directive") && e.nodes) {
          var n = e.nodes[0];
          if (n && n.kind === d.DIRECTIVE) {
            var r = n.name.value;
            if ("arguments" === r || "argumentDefinitions" === r) {
              return !1;
            }
          }
        }
        return !0;
      }));
    }(n, e, r, i).flatMap((e => annotations(e, Bt.Error, "Validation")));
    var s = validate(n, e, [ NoDeprecatedCustomRule ]).flatMap((e => annotations(e, Bt.Warning, "Deprecation")));
    return a.concat(s);
  }(l, n, r, i);
}

function annotations(e, n, r) {
  if (!e.nodes) {
    return [];
  }
  var i = [];
  for (var [a, s] of e.nodes.entries()) {
    var o = "Variable" !== s.kind && "name" in s && void 0 !== s.name ? s.name : "variable" in s && void 0 !== s.variable ? s.variable : s;
    if (o) {
      invariant(e.locations, "GraphQL validation error requires locations.");
      var l = e.locations[a];
      var u = getLocation(o);
      var c = l.column + (u.end - u.start);
      i.push({
        source: `GraphQL: ${r}`,
        message: e.message,
        severity: n,
        range: new Range(new Position(l.line - 1, l.column - 1), new Position(l.line - 1, c))
      });
    }
  }
  return i;
}

function getLocation(e) {
  var n = e.loc;
  invariant(n, "Expected ASTNode to have a location.");
  return n;
}

function getHoverInformation(e, n, r, i, a) {
  var s = i || getTokenAtPosition(n, r);
  if (!e || !s || !s.state) {
    return "";
  }
  var {kind: o, step: l} = s.state;
  var u = getTypeInfo(e, s.state);
  var c = Object.assign(Object.assign({}, a), {
    schema: e
  });
  if ("Field" === o && 0 === l && u.fieldDef || "AliasedField" === o && 2 === l && u.fieldDef) {
    var d = [];
    renderMdCodeStart(d, c);
    !function renderField(e, n, r) {
      renderQualifiedField(e, n, r);
      renderTypeAnnotation(e, n, r, n.type);
    }(d, u, c);
    renderMdCodeEnd(d, c);
    renderDescription(d, c, u.fieldDef);
    return d.join("").trim();
  }
  if ("Directive" === o && 1 === l && u.directiveDef) {
    var f = [];
    renderMdCodeStart(f, c);
    renderDirective(f, u);
    renderMdCodeEnd(f, c);
    renderDescription(f, c, u.directiveDef);
    return f.join("").trim();
  }
  if ("Argument" === o && 0 === l && u.argDef) {
    var v = [];
    renderMdCodeStart(v, c);
    !function renderArg(e, n, r) {
      if (n.directiveDef) {
        renderDirective(e, n);
      } else if (n.fieldDef) {
        renderQualifiedField(e, n, r);
      }
      if (!n.argDef) {
        return;
      }
      var {name: i} = n.argDef;
      text(e, "(");
      text(e, i);
      renderTypeAnnotation(e, n, r, n.inputType);
      text(e, ")");
    }(v, u, c);
    renderMdCodeEnd(v, c);
    renderDescription(v, c, u.argDef);
    return v.join("").trim();
  }
  if ("EnumValue" === o && u.enumValue && "description" in u.enumValue) {
    var h = [];
    renderMdCodeStart(h, c);
    !function renderEnumValue(e, n, r) {
      if (!n.enumValue) {
        return;
      }
      var {name: i} = n.enumValue;
      renderType(e, n, r, n.inputType);
      text(e, ".");
      text(e, i);
    }(h, u, c);
    renderMdCodeEnd(h, c);
    renderDescription(h, c, u.enumValue);
    return h.join("").trim();
  }
  if ("NamedType" === o && u.type && "description" in u.type) {
    var m = [];
    renderMdCodeStart(m, c);
    renderType(m, u, c, u.type);
    renderMdCodeEnd(m, c);
    renderDescription(m, c, u.type);
    return m.join("").trim();
  }
  return "";
}

function renderMdCodeStart(e, n) {
  if (n.useMarkdown) {
    text(e, "```graphql\n");
  }
}

function renderMdCodeEnd(e, n) {
  if (n.useMarkdown) {
    text(e, "\n```");
  }
}

function renderQualifiedField(e, n, r) {
  if (!n.fieldDef) {
    return;
  }
  var i = n.fieldDef.name;
  if ("__" !== i.slice(0, 2)) {
    renderType(e, n, r, n.parentType);
    text(e, ".");
  }
  text(e, i);
}

function renderDirective(e, n, r) {
  if (!n.directiveDef) {
    return;
  }
  text(e, "@" + n.directiveDef.name);
}

function renderTypeAnnotation(e, n, r, i) {
  text(e, ": ");
  renderType(e, n, r, i);
}

function renderType(e, n, r, i) {
  if (!i) {
    return;
  }
  if (i instanceof GraphQLNonNull) {
    renderType(e, n, r, i.ofType);
    text(e, "!");
  } else if (i instanceof GraphQLList) {
    text(e, "[");
    renderType(e, n, r, i.ofType);
    text(e, "]");
  } else {
    text(e, i.name);
  }
}

function renderDescription(e, n, r) {
  if (!r) {
    return;
  }
  var i = "string" == typeof r.description ? r.description : null;
  if (i) {
    text(e, "\n\n");
    text(e, i);
  }
  !function renderDeprecation(e, n, r) {
    if (!r) {
      return;
    }
    var i = r.deprecationReason || null;
    if (!i) {
      return;
    }
    text(e, "\n\n");
    text(e, "Deprecated: ");
    text(e, i);
  }(e, 0, r);
}

function text(e, n) {
  e.push(n);
}

var hasItems = e => !(!e || !e.length);

var zt = {
  OperationDefinition(e) {
    if ("query" === e.operation && !e.name && !hasItems(e.variableDefinitions) && !hasItems(e.directives)) {
      return zt.SelectionSet(e.selectionSet);
    }
    var n = e.operation;
    if (e.name) {
      n += " " + e.name.value;
    }
    if (hasItems(e.variableDefinitions)) {
      if (!e.name) {
        n += " ";
      }
      n += "(" + e.variableDefinitions.map(zt.VariableDefinition).join(", ") + ")";
    }
    if (hasItems(e.directives)) {
      n += " " + e.directives.map(zt.Directive).join(" ");
    }
    return n + " " + zt.SelectionSet(e.selectionSet);
  },
  VariableDefinition(e) {
    var n = zt.Variable(e.variable) + ": " + print(e.type);
    if (e.defaultValue) {
      n += " = " + print(e.defaultValue);
    }
    if (hasItems(e.directives)) {
      n += " " + e.directives.map(zt.Directive).join(" ");
    }
    return n;
  },
  Field(e) {
    var n = (e.alias ? e.alias.value + ": " : "") + e.name.value;
    if (hasItems(e.arguments)) {
      var r = e.arguments.map(zt.Argument);
      var i = n + "(" + r.join(", ") + ")";
      n = i.length > 80 ? n + "(\n  " + r.join("\n").replace(/\n/g, "\n  ") + "\n)" : i;
    }
    if (hasItems(e.directives)) {
      n += " " + e.directives.map(zt.Directive).join(" ");
    }
    return e.selectionSet ? n + " " + zt.SelectionSet(e.selectionSet) : n;
  },
  StringValue: e => e.block ? function printBlockString(e) {
    return '"""\n' + e.replace(/"""/g, '\\"""') + '\n"""';
  }(e.value) : function printString(e) {
    return JSON.stringify(e);
  }(e.value),
  BooleanValue: e => "" + e.value,
  NullValue: e => "null",
  IntValue: e => e.value,
  FloatValue: e => e.value,
  EnumValue: e => e.value,
  Name: e => e.value,
  Variable: e => "$" + e.name.value,
  ListValue: e => "[" + e.values.map(print).join(", ") + "]",
  ObjectValue: e => "{" + e.fields.map(zt.ObjectField).join(", ") + "}",
  ObjectField: e => e.name.value + ": " + print(e.value),
  Document: e => hasItems(e.definitions) ? e.definitions.map(print).join("\n\n") : "",
  SelectionSet: e => "{\n  " + e.selections.map(print).join("\n").replace(/\n/g, "\n  ") + "\n}",
  Argument: e => e.name.value + ": " + print(e.value),
  FragmentSpread(e) {
    var n = "..." + e.name.value;
    if (hasItems(e.directives)) {
      n += " " + e.directives.map(zt.Directive).join(" ");
    }
    return n;
  },
  InlineFragment(e) {
    var n = "...";
    if (e.typeCondition) {
      n += " on " + e.typeCondition.name.value;
    }
    if (hasItems(e.directives)) {
      n += " " + e.directives.map(zt.Directive).join(" ");
    }
    return n + " " + print(e.selectionSet);
  },
  FragmentDefinition(e) {
    var n = "fragment " + e.name.value;
    n += " on " + e.typeCondition.name.value;
    if (hasItems(e.directives)) {
      n += " " + e.directives.map(zt.Directive).join(" ");
    }
    return n + " " + print(e.selectionSet);
  },
  Directive(e) {
    var n = "@" + e.name.value;
    if (hasItems(e.arguments)) {
      n += "(" + e.arguments.map(zt.Argument).join(", ") + ")";
    }
    return n;
  },
  NamedType: e => e.name.value,
  ListType: e => "[" + print(e.type) + "]",
  NonNullType: e => print(e.type) + "!"
};

function print(e) {
  return zt[e.kind] ? zt[e.kind](e) : "";
}

var Yt = new Set([ "gql", "graphql" ]);

function getSource(e, n) {
  var r = e.languageService.getProgram();
  if (!r) {
    return;
  }
  var i = r.getSourceFile(n);
  if (!i) {
    return;
  }
  return i;
}

function findNode(e, n) {
  return function find(e) {
    if (n >= e.getStart() && n < e.getEnd()) {
      return i.forEachChild(e, find) || e;
    }
  }(e);
}

function unrollFragment(e, n) {
  var r = [];
  var a = n.languageService.getDefinitionAtPosition(e.getSourceFile().fileName, e.getStart());
  if (!a) {
    return r;
  }
  var [s] = a;
  var o = getSource(n, s.fileName);
  if (!o) {
    return r;
  }
  var l = findNode(o, s.textSpan.start);
  if (!l) {
    return r;
  }
  if (i.isVariableDeclaration(l.parent) && l.parent.initializer && i.isCallExpression(l.parent.initializer)) {
    l = l.parent.initializer;
  } else if (i.isPropertyAssignment(l.parent)) {
    l = l.parent.initializer;
  }
  if (i.isCallExpression(l) && Yt.has(l.expression.getText())) {
    var [u, c] = l.arguments;
    if (c && i.isArrayLiteralExpression(c)) {
      c.elements.forEach((e => {
        if (i.isIdentifier(e)) {
          r.push(...unrollFragment(e, n));
        }
      }));
    }
    try {
      parse(u.getText().slice(1, -1), {
        noLocation: !0
      }).definitions.forEach((e => {
        if ("FragmentDefinition" === e.kind) {
          r.push(e);
        }
      }));
    } catch (e) {}
  }
  return r;
}

function findAllCallExpressions(e, n, r = !0) {
  var a = [];
  var s = [];
  var o = r ? !1 : !0;
  !function find(r) {
    if (i.isCallExpression(r) && Yt.has(r.expression.getText())) {
      var [l, u] = r.arguments;
      if (!o && !u) {
        o = !0;
        s = getAllFragments(e.fileName, r, n);
      } else if (u && i.isArrayLiteralExpression(u)) {
        u.elements.forEach((e => {
          if (i.isIdentifier(e)) {
            s.push(...unrollFragment(e, n));
          } else if (i.isPropertyAccessExpression(e)) {
            var r = e;
            while (i.isPropertyAccessExpression(r.expression)) {
              r = r.expression;
            }
            if (i.isIdentifier(r.name)) {
              s.push(...unrollFragment(r.name, n));
            }
          }
        }));
      }
      if (l && i.isNoSubstitutionTemplateLiteral(l)) {
        a.push(l);
      }
      return;
    } else {
      i.forEachChild(r, find);
    }
  }(e);
  return {
    nodes: a,
    fragments: s
  };
}

function getAllFragments(e, n, r) {
  var a = [];
  var s = r.languageService.getDefinitionAtPosition(e, n.expression.getStart());
  if (!s) {
    return a;
  }
  if (n.arguments[1] && i.isArrayLiteralExpression(n.arguments[1])) {
    n.arguments[1].elements.forEach((e => {
      if (i.isIdentifier(e)) {
        a.push(...unrollFragment(e, r));
      }
    }));
    return a;
  }
  var o = s[0];
  if (!o) {
    return a;
  }
  var l = getSource(r, o.fileName);
  if (!l) {
    return a;
  }
  i.forEachChild(l, (e => {
    if (i.isVariableStatement(e) && e.declarationList && "documents" === e.declarationList.declarations[0].name.getText()) {
      var [n] = e.declarationList.declarations;
      if (n.initializer && i.isObjectLiteralExpression(n.initializer)) {
        n.initializer.properties.forEach((e => {
          if (i.isPropertyAssignment(e) && i.isStringLiteral(e.name)) {
            try {
              var n = JSON.parse(`${e.name.getText().replace(/'/g, '"')}`);
              if (n.includes("fragment ") && n.includes(" on ")) {
                parse(n, {
                  noLocation: !0
                }).definitions.forEach((e => {
                  if ("FragmentDefinition" === e.kind) {
                    a.push(e);
                  }
                }));
              }
            } catch (e) {}
          }
        }));
      }
    }
  }));
  return a;
}

function bubbleUpTemplate(e) {
  while (i.isNoSubstitutionTemplateLiteral(e) || i.isToken(e) || i.isTemplateExpression(e) || i.isTemplateSpan(e)) {
    e = e.parent;
  }
  return e;
}

function bubbleUpCallExpression(e) {
  while (i.isNoSubstitutionTemplateLiteral(e) || i.isToken(e) || i.isTemplateExpression(e) || i.isTemplateSpan(e)) {
    e = e.parent;
  }
  return e;
}

class Cursor {
  constructor(e, n) {
    this.line = e;
    this.character = n;
  }
  setLine(e) {
    this.line = e;
  }
  setCharacter(e) {
    this.character = e;
  }
  lessThanOrEqualTo(e) {
    return this.line < e.line || this.line === e.line && this.character <= e.character;
  }
}

function resolveTemplate(e, n, r) {
  if (i.isNoSubstitutionTemplateLiteral(e)) {
    return {
      combinedText: e.getText().slice(1, -1),
      resolvedSpans: []
    };
  }
  var a = e.template.getText().slice(1, -1);
  if (i.isNoSubstitutionTemplateLiteral(e.template) || 0 === e.template.templateSpans.length) {
    return {
      combinedText: a,
      resolvedSpans: []
    };
  }
  var s = 0;
  var o = e.template.templateSpans.map((e => {
    if (i.isIdentifier(e.expression)) {
      var o = r.languageService.getDefinitionAtPosition(n, e.expression.getStart());
      if (!o) {
        return;
      }
      var l = o[0];
      var u = getSource(r, l.fileName);
      if (!u) {
        return;
      }
      var c = findNode(u, l.textSpan.start);
      if (!c || !c.parent) {
        return;
      }
      var d = c.parent;
      if (i.isVariableDeclaration(d)) {
        var f = e.expression.escapedText;
        var v = e.expression.getStart() - 2;
        var h = {
          start: v,
          length: e.expression.end - v + 1
        };
        if (d.initializer && i.isTaggedTemplateExpression(d.initializer)) {
          var m = resolveTemplate(d.initializer, l.fileName, r);
          a = a.replace("${" + e.expression.escapedText + "}", m.combinedText);
          var g = {
            lines: m.combinedText.split("\n").length,
            identifier: f,
            original: h,
            new: {
              start: h.start + s,
              length: m.combinedText.length
            }
          };
          s += m.combinedText.length - h.length;
          return g;
        } else if (d.initializer && i.isAsExpression(d.initializer) && i.isTaggedTemplateExpression(d.initializer.expression)) {
          var y = resolveTemplate(d.initializer.expression, l.fileName, r);
          a = a.replace("${" + e.expression.escapedText + "}", y.combinedText);
          var T = {
            lines: y.combinedText.split("\n").length,
            identifier: f,
            original: h,
            new: {
              start: h.start + s,
              length: y.combinedText.length
            }
          };
          s += y.combinedText.length - h.length;
          return T;
        } else if (d.initializer && i.isAsExpression(d.initializer) && i.isAsExpression(d.initializer.expression) && i.isObjectLiteralExpression(d.initializer.expression.expression)) {
          var E = print(JSON.parse(d.initializer.expression.expression.getText()));
          a = a.replace("${" + e.expression.escapedText + "}", E);
          var N = {
            lines: E.split("\n").length,
            identifier: f,
            original: h,
            new: {
              start: h.start + s,
              length: E.length
            }
          };
          s += E.length - h.length;
          return N;
        }
        return;
      }
    }
    return;
  })).filter(Boolean);
  return {
    combinedText: a,
    resolvedSpans: o
  };
}

var getToken = (e, n) => {
  var r = e.getText().slice(1, -1).split("\n");
  var i = onlineParser();
  var a = i.startState();
  var s = e.getStart() + 1;
  var o = void 0;
  for (var l = 0; l < r.length; l++) {
    var u = s;
    var c = new CharacterStream(r[l] + "\n");
    while (!c.eol()) {
      var d = i.token(c, a);
      var f = c.current();
      if (u + c.getStartOfToken() <= n && u + c.getCurrentPosition() >= n) {
        o = {
          line: l,
          start: c.getStartOfToken() + 1,
          end: c.getCurrentPosition(),
          string: f,
          state: a,
          tokenKind: d
        };
        break;
      }
    }
    s += r[l].length + 1;
  }
  return o;
};

function hintList(e, n) {
  return function filterAndSortList(e, n) {
    if (!n) {
      return filterNonEmpty(e, (e => !e.isDeprecated));
    }
    var r = e.map((e => ({
      proximity: getProximity(normalizeText(e.label), n),
      entry: e
    })));
    return filterNonEmpty(filterNonEmpty(r, (e => e.proximity <= 2)), (e => !e.entry.isDeprecated)).sort(((e, n) => (e.entry.isDeprecated ? 1 : 0) - (n.entry.isDeprecated ? 1 : 0) || e.proximity - n.proximity || e.entry.label.length - n.entry.label.length)).map((e => e.entry));
  }(n, normalizeText(e.string));
}

function filterNonEmpty(e, n) {
  var r = e.filter(n);
  return 0 === r.length ? e : r;
}

function normalizeText(e) {
  return e.toLowerCase().replace(/\W/g, "");
}

function getProximity(e, n) {
  var r = function lexicalDistance(e, n) {
    var r;
    var i;
    var a = [];
    var s = e.length;
    var o = n.length;
    for (r = 0; r <= s; r++) {
      a[r] = [ r ];
    }
    for (i = 1; i <= o; i++) {
      a[0][i] = i;
    }
    for (r = 1; r <= s; r++) {
      for (i = 1; i <= o; i++) {
        var l = e[r - 1] === n[i - 1] ? 0 : 1;
        a[r][i] = Math.min(a[r - 1][i] + 1, a[r][i - 1] + 1, a[r - 1][i - 1] + l);
        if (r > 1 && i > 1 && e[r - 1] === n[i - 2] && e[r - 2] === n[i - 1]) {
          a[r][i] = Math.min(a[r][i], a[r - 2][i - 2] + l);
        }
      }
    }
    return a[s][o];
  }(n, e);
  if (e.length > n.length) {
    r -= e.length - n.length - 1;
    r += 0 === e.indexOf(n) ? 0 : .5;
  }
  return r;
}

function getGraphQLCompletions(e, n, r, a) {
  var s = a.config.templateIsCallExpression ?? !0;
  var o = getSource(a, e);
  if (!o) {
    return;
  }
  var l = findNode(o, n);
  if (!l) {
    return;
  }
  l = s ? bubbleUpCallExpression(l) : bubbleUpTemplate(l);
  var u, c;
  if (i.isCallExpression(l) && s && Yt.has(l.expression.getText()) && l.arguments.length > 0 && i.isNoSubstitutionTemplateLiteral(l.arguments[0])) {
    var f = getToken(l.arguments[0], n);
    if (!r.current || !f) {
      return;
    }
    u = `${l.arguments[0].getText().slice(1, -1)}\n${getAllFragments(e, l, a).map((e => print(e))).join("\n")}`;
    c = new Cursor(f.line, f.start - 1);
  } else if (i.isTaggedTemplateExpression(l)) {
    var {template: v, tag: h} = l;
    if (!i.isIdentifier(h) || !Yt.has(h.text)) {
      return;
    }
    var m = getToken(v, n);
    if (!m || !r.current) {
      return;
    }
    var {combinedText: g, resolvedSpans: y} = resolveTemplate(l, e, a);
    var T = y.filter((e => e.original.start < n && e.original.start + e.original.length < n)).reduce(((e, n) => e + (n.lines - 1)), 0);
    m.line = m.line + T;
    u = g;
    c = new Cursor(m.line, m.start - 1);
  } else {
    return;
  }
  var [E, N] = function getSuggestionsInternal(e, n, r) {
    var i = getTokenAtPosition(n, r);
    var a = [];
    try {
      a = parse(n, {
        noLocation: !0
      }).definitions.filter((e => e.kind === d.FRAGMENT_DEFINITION));
    } catch (e) {}
    var s = getAutocompleteSuggestions(e, n, r);
    var o = function getSuggestionsForFragmentSpread(e, n, r, i, a) {
      if (!i) {
        return [];
      }
      var s = r.getTypeMap();
      var o = getDefinitionState(e.state);
      return hintList(e, a.filter((e => s[e.typeCondition.name.value] && !(o && o.kind === Ut.FRAGMENT_DEFINITION && o.name === e.name.value) && isCompositeType(n.parentType) && isCompositeType(s[e.typeCondition.name.value]) && doTypesOverlap(r, n.parentType, s[e.typeCondition.name.value]))).map((e => ({
        label: e.name.value,
        detail: String(s[e.typeCondition.name.value]),
        documentation: `fragment ${e.name.value} on ${e.typeCondition.name.value}`,
        kind: Ct.Field,
        type: s[e.typeCondition.name.value]
      }))));
    }(i, getTypeInfo(e, i.state), e, n, a);
    var l = "Invalid" === i.state.kind ? i.state.prevState : i.state;
    var u = getParentDefinition(i.state, Ut.FIELD)?.name;
    if (l && u) {
      var {kind: c} = l;
      if (c === Ut.ARGUMENTS || c === Ut.ARGUMENT) {
        var f = new Set;
        runOnlineParser(n, ((e, n) => {
          if (n.kind === Ut.ARGUMENT) {
            var r = getParentDefinition(n, Ut.FIELD);
            if (u && n.name && r?.name === u) {
              f.add(n.name);
            }
          }
        }));
        s = s.filter((e => !f.has(e.label)));
      }
      if (c === Ut.SELECTION_SET || c === Ut.FIELD || c === Ut.ALIASED_FIELD) {
        var v = new Set;
        var h = getUsedFragments(n, u);
        runOnlineParser(n, ((e, n) => {
          if (n.kind === Ut.FIELD || n.kind === Ut.ALIASED_FIELD) {
            var r = getParentDefinition(n, Ut.FIELD);
            if (r && r.name === u && n.name) {
              v.add(n.name);
            }
          }
        }));
        s = s.filter((e => !v.has(e.label)));
        o = o.filter((e => !h.has(e.label)));
      }
      if (c === Ut.FRAGMENT_SPREAD) {
        var m = getUsedFragments(n, u);
        s = s.filter((e => !m.has(e.label)));
        o = o.filter((e => !m.has(e.label)));
      }
    }
    return [ s, o ];
  }(r.current, u, c);
  return {
    isGlobalCompletion: !1,
    isMemberCompletion: !1,
    isNewIdentifierLocation: !1,
    entries: [ ...E.map((e => ({
      ...e,
      kind: i.ScriptElementKind.variableElement,
      name: e.label,
      kindModifiers: "declare",
      sortText: e.sortText || "0",
      labelDetails: {
        detail: e.type ? " " + e.type?.toString() : void 0,
        description: e.documentation
      }
    }))), ...N.map((e => ({
      ...e,
      kind: i.ScriptElementKind.variableElement,
      name: e.label,
      insertText: "..." + e.label,
      kindModifiers: "declare",
      sortText: "0",
      labelDetails: {
        description: e.documentation
      }
    }))) ]
  };
}

function getUsedFragments(e, n) {
  var r = new Set;
  runOnlineParser(e, ((e, i) => {
    if (i.kind === Ut.FRAGMENT_SPREAD && i.name) {
      var a = getParentDefinition(i, Ut.FIELD);
      if (n && a?.name === n) {
        r.add(i.name);
      }
    }
  }));
  return r;
}

function getParentDefinition(e, n) {
  if (e.prevState?.kind === n) {
    return e.prevState;
  }
  if (e.prevState?.prevState?.kind === n) {
    return e.prevState.prevState;
  }
  if (e.prevState?.prevState?.prevState?.kind === n) {
    return e.prevState.prevState.prevState;
  }
  if (e.prevState?.prevState?.prevState?.prevState?.kind === n) {
    return e.prevState.prevState.prevState.prevState;
  }
}

function runOnlineParser(e, n) {
  var r = e.split("\n");
  var i = onlineParser();
  var a = i.startState();
  var s = "";
  var o = new CharacterStream("");
  for (var l = 0; l < r.length; l++) {
    o = new CharacterStream(r[l]);
    while (!o.eol()) {
      if ("BREAK" === n(o, a, s = i.token(o, a), l)) {
        break;
      }
    }
    n(o, a, s, l);
    if (!a.kind) {
      a = i.startState();
    }
  }
  return {
    start: o.getStartOfToken(),
    end: o.getCurrentPosition(),
    string: o.current(),
    state: a,
    style: s
  };
}

var qt = "object" == typeof performance && performance && "function" == typeof performance.now ? performance : Date;

var Jt = new Set;

var Wt = "object" == typeof process && process ? process : {};

var emitWarning = (e, n, r, i) => {
  "function" == typeof Wt.emitWarning ? Wt.emitWarning(e, n, r, i) : console.error(`[${r}] ${n}: ${e}`);
};

var Xt = globalThis.AbortController;

var Kt = globalThis.AbortSignal;

if (void 0 === Xt) {
  Kt = class AbortSignal {
    _onabort=[];
    aborted=!1;
    addEventListener(e, n) {
      this._onabort.push(n);
    }
  };
  Xt = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal=new Kt;
    abort(e) {
      if (this.signal.aborted) {
        return;
      }
      this.signal.reason = e;
      this.signal.aborted = !0;
      for (var n of this.signal._onabort) {
        n(e);
      }
      this.signal.onabort?.(e);
    }
  };
  var Ht = "1" !== Wt.env?.LRU_CACHE_IGNORE_AC_WARNING;
  var warnACPolyfill = () => {
    if (!Ht) {
      return;
    }
    Ht = !1;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}

var isPosInt = e => e && e === Math.floor(e) && e > 0 && isFinite(e);

var getUintArray = e => !isPosInt(e) ? null : e <= Math.pow(2, 8) ? Uint8Array : e <= Math.pow(2, 16) ? Uint16Array : e <= Math.pow(2, 32) ? Uint32Array : e <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(e) {
    super(e);
    this.fill(0);
  }
}

class Stack {
  static #e=!1;
  static create(e) {
    var n = getUintArray(e);
    if (!n) {
      return [];
    }
    Stack.#e = !0;
    var r = new Stack(e, n);
    Stack.#e = !1;
    return r;
  }
  constructor(e, n) {
    if (!Stack.#e) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new n(e);
    this.length = 0;
  }
  push(e) {
    this.heap[this.length++] = e;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #t;
  #n;
  #r;
  #i;
  #a;
  #s;
  #o;
  #l;
  #u;
  #c;
  #p;
  #d;
  #f;
  #v;
  #h;
  #m;
  #g;
  #y;
  #T;
  #E;
  #N;
  #I;
  static unsafeExposeInternals(e) {
    return {
      starts: e.#y,
      ttls: e.#T,
      sizes: e.#g,
      keyMap: e.#l,
      keyList: e.#u,
      valList: e.#c,
      next: e.#p,
      prev: e.#d,
      get head() {
        return e.#f;
      },
      get tail() {
        return e.#v;
      },
      free: e.#h,
      isBackgroundFetch: n => e.#b(n),
      backgroundFetch: (n, r, i, a) => e.#S(n, r, i, a),
      moveToTail: n => e.#_(n),
      indexes: n => e.#A(n),
      rindexes: n => e.#O(n),
      isStale: n => e.#L(n)
    };
  }
  get max() {
    return this.#t;
  }
  get maxSize() {
    return this.#n;
  }
  get calculatedSize() {
    return this.#o;
  }
  get size() {
    return this.#s;
  }
  get fetchMethod() {
    return this.#a;
  }
  get dispose() {
    return this.#r;
  }
  get disposeAfter() {
    return this.#i;
  }
  constructor(e) {
    var {max: n = 0, ttl: r, ttlResolution: i = 1, ttlAutopurge: a, updateAgeOnGet: s, updateAgeOnHas: o, allowStale: l, dispose: u, disposeAfter: c, noDisposeOnSet: d, noUpdateTTL: f, maxSize: v = 0, maxEntrySize: h = 0, sizeCalculation: m, fetchMethod: g, noDeleteOnFetchRejection: y, noDeleteOnStaleGet: T, allowStaleOnFetchRejection: E, allowStaleOnFetchAbort: N, ignoreFetchAbort: I} = e;
    if (0 !== n && !isPosInt(n)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    var b = n ? getUintArray(n) : Array;
    if (!b) {
      throw new Error("invalid max value: " + n);
    }
    this.#t = n;
    this.#n = v;
    this.maxEntrySize = h || this.#n;
    this.sizeCalculation = m;
    if (this.sizeCalculation) {
      if (!this.#n && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if ("function" != typeof this.sizeCalculation) {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (void 0 !== g && "function" != typeof g) {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#a = g;
    this.#N = !!g;
    this.#l = new Map;
    this.#u = new Array(n).fill(void 0);
    this.#c = new Array(n).fill(void 0);
    this.#p = new b(n);
    this.#d = new b(n);
    this.#f = 0;
    this.#v = 0;
    this.#h = Stack.create(n);
    this.#s = 0;
    this.#o = 0;
    if ("function" == typeof u) {
      this.#r = u;
    }
    if ("function" == typeof c) {
      this.#i = c;
      this.#m = [];
    } else {
      this.#i = void 0;
      this.#m = void 0;
    }
    this.#E = !!this.#r;
    this.#I = !!this.#i;
    this.noDisposeOnSet = !!d;
    this.noUpdateTTL = !!f;
    this.noDeleteOnFetchRejection = !!y;
    this.allowStaleOnFetchRejection = !!E;
    this.allowStaleOnFetchAbort = !!N;
    this.ignoreFetchAbort = !!I;
    if (0 !== this.maxEntrySize) {
      if (0 !== this.#n) {
        if (!isPosInt(this.#n)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#D();
    }
    this.allowStale = !!l;
    this.noDeleteOnStaleGet = !!T;
    this.updateAgeOnGet = !!s;
    this.updateAgeOnHas = !!o;
    this.ttlResolution = isPosInt(i) || 0 === i ? i : 1;
    this.ttlAutopurge = !!a;
    this.ttl = r || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#x();
    }
    if (0 === this.#t && 0 === this.ttl && 0 === this.#n) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#t && !this.#n) {
      var S = "LRU_CACHE_UNBOUNDED";
      if ((e => !Jt.has(e))(S)) {
        Jt.add(S);
        emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", S, LRUCache);
      }
    }
  }
  getRemainingTTL(e) {
    return this.#l.has(e) ? 1 / 0 : 0;
  }
  #x() {
    var e = new ZeroArray(this.#t);
    var n = new ZeroArray(this.#t);
    this.#T = e;
    this.#y = n;
    this.#F = (r, i, a = qt.now()) => {
      n[r] = 0 !== i ? a : 0;
      e[r] = i;
      if (0 !== i && this.ttlAutopurge) {
        var s = setTimeout((() => {
          if (this.#L(r)) {
            this.delete(this.#u[r]);
          }
        }), i + 1);
        if (s.unref) {
          s.unref();
        }
      }
    };
    this.#w = r => {
      n[r] = 0 !== e[r] ? qt.now() : 0;
    };
    this.#k = (i, a) => {
      if (e[a]) {
        var s = e[a];
        var o = n[a];
        i.ttl = s;
        i.start = o;
        i.now = r || getNow();
        i.remainingTTL = s - (i.now - o);
      }
    };
    var r = 0;
    var getNow = () => {
      var e = qt.now();
      if (this.ttlResolution > 0) {
        r = e;
        var n = setTimeout((() => r = 0), this.ttlResolution);
        if (n.unref) {
          n.unref();
        }
      }
      return e;
    };
    this.getRemainingTTL = i => {
      var a = this.#l.get(i);
      if (void 0 === a) {
        return 0;
      }
      var s = e[a];
      var o = n[a];
      if (0 === s || 0 === o) {
        return 1 / 0;
      }
      return s - ((r || getNow()) - o);
    };
    this.#L = i => 0 !== e[i] && 0 !== n[i] && (r || getNow()) - n[i] > e[i];
  }
  #w=() => {};
  #k=() => {};
  #F=() => {};
  #L=() => !1;
  #D() {
    var e = new ZeroArray(this.#t);
    this.#o = 0;
    this.#g = e;
    this.#C = n => {
      this.#o -= e[n];
      e[n] = 0;
    };
    this.#R = (e, n, r, i) => {
      if (this.#b(n)) {
        return 0;
      }
      if (!isPosInt(r)) {
        if (i) {
          if ("function" != typeof i) {
            throw new TypeError("sizeCalculation must be a function");
          }
          r = i(n, e);
          if (!isPosInt(r)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return r;
    };
    this.#j = (n, r, i) => {
      e[n] = r;
      if (this.#n) {
        var a = this.#n - e[n];
        while (this.#o > a) {
          this.#V(!0);
        }
      }
      this.#o += e[n];
      if (i) {
        i.entrySize = r;
        i.totalCalculatedSize = this.#o;
      }
    };
  }
  #C=e => {};
  #j=(e, n, r) => {};
  #R=(e, n, r, i) => {
    if (r || i) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  * #A({allowStale: e = this.allowStale} = {}) {
    if (this.#s) {
      for (var n = this.#v; 1; ) {
        if (!this.#U(n)) {
          break;
        }
        if (e || !this.#L(n)) {
          yield n;
        }
        if (n === this.#f) {
          break;
        } else {
          n = this.#d[n];
        }
      }
    }
  }
  * #O({allowStale: e = this.allowStale} = {}) {
    if (this.#s) {
      for (var n = this.#f; 1; ) {
        if (!this.#U(n)) {
          break;
        }
        if (e || !this.#L(n)) {
          yield n;
        }
        if (n === this.#v) {
          break;
        } else {
          n = this.#p[n];
        }
      }
    }
  }
  #U(e) {
    return void 0 !== e && this.#l.get(this.#u[e]) === e;
  }
  * entries() {
    for (var e of this.#A()) {
      if (void 0 !== this.#c[e] && void 0 !== this.#u[e] && !this.#b(this.#c[e])) {
        yield [ this.#u[e], this.#c[e] ];
      }
    }
  }
  * rentries() {
    for (var e of this.#O()) {
      if (void 0 !== this.#c[e] && void 0 !== this.#u[e] && !this.#b(this.#c[e])) {
        yield [ this.#u[e], this.#c[e] ];
      }
    }
  }
  * keys() {
    for (var e of this.#A()) {
      var n = this.#u[e];
      if (void 0 !== n && !this.#b(this.#c[e])) {
        yield n;
      }
    }
  }
  * rkeys() {
    for (var e of this.#O()) {
      var n = this.#u[e];
      if (void 0 !== n && !this.#b(this.#c[e])) {
        yield n;
      }
    }
  }
  * values() {
    for (var e of this.#A()) {
      if (void 0 !== this.#c[e] && !this.#b(this.#c[e])) {
        yield this.#c[e];
      }
    }
  }
  * rvalues() {
    for (var e of this.#O()) {
      if (void 0 !== this.#c[e] && !this.#b(this.#c[e])) {
        yield this.#c[e];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(e, n = {}) {
    for (var r of this.#A()) {
      var i = this.#c[r];
      var a = this.#b(i) ? i.__staleWhileFetching : i;
      if (void 0 === a) {
        continue;
      }
      if (e(a, this.#u[r], this)) {
        return this.get(this.#u[r], n);
      }
    }
  }
  forEach(e, n = this) {
    for (var r of this.#A()) {
      var i = this.#c[r];
      var a = this.#b(i) ? i.__staleWhileFetching : i;
      if (void 0 === a) {
        continue;
      }
      e.call(n, a, this.#u[r], this);
    }
  }
  rforEach(e, n = this) {
    for (var r of this.#O()) {
      var i = this.#c[r];
      var a = this.#b(i) ? i.__staleWhileFetching : i;
      if (void 0 === a) {
        continue;
      }
      e.call(n, a, this.#u[r], this);
    }
  }
  purgeStale() {
    var e = !1;
    for (var n of this.#O({
      allowStale: !0
    })) {
      if (this.#L(n)) {
        this.delete(this.#u[n]);
        e = !0;
      }
    }
    return e;
  }
  dump() {
    var e = [];
    for (var n of this.#A({
      allowStale: !0
    })) {
      var r = this.#u[n];
      var i = this.#c[n];
      var a = this.#b(i) ? i.__staleWhileFetching : i;
      if (void 0 === a || void 0 === r) {
        continue;
      }
      var s = {
        value: a
      };
      if (this.#T && this.#y) {
        s.ttl = this.#T[n];
        var o = qt.now() - this.#y[n];
        s.start = Math.floor(Date.now() - o);
      }
      if (this.#g) {
        s.size = this.#g[n];
      }
      e.unshift([ r, s ]);
    }
    return e;
  }
  load(e) {
    this.clear();
    for (var [n, r] of e) {
      if (r.start) {
        var i = Date.now() - r.start;
        r.start = qt.now() - i;
      }
      this.set(n, r.value, r);
    }
  }
  set(e, n, r = {}) {
    if (void 0 === n) {
      this.delete(e);
      return this;
    }
    var {ttl: i = this.ttl, start: a, noDisposeOnSet: s = this.noDisposeOnSet, sizeCalculation: o = this.sizeCalculation, status: l} = r;
    var {noUpdateTTL: u = this.noUpdateTTL} = r;
    var c = this.#R(e, n, r.size || 0, o);
    if (this.maxEntrySize && c > this.maxEntrySize) {
      if (l) {
        l.set = "miss";
        l.maxEntrySizeExceeded = !0;
      }
      this.delete(e);
      return this;
    }
    var d = 0 === this.#s ? void 0 : this.#l.get(e);
    if (void 0 === d) {
      d = 0 === this.#s ? this.#v : 0 !== this.#h.length ? this.#h.pop() : this.#s === this.#t ? this.#V(!1) : this.#s;
      this.#u[d] = e;
      this.#c[d] = n;
      this.#l.set(e, d);
      this.#p[this.#v] = d;
      this.#d[d] = this.#v;
      this.#v = d;
      this.#s++;
      this.#j(d, c, l);
      if (l) {
        l.set = "add";
      }
      u = !1;
    } else {
      this.#_(d);
      var f = this.#c[d];
      if (n !== f) {
        if (this.#N && this.#b(f)) {
          f.__abortController.abort(new Error("replaced"));
          var {__staleWhileFetching: v} = f;
          if (void 0 !== v && !s) {
            if (this.#E) {
              this.#r?.(v, e, "set");
            }
            if (this.#I) {
              this.#m?.push([ v, e, "set" ]);
            }
          }
        } else if (!s) {
          if (this.#E) {
            this.#r?.(f, e, "set");
          }
          if (this.#I) {
            this.#m?.push([ f, e, "set" ]);
          }
        }
        this.#C(d);
        this.#j(d, c, l);
        this.#c[d] = n;
        if (l) {
          l.set = "replace";
          var h = f && this.#b(f) ? f.__staleWhileFetching : f;
          if (void 0 !== h) {
            l.oldValue = h;
          }
        }
      } else if (l) {
        l.set = "update";
      }
    }
    if (0 !== i && !this.#T) {
      this.#x();
    }
    if (this.#T) {
      if (!u) {
        this.#F(d, i, a);
      }
      if (l) {
        this.#k(l, d);
      }
    }
    if (!s && this.#I && this.#m) {
      var m = this.#m;
      var g;
      while (g = m?.shift()) {
        this.#i?.(...g);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#s) {
        var e = this.#c[this.#f];
        this.#V(!0);
        if (this.#b(e)) {
          if (e.__staleWhileFetching) {
            return e.__staleWhileFetching;
          }
        } else if (void 0 !== e) {
          return e;
        }
      }
    } finally {
      if (this.#I && this.#m) {
        var n = this.#m;
        var r;
        while (r = n?.shift()) {
          this.#i?.(...r);
        }
      }
    }
  }
  #V(e) {
    var n = this.#f;
    var r = this.#u[n];
    var i = this.#c[n];
    if (this.#N && this.#b(i)) {
      i.__abortController.abort(new Error("evicted"));
    } else if (this.#E || this.#I) {
      if (this.#E) {
        this.#r?.(i, r, "evict");
      }
      if (this.#I) {
        this.#m?.push([ i, r, "evict" ]);
      }
    }
    this.#C(n);
    if (e) {
      this.#u[n] = void 0;
      this.#c[n] = void 0;
      this.#h.push(n);
    }
    if (1 === this.#s) {
      this.#f = this.#v = 0;
      this.#h.length = 0;
    } else {
      this.#f = this.#p[n];
    }
    this.#l.delete(r);
    this.#s--;
    return n;
  }
  has(e, n = {}) {
    var {updateAgeOnHas: r = this.updateAgeOnHas, status: i} = n;
    var a = this.#l.get(e);
    if (void 0 !== a) {
      var s = this.#c[a];
      if (this.#b(s) && void 0 === s.__staleWhileFetching) {
        return !1;
      }
      if (!this.#L(a)) {
        if (r) {
          this.#w(a);
        }
        if (i) {
          i.has = "hit";
          this.#k(i, a);
        }
        return !0;
      } else if (i) {
        i.has = "stale";
        this.#k(i, a);
      }
    } else if (i) {
      i.has = "miss";
    }
    return !1;
  }
  peek(e, n = {}) {
    var {allowStale: r = this.allowStale} = n;
    var i = this.#l.get(e);
    if (void 0 !== i && (r || !this.#L(i))) {
      var a = this.#c[i];
      return this.#b(a) ? a.__staleWhileFetching : a;
    }
  }
  #S(e, n, r, i) {
    var a = void 0 === n ? void 0 : this.#c[n];
    if (this.#b(a)) {
      return a;
    }
    var s = new Xt;
    var {signal: o} = r;
    o?.addEventListener("abort", (() => s.abort(o.reason)), {
      signal: s.signal
    });
    var l = {
      signal: s.signal,
      options: r,
      context: i
    };
    var cb = (i, a = !1) => {
      var {aborted: o} = s.signal;
      var c = r.ignoreFetchAbort && void 0 !== i;
      if (r.status) {
        if (o && !a) {
          r.status.fetchAborted = !0;
          r.status.fetchError = s.signal.reason;
          if (c) {
            r.status.fetchAbortIgnored = !0;
          }
        } else {
          r.status.fetchResolved = !0;
        }
      }
      if (o && !c && !a) {
        return fetchFail(s.signal.reason);
      }
      if (this.#c[n] === u) {
        if (void 0 === i) {
          if (u.__staleWhileFetching) {
            this.#c[n] = u.__staleWhileFetching;
          } else {
            this.delete(e);
          }
        } else {
          if (r.status) {
            r.status.fetchUpdated = !0;
          }
          this.set(e, i, l.options);
        }
      }
      return i;
    };
    var fetchFail = i => {
      var {aborted: a} = s.signal;
      var o = a && r.allowStaleOnFetchAbort;
      var l = o || r.allowStaleOnFetchRejection;
      var c = u;
      if (this.#c[n] === u) {
        if (!(l || r.noDeleteOnFetchRejection) || void 0 === c.__staleWhileFetching) {
          this.delete(e);
        } else if (!o) {
          this.#c[n] = c.__staleWhileFetching;
        }
      }
      if (l) {
        if (r.status && void 0 !== c.__staleWhileFetching) {
          r.status.returnedStale = !0;
        }
        return c.__staleWhileFetching;
      } else if (c.__returned === c) {
        throw i;
      }
    };
    if (r.status) {
      r.status.fetchDispatched = !0;
    }
    var u = new Promise(((n, i) => {
      var o = this.#a?.(e, a, l);
      if (o && o instanceof Promise) {
        o.then((e => n(void 0 === e ? void 0 : e)), i);
      }
      s.signal.addEventListener("abort", (() => {
        if (!r.ignoreFetchAbort || r.allowStaleOnFetchAbort) {
          n(void 0);
          if (r.allowStaleOnFetchAbort) {
            n = e => cb(e, !0);
          }
        }
      }));
    })).then(cb, (e => {
      if (r.status) {
        r.status.fetchRejected = !0;
        r.status.fetchError = e;
      }
      return fetchFail(e);
    }));
    var c = Object.assign(u, {
      __abortController: s,
      __staleWhileFetching: a,
      __returned: void 0
    });
    if (void 0 === n) {
      this.set(e, c, {
        ...l.options,
        status: void 0
      });
      n = this.#l.get(e);
    } else {
      this.#c[n] = c;
    }
    return c;
  }
  #b(e) {
    if (!this.#N) {
      return !1;
    }
    var n = e;
    return !!n && n instanceof Promise && n.hasOwnProperty("__staleWhileFetching") && n.__abortController instanceof Xt;
  }
  async fetch(e, n = {}) {
    var {allowStale: r = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: a = this.noDeleteOnStaleGet, ttl: s = this.ttl, noDisposeOnSet: o = this.noDisposeOnSet, size: l = 0, sizeCalculation: u = this.sizeCalculation, noUpdateTTL: c = this.noUpdateTTL, noDeleteOnFetchRejection: d = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: f = this.allowStaleOnFetchRejection, ignoreFetchAbort: v = this.ignoreFetchAbort, allowStaleOnFetchAbort: h = this.allowStaleOnFetchAbort, context: m, forceRefresh: g = !1, status: y, signal: T} = n;
    if (!this.#N) {
      if (y) {
        y.fetch = "get";
      }
      return this.get(e, {
        allowStale: r,
        updateAgeOnGet: i,
        noDeleteOnStaleGet: a,
        status: y
      });
    }
    var E = {
      allowStale: r,
      updateAgeOnGet: i,
      noDeleteOnStaleGet: a,
      ttl: s,
      noDisposeOnSet: o,
      size: l,
      sizeCalculation: u,
      noUpdateTTL: c,
      noDeleteOnFetchRejection: d,
      allowStaleOnFetchRejection: f,
      allowStaleOnFetchAbort: h,
      ignoreFetchAbort: v,
      status: y,
      signal: T
    };
    var N = this.#l.get(e);
    if (void 0 === N) {
      if (y) {
        y.fetch = "miss";
      }
      var I = this.#S(e, N, E, m);
      return I.__returned = I;
    } else {
      var b = this.#c[N];
      if (this.#b(b)) {
        var S = r && void 0 !== b.__staleWhileFetching;
        if (y) {
          y.fetch = "inflight";
          if (S) {
            y.returnedStale = !0;
          }
        }
        return S ? b.__staleWhileFetching : b.__returned = b;
      }
      var _ = this.#L(N);
      if (!g && !_) {
        if (y) {
          y.fetch = "hit";
        }
        this.#_(N);
        if (i) {
          this.#w(N);
        }
        if (y) {
          this.#k(y, N);
        }
        return b;
      }
      var A = this.#S(e, N, E, m);
      var O = void 0 !== A.__staleWhileFetching && r;
      if (y) {
        y.fetch = _ ? "stale" : "refresh";
        if (O && _) {
          y.returnedStale = !0;
        }
      }
      return O ? A.__staleWhileFetching : A.__returned = A;
    }
  }
  get(e, n = {}) {
    var {allowStale: r = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: a = this.noDeleteOnStaleGet, status: s} = n;
    var o = this.#l.get(e);
    if (void 0 !== o) {
      var l = this.#c[o];
      var u = this.#b(l);
      if (s) {
        this.#k(s, o);
      }
      if (this.#L(o)) {
        if (s) {
          s.get = "stale";
        }
        if (!u) {
          if (!a) {
            this.delete(e);
          }
          if (s && r) {
            s.returnedStale = !0;
          }
          return r ? l : void 0;
        } else {
          if (s && r && void 0 !== l.__staleWhileFetching) {
            s.returnedStale = !0;
          }
          return r ? l.__staleWhileFetching : void 0;
        }
      } else {
        if (s) {
          s.get = "hit";
        }
        if (u) {
          return l.__staleWhileFetching;
        }
        this.#_(o);
        if (i) {
          this.#w(o);
        }
        return l;
      }
    } else if (s) {
      s.get = "miss";
    }
  }
  #M(e, n) {
    this.#d[n] = e;
    this.#p[e] = n;
  }
  #_(e) {
    if (e !== this.#v) {
      if (e === this.#f) {
        this.#f = this.#p[e];
      } else {
        this.#M(this.#d[e], this.#p[e]);
      }
      this.#M(this.#v, e);
      this.#v = e;
    }
  }
  delete(e) {
    var n = !1;
    if (0 !== this.#s) {
      var r = this.#l.get(e);
      if (void 0 !== r) {
        n = !0;
        if (1 === this.#s) {
          this.clear();
        } else {
          this.#C(r);
          var i = this.#c[r];
          if (this.#b(i)) {
            i.__abortController.abort(new Error("deleted"));
          } else if (this.#E || this.#I) {
            if (this.#E) {
              this.#r?.(i, e, "delete");
            }
            if (this.#I) {
              this.#m?.push([ i, e, "delete" ]);
            }
          }
          this.#l.delete(e);
          this.#u[r] = void 0;
          this.#c[r] = void 0;
          if (r === this.#v) {
            this.#v = this.#d[r];
          } else if (r === this.#f) {
            this.#f = this.#p[r];
          } else {
            this.#p[this.#d[r]] = this.#p[r];
            this.#d[this.#p[r]] = this.#d[r];
          }
          this.#s--;
          this.#h.push(r);
        }
      }
    }
    if (this.#I && this.#m?.length) {
      var a = this.#m;
      var s;
      while (s = a?.shift()) {
        this.#i?.(...s);
      }
    }
    return n;
  }
  clear() {
    for (var e of this.#O({
      allowStale: !0
    })) {
      var n = this.#c[e];
      if (this.#b(n)) {
        n.__abortController.abort(new Error("deleted"));
      } else {
        var r = this.#u[e];
        if (this.#E) {
          this.#r?.(n, r, "delete");
        }
        if (this.#I) {
          this.#m?.push([ n, r, "delete" ]);
        }
      }
    }
    this.#l.clear();
    this.#c.fill(void 0);
    this.#u.fill(void 0);
    if (this.#T && this.#y) {
      this.#T.fill(0);
      this.#y.fill(0);
    }
    if (this.#g) {
      this.#g.fill(0);
    }
    this.#f = 0;
    this.#v = 0;
    this.#h.length = 0;
    this.#o = 0;
    this.#s = 0;
    if (this.#I && this.#m) {
      var i = this.#m;
      var a;
      while (a = i?.shift()) {
        this.#i?.(...a);
      }
    }
  }
}

var Zt = {
  exports: {}
};

var en = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};

var tn = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};

Zt.exports = function fnv1a(e) {
  var n = Number(tn[32]);
  var r = !1;
  for (var i = 0; i < e.length; i++) {
    var a = e.charCodeAt(i);
    if (a > 127 && !r) {
      a = (e = unescape(encodeURIComponent(e))).charCodeAt(i);
      r = !0;
    }
    n ^= a;
    n += (n << 1) + (n << 4) + (n << 7) + (n << 8) + (n << 24);
  }
  return n >>> 0;
};

Zt.exports.bigInt = function bigInt(e, {size: n = 32} = {}) {
  if (!en[n]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  var r = tn[n];
  var i = en[n];
  var a = !1;
  for (var s = 0; s < e.length; s++) {
    var o = e.charCodeAt(s);
    if (o > 127 && !a) {
      o = (e = unescape(encodeURIComponent(e))).charCodeAt(s);
      a = !0;
    }
    r ^= BigInt(o);
    r = BigInt.asUintN(n, r * i);
  }
  return r;
};

var nn = getDefaultExportFromCjs(Zt.exports);

var traverseArrayDestructuring = (e, n, r, a, s) => e.elements.flatMap((e => {
  if (i.isOmittedExpression(e)) {
    return [];
  }
  var o = [ ...n ];
  return i.isIdentifier(e.name) ? crawlScope(e.name, o, r, a, s) : i.isObjectBindingPattern(e.name) ? traverseDestructuring(e.name, o, r, a, s) : traverseArrayDestructuring(e.name, o, r, a, s);
}));

var traverseDestructuring = (e, n, r, a, s) => {
  var o = [];
  var _loop = function() {
    if (i.isObjectBindingPattern(l.name)) {
      var e = [ ...n ];
      if (l.propertyName && !n.includes(l.propertyName.getText())) {
        var u = [ ...e, l.propertyName.getText() ].join(".");
        if (r.find((e => e.startsWith(u)))) {
          e.push(l.propertyName.getText());
        }
      }
      var c = traverseDestructuring(l.name, e, r, a, s);
      o.push(...c);
    } else if (i.isIdentifier(l.name)) {
      var d = [ ...n ];
      if (l.propertyName && !n.includes(l.propertyName.getText())) {
        var f = [ ...d, l.propertyName.getText() ].join(".");
        if (r.find((e => e.startsWith(f)))) {
          d.push(l.propertyName.getText());
        }
      } else {
        var v = [ ...d, l.name.getText() ].join(".");
        if (r.find((e => e.startsWith(v)))) {
          d.push(l.name.getText());
        }
      }
      var h = crawlScope(l.name, d, r, a, s);
      o.push(...h);
    }
  };
  for (var l of e.elements) {
    _loop();
  }
  return o;
};

var rn = new Set([ "map", "filter", "forEach", "reduce", "every", "some", "find", "flatMap", "sort" ]);

var crawlScope = (e, n, r, a, s) => {
  var o = [];
  var l = s.languageService.getReferencesAtPosition(a.fileName, e.getStart());
  if (!l) {
    return o;
  }
  return o = l.flatMap((o => {
    if (o.fileName !== a.fileName) {
      return [];
    }
    if (e.getStart() <= o.textSpan.start && e.getEnd() >= o.textSpan.start + o.textSpan.length) {
      return [];
    }
    var l = findNode(a, o.textSpan.start);
    if (!l) {
      return [];
    }
    var u = [ ...n ];
    var c, _loop2 = function() {
      if (i.isVariableDeclaration(l)) {
        if (i.isIdentifier(l.name)) {
          return {
            v: crawlScope(l.name, u, r, a, s)
          };
        } else if (i.isObjectBindingPattern(l.name)) {
          return {
            v: traverseDestructuring(l.name, u, r, a, s)
          };
        } else if (i.isArrayBindingPattern(l.name)) {
          return {
            v: traverseArrayDestructuring(l.name, u, r, a, s)
          };
        }
      } else if (i.isIdentifier(l) && !u.includes(l.text)) {
        var e = [ ...u, l.text ].join(".");
        if (r.find((n => n.startsWith(e)))) {
          u.push(l.text);
        }
      } else if (i.isPropertyAccessExpression(l) && "at" === l.name.text && i.isCallExpression(l.parent)) {
        l = l.parent;
      } else if (i.isPropertyAccessExpression(l) && rn.has(l.name.text) && i.isCallExpression(l.parent)) {
        var n = "reduce" === l.name.text;
        var o = "every" === l.name.text || "some" === l.name.text;
        var c = l.parent;
        var d = c.arguments[0];
        if (i.isFunctionExpression(d) || i.isArrowFunction(d)) {
          var f = crawlScope(d.parameters[n ? 1 : 0].name, u, r, a, s);
          if (i.isVariableDeclaration(c.parent) && !o) {
            var v = crawlScope(c.parent.name, u, r, a, s);
            f.push(...v);
          }
          return {
            v: f
          };
        } else if (i.isIdentifier(d)) {}
      } else if (i.isPropertyAccessExpression(l) && !u.includes(l.name.text)) {
        var h = [ ...u, l.name.text ].join(".");
        if (r.find((e => e.startsWith(h)))) {
          u.push(l.name.text);
        }
      } else if (i.isElementAccessExpression(l) && i.isStringLiteral(l.argumentExpression) && !u.includes(l.argumentExpression.text)) {
        var m = [ ...u, l.argumentExpression.text ].join(".");
        if (r.find((e => e.startsWith(m)))) {
          u.push(l.argumentExpression.text);
        }
      }
      if (i.isNonNullExpression(l.parent)) {
        l = l.parent.parent;
      } else {
        l = l.parent;
      }
    };
    while (i.isIdentifier(l) || i.isPropertyAccessExpression(l) || i.isElementAccessExpression(l) || i.isVariableDeclaration(l) || i.isBinaryExpression(l)) {
      if (c = _loop2()) {
        return c.v;
      }
    }
    return u.join(".");
  }));
};

var checkFieldUsageInFile = (e, n, r) => {
  var a = [];
  if (!(r.config.trackFieldUsage ?? !0)) {
    return a;
  }
  var s = new Set([ "id", "_id", "__typename", ...r.config.reservedKeys ?? [] ]);
  try {
    n.forEach((n => {
      var o = n.getText();
      if (o.includes("mutation") || o.includes("subscription")) {
        return;
      }
      var l = (e => {
        var n = e;
        var r = 0;
        while (!i.isVariableDeclaration(n) && n.parent && r < 5) {
          n = n.parent;
          r++;
        }
        return n;
      })(n);
      if (!i.isVariableDeclaration(l)) {
        return;
      }
      var u = r.languageService.getReferencesAtPosition(e.fileName, l.name.getStart());
      if (!u) {
        return;
      }
      var c = [];
      var d = [];
      var f = [];
      var v = new Map;
      visit(parse(n.getText().slice(1, -1)), {
        Field: {
          enter: e => {
            if (!e.selectionSet && !s.has(e.name.value)) {
              var n;
              if (d.length) {
                n = d.join(".") + "." + e.name.value;
              } else {
                n = e.name.value;
              }
              f.push(n);
              v.set(n, {
                start: e.name.loc.start,
                length: e.name.loc.end - e.name.loc.start
              });
            } else if (e.selectionSet) {
              d.push(e.name.value);
            }
          },
          leave: e => {
            if (e.selectionSet) {
              d.pop();
            }
          }
        }
      });
      u.forEach((n => {
        if (n.fileName !== e.fileName) {
          return;
        }
        var a = findNode(e, n.textSpan.start);
        while (a && !i.isVariableStatement(a)) {
          a = a.parent;
        }
        if (!a || !i.isVariableStatement(a)) {
          return;
        }
        var [s] = a.declarationList.declarations;
        if (s.name.getText() === l.name.getText()) {
          return;
        }
        var o = s.name;
        if (i.isArrayBindingPattern(o) && i.isBindingElement(o.elements[0])) {
          o = o.elements[0].name;
        }
        if (i.isObjectBindingPattern(o)) {
          var u = traverseDestructuring(o, [], f, e, r);
          c.push(...u);
        } else {
          var d = crawlScope(o, [], f, e, r);
          c.push(...d);
        }
      }));
      if (!c.length) {
        return;
      }
      f.filter((e => !c.includes(e))).forEach((r => {
        var s = v.get(r);
        if (!s) {
          return;
        }
        a.push({
          file: e,
          length: s.length,
          start: n.getStart() + s.start + 1,
          category: i.DiagnosticCategory.Warning,
          code: 52005,
          messageText: `Field '${r}' is not used.`
        });
      }));
    }));
  } catch (e) {
    console.error("[GraphQLSP]: ", e.message, e.stack);
  }
  return a;
};

var an = 52003;

var getColocatedFragmentNames = (e, n) => {
  var r = function findAllImports(e) {
    return e.statements.filter(i.isImportDeclaration);
  }(e);
  var a = {};
  if (r.length) {
    r.forEach((r => {
      if (!r.importClause) {
        return;
      }
      if (r.importClause.name) {
        var s = n.languageService.getDefinitionAtPosition(e.fileName, r.importClause.name.getStart());
        if (s && s.length) {
          var [o] = s;
          if (o.fileName.includes("node_modules")) {
            return;
          }
          var l = getSource(n, o.fileName);
          if (!l) {
            return;
          }
          var u = getFragmentsInSource(l, n).map((e => e.name.value));
          if (u.length && !a[r.moduleSpecifier.getText()]) {
            a[r.moduleSpecifier.getText()] = {
              start: r.moduleSpecifier.getStart(),
              length: r.moduleSpecifier.getText().length,
              fragments: u
            };
          } else if (u.length) {
            a[r.moduleSpecifier.getText()].fragments = a[r.moduleSpecifier.getText()].fragments.concat(u);
          }
        }
      }
      if (r.importClause.namedBindings && i.isNamespaceImport(r.importClause.namedBindings)) {
        var c = n.languageService.getDefinitionAtPosition(e.fileName, r.importClause.namedBindings.getStart());
        if (c && c.length) {
          var [d] = c;
          if (d.fileName.includes("node_modules")) {
            return;
          }
          var f = getSource(n, d.fileName);
          if (!f) {
            return;
          }
          var v = getFragmentsInSource(f, n).map((e => e.name.value));
          if (v.length && !a[r.moduleSpecifier.getText()]) {
            a[r.moduleSpecifier.getText()] = {
              start: r.moduleSpecifier.getStart(),
              length: r.moduleSpecifier.getText().length,
              fragments: v
            };
          } else if (v.length) {
            a[r.moduleSpecifier.getText()].fragments = a[r.moduleSpecifier.getText()].fragments.concat(v);
          }
        }
      } else if (r.importClause.namedBindings && i.isNamedImportBindings(r.importClause.namedBindings)) {
        r.importClause.namedBindings.elements.forEach((i => {
          var s = n.languageService.getDefinitionAtPosition(e.fileName, i.getStart());
          if (s && s.length) {
            var [o] = s;
            if (o.fileName.includes("node_modules")) {
              return;
            }
            var l = getSource(n, o.fileName);
            if (!l) {
              return;
            }
            var u = getFragmentsInSource(l, n).map((e => e.name.value));
            if (u.length && !a[r.moduleSpecifier.getText()]) {
              a[r.moduleSpecifier.getText()] = {
                start: r.moduleSpecifier.getStart(),
                length: r.moduleSpecifier.getText().length,
                fragments: u
              };
            } else if (u.length) {
              a[r.moduleSpecifier.getText()].fragments = a[r.moduleSpecifier.getText()].fragments.concat(u);
            }
          }
        }));
      }
    }));
  }
  return a;
};

function getFragmentsInSource(e, n) {
  var r = [];
  findAllCallExpressions(e, n, !1).nodes.forEach((i => {
    var a = resolveTemplate(i, e.fileName, n).combinedText;
    try {
      var s = parse(a, {
        noLocation: !0
      });
      if (s.definitions.every((e => e.kind === d.FRAGMENT_DEFINITION))) {
        r = r.concat(s.definitions);
      }
    } catch (e) {
      return;
    }
  }));
  return r;
}

var sn = new Set([ "populate", "client", "_unmask", "_optional", "_relayPagination", "_simplePagination", "_required", "optional", "required", "arguments", "argumentDefinitions", "connection", "refetchable", "relay", "required", "inline" ]);

var on = /Unknown directive "@([^)]+)"/g;

var ln = new LRUCache({
  ttl: 9e5,
  max: 5e3
});

function getGraphQLDiagnostics(e, n, r) {
  var a = r.config.templateIsCallExpression ?? !0;
  var s = getSource(r, e);
  if (!s) {
    return;
  }
  var o, l = [];
  if (a) {
    var u = findAllCallExpressions(s, r);
    l = u.fragments;
    o = u.nodes;
  } else {
    o = function findAllTaggedTemplateNodes(e) {
      var n = [];
      !function find(e) {
        if (i.isTaggedTemplateExpression(e) && Yt.has(e.tag.getText()) || i.isNoSubstitutionTemplateLiteral(e) && i.isTaggedTemplateExpression(e.parent) && Yt.has(e.parent.tag.getText())) {
          n.push(e);
          return;
        } else {
          i.forEachChild(e, find);
        }
      }(e);
      return n;
    }(s);
  }
  var c = o.map((n => {
    if ((i.isNoSubstitutionTemplateLiteral(n) || i.isTemplateExpression(n)) && !a) {
      if (i.isTaggedTemplateExpression(n.parent)) {
        n = n.parent;
      } else {
        return;
      }
    }
    return resolveTemplate(n, e, r).combinedText;
  }));
  var d = nn(a ? s.getText() + l.map((e => print(e))).join("-") + n.version : c.join("-") + n.version);
  var f;
  if (ln.has(d)) {
    f = ln.get(d);
  } else {
    f = runDiagnostics(s, {
      nodes: o,
      fragments: l
    }, n, r);
    ln.set(d, f);
  }
  var v = [];
  if (a && (r.config.shouldCheckForColocatedFragments ?? !0)) {
    var h = getColocatedFragmentNames(s, r);
    var m = new Set;
    o.forEach((e => {
      try {
        visit(parse(e.getText().slice(1, -1), {
          noLocation: !0
        }), {
          FragmentSpread: e => {
            m.add(e.name.value);
          }
        });
      } catch (e) {}
    }));
    Object.keys(h).forEach((e => {
      var {fragments: n, start: r, length: a} = h[e];
      var o = Array.from(new Set(n.filter((e => !m.has(e)))));
      if (o.length) {
        v.push({
          file: s,
          length: a,
          start: r,
          category: i.DiagnosticCategory.Warning,
          code: an,
          messageText: `Unused co-located fragment definition(s) "${o.join(", ")}" in ${e}`
        });
      }
    }));
    return [ ...f, ...v ];
  } else {
    return f;
  }
}

var runDiagnostics = (e, {nodes: n, fragments: r}, a, s) => {
  var o = e.fileName;
  var l = s.config.templateIsCallExpression ?? !0;
  var u = n.map((e => {
    var n = e;
    if (!l && (i.isNoSubstitutionTemplateLiteral(n) || i.isTemplateExpression(n))) {
      if (i.isTaggedTemplateExpression(n.parent)) {
        n = n.parent;
      } else {
        return;
      }
    }
    var {combinedText: u, resolvedSpans: c} = resolveTemplate(n, o, s);
    var f = u.split("\n");
    var v = !1;
    if (i.isAsExpression(n.parent)) {
      if (i.isExpressionStatement(n.parent.parent)) {
        v = !0;
      }
    } else if (i.isExpressionStatement(n.parent)) {
      v = !0;
    }
    var h = n.getStart() + (l ? 0 : n.tag.getText().length + (v ? 2 : 0));
    var m = h + n.getText().length;
    var g = [ ...r ];
    if (l) {
      try {
        var y = parse(u, {
          noLocation: !0
        }).definitions.filter((e => e.kind === d.FRAGMENT_DEFINITION));
        g = g.filter((e => !y.some((n => n.kind === d.FRAGMENT_DEFINITION && n.name.value === e.name.value))));
      } catch (e) {}
    }
    var T = getDiagnostics(u, a.current, void 0, void 0, g).filter((e => {
      if (!e.message.includes("Unknown directive")) {
        return !0;
      }
      var [n] = e.message.split("(");
      var r = on.exec(n);
      if (!r) {
        return !0;
      }
      return !sn.has(r[1]);
    })).map((e => {
      var {start: n, end: r} = e.range;
      var i = h + n.line;
      for (var a = 0; a <= n.line; a++) {
        if (a === n.line) {
          i += n.character;
        } else if (f[a]) {
          i += f[a].length;
        }
      }
      var s = h + r.line;
      for (var o = 0; o <= r.line; o++) {
        if (o === r.line) {
          s += r.character;
        } else if (f[o]) {
          s += f[o].length;
        }
      }
      var l = c.find((e => i >= e.new.start && s <= e.new.start + e.new.length));
      if (l) {
        return {
          ...e,
          start: l.original.start,
          length: l.original.length
        };
      } else if (i > m) {
        var u = c.filter((e => e.new.start + e.new.length < i)).reduce(((e, n) => e + (n.new.length - n.original.length)), 0);
        i -= u;
        s -= u;
        return {
          ...e,
          start: i + 1,
          length: s - i
        };
      } else {
        return {
          ...e,
          start: i + 1,
          length: s - i
        };
      }
    })).filter((e => e.start + e.length <= m));
    try {
      var E = parse(u, {
        noLocation: !0
      });
      if (E.definitions.some((e => e.kind === d.OPERATION_DEFINITION))) {
        if (!E.definitions.find((e => e.kind === d.OPERATION_DEFINITION)).name) {
          T.push({
            message: "Operation needs a name for types to be generated.",
            start: n.getStart(),
            code: 52002,
            length: e.getText().length,
            range: {},
            severity: 2
          });
        }
      }
    } catch (e) {}
    return T;
  })).flat().filter(Boolean);
  var c = u.map((n => ({
    file: e,
    length: n.length,
    start: n.start,
    category: 2 === n.severity ? i.DiagnosticCategory.Warning : i.DiagnosticCategory.Error,
    code: "number" == typeof n.code ? n.code : 2 === n.severity ? 52004 : 52001,
    messageText: n.message.split("\n")[0]
  })));
  if (l) {
    var f = checkFieldUsageInFile(e, n, s);
    return [ ...c, ...f ];
  } else {
    return c;
  }
};

function create(a) {
  var logger = e => a.project.projectService.logger.info(`[GraphQLSP] ${e}`);
  var s = a.config;
  logger("config: " + JSON.stringify(s));
  if (!s.schema) {
    logger('Missing "schema" option in configuration.');
    throw new Error("Please provide a GraphQL Schema!");
  }
  logger("Setting up the GraphQL Plugin");
  if (s.template) {
    Yt.add(s.template);
  }
  var o = function createBasicDecorator(e) {
    var n = Object.create(null);
    var _loop = function() {
      var i = e.languageService[r];
      n[r] = (...n) => i.apply(e.languageService, n);
    };
    for (var r of Object.keys(e.languageService)) {
      _loop();
    }
    return n;
  }(a);
  var l = ((i, a, s, o) => {
    var l = {
      current: null,
      version: 0,
      prev: null
    };
    var u;
    var c;
    try {
      if ("object" == typeof a) {
        u = new URL(a.url);
        c = {
          headers: a.headers
        };
      } else {
        u = new URL(a);
      }
    } catch (v) {}
    if (u) {
      var pollSchema = () => {
        o(`Fetching introspection from ${u.toString()}`);
        e(u.toString(), {
          method: "POST",
          headers: c ? {
            ...c.headers || {},
            "Content-Type": "application/json"
          } : {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            query: getIntrospectionQuery({
              descriptions: !0,
              schemaDescription: !1,
              inputValueDeprecation: !1,
              directiveIsRepeatable: !1,
              specifiedByUrl: !1
            })
          })
        }).then((e => {
          o(`Got response ${e.statusText} ${e.status}`);
          if (e.ok) {
            return e.json();
          } else {
            return e.text();
          }
        })).then((e => {
          if ("string" == typeof e) {
            o(`Got error while fetching introspection ${e}`);
          } else if (e.data) {
            var n = e.data;
            var r = JSON.stringify(n);
            if (l.prev && l.prev === r) {
              return;
            }
            l.prev = r;
            try {
              if (s) {
                saveTadaIntrospection(i, n, s, o);
              }
              l.current = buildClientSchema(n);
              l.version = l.version + 1;
              o(`Got schema for ${u.toString()}`);
            } catch (e) {
              o(`Got schema error for ${e.message}`);
            }
          } else {
            o(`Got invalid response ${JSON.stringify(e)}`);
          }
        }));
      };
      pollSchema();
      setInterval((() => {
        pollSchema();
      }), 6e4);
    } else if ("string" == typeof a) {
      var d = ".json" === n.extname(a);
      var f = n.resolve(n.dirname(i), a);
      o(`Getting schema from ${f}`);
      async function readSchema() {
        var e = r.readFileSync(f, "utf-8");
        var n = d ? JSON.parse(e) : buildSchema(e);
        l.version = l.version + 1;
        l.current = "__schema" in n ? buildClientSchema(n) : n;
        if (s) {
          saveTadaIntrospection(i, n, s, o);
        }
      }
      readSchema();
      r.watchFile(f, (() => {
        readSchema();
      }));
      o(`Got schema and initialized watcher for ${a}`);
    }
    return l;
  })(a.project.getProjectName(), s.schema, s.tadaOutputLocation, logger);
  o.getSemanticDiagnostics = e => {
    var n = a.languageService.getSemanticDiagnostics(e);
    var r = getGraphQLDiagnostics(e, l, a);
    return r ? [ ...r, ...n ] : n;
  };
  o.getCompletionsAtPosition = (e, n, r) => {
    var i = getGraphQLCompletions(e, n, l, a);
    if (i && i.entries.length) {
      return i;
    } else {
      return a.languageService.getCompletionsAtPosition(e, n, r) || {
        isGlobalCompletion: !1,
        isMemberCompletion: !1,
        isNewIdentifierLocation: !1,
        entries: []
      };
    }
  };
  o.getQuickInfoAtPosition = (e, n) => {
    var r = function getGraphQLQuickInfo(e, n, r, a) {
      var s = a.config.templateIsCallExpression ?? !0;
      var o = getSource(a, e);
      if (!o) {
        return;
      }
      var l = findNode(o, n);
      if (!l) {
        return;
      }
      l = s ? bubbleUpCallExpression(l) : bubbleUpTemplate(l);
      var u, c;
      if (i.isCallExpression(l) && s && Yt.has(l.expression.getText()) && l.arguments.length > 0 && i.isNoSubstitutionTemplateLiteral(l.arguments[0])) {
        var d = getToken(l.arguments[0], n);
        if (!r.current || !d) {
          return;
        }
        c = l.arguments[0].getText();
        u = new Cursor(d.line, d.start - 1);
      } else if (i.isTaggedTemplateExpression(l)) {
        var {template: f, tag: v} = l;
        if (!i.isIdentifier(v) || !Yt.has(v.text)) {
          return;
        }
        var h = getToken(f, n);
        if (!h || !r.current) {
          return;
        }
        var {combinedText: m, resolvedSpans: g} = resolveTemplate(l, e, a);
        var y = g.filter((e => e.original.start < n && e.original.start + e.original.length < n)).reduce(((e, n) => e + (n.lines - 1)), 0);
        h.line = h.line + y;
        c = m;
        u = new Cursor(h.line, h.start - 1);
      } else {
        return;
      }
      var T = getHoverInformation(r.current, c, u);
      return {
        kind: i.ScriptElementKind.label,
        textSpan: {
          start: n,
          length: 1
        },
        kindModifiers: "text",
        documentation: Array.isArray(T) ? T.map((e => ({
          kind: "text",
          text: e
        }))) : [ {
          kind: "text",
          text: T
        } ]
      };
    }(e, n, l, a);
    if (r) {
      return r;
    }
    return a.languageService.getQuickInfoAtPosition(e, n);
  };
  logger("proxy: " + JSON.stringify(o));
  return o;
}

var init = e => {
  init$1(e);
  return {
    create
  };
};

export { init as default };
//# sourceMappingURL=graphqlsp.module.js.map
